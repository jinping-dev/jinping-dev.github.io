<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jinping-dev.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一.基础1.hashmapHashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并且允许null键和null值。不保证顺序。 1.1 7与8的区别hashmap初始容量都是16，扩容因子是0.75倍.当元素的数量达到了16*0.75&#x3D;12的时候，会进行扩容。底层：数组+链表。数组中的元素存放的是entry的引用  jdk8中会将链表转化为红黑树（红黑树的查询插入效率">
<meta property="og:type" content="article">
<meta property="og:title" content="面试准备">
<meta property="og:url" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Jinping&#39;s Blog">
<meta property="og:description" content="一.基础1.hashmapHashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并且允许null键和null值。不保证顺序。 1.1 7与8的区别hashmap初始容量都是16，扩容因子是0.75倍.当元素的数量达到了16*0.75&#x3D;12的时候，会进行扩容。底层：数组+链表。数组中的元素存放的是entry的引用  jdk8中会将链表转化为红黑树（红黑树的查询插入效率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/concurrent1">
<meta property="og:image" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1.png">
<meta property="og:image" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2.png">
<meta property="og:image" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5.png">
<meta property="article:published_time" content="2020-10-22T16:45:13.000Z">
<meta property="article:modified_time" content="2021-07-05T07:47:23.152Z">
<meta property="article:author" content="Jinping">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/concurrent1">

<link rel="canonical" href="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试准备 | Jinping's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8963e74cb35315df308c698224929229";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jinping's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">程序员要常思考</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">21</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">50</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://jinping-dev.github.io/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/image.png">
      <meta itemprop="name" content="Jinping">
      <meta itemprop="description" content="程序员要常思考">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jinping's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试准备
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-23 00:45:13" itemprop="dateCreated datePublished" datetime="2020-10-23T00:45:13+08:00">2020-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-05 15:47:23" itemprop="dateModified" datetime="2021-07-05T15:47:23+08:00">2021-07-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer">

<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h1><h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1.hashmap"></a>1.hashmap</h2><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并且允许null键和null值。不保证顺序。</p>
<h3 id="1-1-7与8的区别"><a href="#1-1-7与8的区别" class="headerlink" title="1.1 7与8的区别"></a>1.1 7与8的区别</h3><p>hashmap初始容量都是16，扩容因子是0.75倍.当元素的数量达到了<code>16*0.75=12</code>的时候，会进行扩容。<br>底层：数组+链表。数组中的元素存放的是entry的引用</p>
<ul>
<li>jdk8中会将链表转化为红黑树（红黑树的查询插入效率介于链表和二叉树之间）</li>
<li>新节点插入链表的顺序不同（jdk7是插入头节点，jdk8因为要遍历链表把链表变为红黑树所以采用插入尾结点）</li>
<li>hash算法简化。因为使用了红黑树，即使散列不均匀查询效率也不会很低。</li>
<li>resize的逻辑修改（jdk7会出现死循环，jdk8不会），resize方法完成了初始化和扩容。</li>
</ul>
<a id="more"></a>
<blockquote>
<p>1.在put的时候一开始初始化的时候要用比阈值大的2的次方数。</p>
</blockquote>
<blockquote>
<p>2.在hash算法中，首先对其key的hashcode进行抑或操作，目的就是控制散列值在数组size中，但是在抑或之后还要对key的hashcode进行右移，目的就是让其高位参与运算，使得散列更为均匀。</p>
</blockquote>
<blockquote>
<p>3.jdk1.7中在对hashmap进行扩容的时候，由于使用的是头插法，就可能会导致出现死循环的问题，发生死锁。因为1.7是循环遍历，1.8是先判断元素是要放在高位还是低位，然后将low的元素和high的元素分别组合起来放到新的扩容数组中</p>
</blockquote>
<blockquote>
<p>4.jdk1.8当hash相同的链表中的node超过阈值（8）的时候并且数组的长度小于64的时候，会进行扩容；如果数组的长度大于64，会将当前下标指向的这个链表转化为红黑树。</p>
</blockquote>
<blockquote>
<p>5.链表转化为红黑树：先比较key的hashcode；如果相同则去看key有没有实现comparable接口，如果实现了则进行比较；如果没有实现或者相同，则会比较key的class的名字；如果key的className相同则会调同<code>System.identityHashcode</code>方法去进行比较jvm内部的hashcode。然后根据插入的元素进行红黑树root节点的调整。一个node节点既是红黑树的节点，同时也是双向链表的节点，因为它继承了hashmap的entry类。扩容的时候遍历双向链表，同样先判断元素是要放在高位还是低位.</p>
</blockquote>
<h3 id="1-2遍历方式"><a href="#1-2遍历方式" class="headerlink" title="1.2遍历方式"></a>1.2遍历方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Iterator</span>&lt;Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">Integer</span>&gt;&gt; entryIterator = map.entrySet().<span class="built_in">iterator</span>();</span><br><span class="line">        <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">Integer</span>&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + next.getKey() + <span class="string">&quot; value=&quot;</span> + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Iterator</span>&lt;<span class="keyword">String</span>&gt; <span class="built_in">iterator</span> = map.keySet().<span class="built_in">iterator</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">iterator</span>.hasNext())&#123;</span><br><span class="line">            <span class="keyword">String</span> key = <span class="built_in">iterator</span>.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-Concurrenthashmap"><a href="#2-Concurrenthashmap" class="headerlink" title="2.Concurrenthashmap"></a>2.Concurrenthashmap</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/concurrent1" alt="concurrent构成"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">    * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line">    */</span><br><span class="line">   final Segment&lt;<span class="keyword">K</span>,V&gt;[] segments;</span><br><span class="line">   transient <span class="keyword">Set</span>&lt;<span class="keyword">K</span>&gt; keySet;</span><br><span class="line">   transient <span class="keyword">Set</span>&lt;<span class="keyword">Map</span>.Entry&lt;<span class="keyword">K</span>,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p><strong>[put]</strong></p>
<ul>
<li><p>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</p>
</li>
<li><p>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</p>
</li>
<li><p>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</p>
</li>
<li><p>最后会解除在 1 中所获取当前 Segment 的锁</p>
</li>
</ul>
<p><strong>[get]</strong></p>
<ul>
<li><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
</li>
<li><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
</li>
<li><p>ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。</p>
</li>
</ul>
<h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p>
<p>其中的 val next 都用了 volatile 修饰，保证了可见性。</p>
<p><strong>[put]</strong></p>
<ul>
<li><p>根据 key 计算出 hashcode 。</p>
</li>
<li><p>判断是否需要进行初始化。</p>
</li>
<li><p>f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
</li>
<li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p>
</li>
<li><p>如果都不满足，则利用 synchronized 锁写入数据。</p>
</li>
<li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p>
</li>
</ul>
<p><strong>[get]</strong></p>
<ul>
<li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p>
</li>
<li><p>如果是红黑树那就按照树的方式获取值。</p>
</li>
<li><p>不满足那就按照链表的方式遍历获取值。</p>
</li>
</ul>
<blockquote>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
</blockquote>
<h2 id="3-内存相关"><a href="#3-内存相关" class="headerlink" title="3.内存相关"></a>3.内存相关</h2><h3 id="3-1-对象在内存中的布局：（4部分）"><a href="#3-1-对象在内存中的布局：（4部分）" class="headerlink" title="3.1 对象在内存中的布局：（4部分）"></a>3.1 对象在内存中的布局：（4部分）</h3><ul>
<li><code>markword</code> :标记字，8字节（64位的话，给8字节），记录的是锁信息、hashcode、gc垃圾回收信息</li>
<li><code>class pointer</code>:类型指针。（创建一个Object类型，就是Object.class）</li>
<li><code>instance data</code>:实例数据，一个类中的成员变量（8种基本数据类型和引用数据类型）</li>
<li><code>padding</code>:对齐，为了能够让上述三部分相加起来的字节数能够让8整除，多添加几个字节，目的是为了提高cpu的利用率。</li>
</ul>
<p>一个Object对象，占16个字节，8个标记字，4个class pointer,还有4个对齐</p>
<h3 id="3-2-锁升级"><a href="#3-2-锁升级" class="headerlink" title="3.2 锁升级"></a>3.2 锁升级</h3><p>java上的实现都是小端在前，大端在后；网络上的实现都是大端在前</p>
<ul>
<li>new出来对象之后，优先上的锁叫偏向锁，偏向第一个进去做事的线程。偏向锁的意思就是当前线程的指针被记录在了markword里面，偏向锁严格来讲不是一把锁，它就是一个标志，表示这个锁归我了。</li>
<li>偏向锁不需要锁竞争，只需要第一个来的线程就直接给他上了这个锁，没有竞争，就少了同步，效率就会提升。</li>
</ul>
<p><strong>为什么要设计偏向锁？</strong></p>
<p>设计偏向锁的原因在于提高效率，因为这个锁相当于给了一个标记，标记它不需要去参与竞争。</p>
<p><strong>如果第二个线程来了怎么办？</strong></p>
<p>1&gt;这个时候锁升级，升级为自旋锁（轻量级锁）。<br>2&gt;自旋锁又会升级为重量级锁</p>
<p><strong>那么什么时候自旋锁会升级为重量级锁？</strong></p>
<p>竞争加剧：有一个线程超过10次自旋，或者自旋线程超过CPU核数的一半，就会升级。1.6之后，加入自适应自旋AdapativeSlefSpinning，JVM自己控制</p>
<h4 id="3-2-1-自旋锁和重量级锁的区别"><a href="#3-2-1-自旋锁和重量级锁的区别" class="headerlink" title="3.2.1 自旋锁和重量级锁的区别"></a>3.2.1 自旋锁和重量级锁的区别</h4><p>自旋是发生在用户空间的，它不经过os对线程的调度。一般来讲，只要调用了<code>wait()</code>、<code>notify()</code>等方法，就进入到了重量级锁的状态了。重量级状态是什么状态呢？这把锁，附着着一个队列，这个队列的专业叫法叫<code>waitSet</code>,<code>waitSet</code>这里面的线程都是排好队的，等着操作系统调度才能拿到锁，这个<code>waitSet</code>就是等待队列。区别就在于，自旋锁是大家相互抢，谁抢着锁算谁的，而重量级锁是大家都进入到一个等待队列中去，等着操作系统老大去进行调度拿锁。自旋锁在等待的时候消耗cpu资源，而重量级锁在等待的时候不需要消耗cpu资源。</p>
<h4 id="3-2-2-偏向锁的时延："><a href="#3-2-2-偏向锁的时延：" class="headerlink" title="3.2.2 偏向锁的时延："></a>3.2.2 偏向锁的时延：</h4><p>偏向锁是在jvm启动之后的4秒后开始启动，偏向锁启动之后，给对象上的偏向锁都是匿名偏向。<code>为什么是4秒？</code>原因是jvm启动的过程一定会有锁竞争，因此就没有必要启动这把偏向锁，等jvm启动之后，再启动偏向锁</p>
<h4 id="3-2-3-偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？"><a href="#3-2-3-偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？" class="headerlink" title="3.2.3 偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？"></a>3.2.3 偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？</h4><p>不一定，因为偏向锁是希望没有锁竞争的，但是如果你明明知道会有锁竞争，还去加偏向锁，没有任何意义。</p>
<blockquote>
<p>注意：偏向锁是锁的类型，可重入锁是锁的机制，两个不是一个概念。</p>
</blockquote>
<h3 id="3-3-volatile关键字"><a href="#3-3-volatile关键字" class="headerlink" title="3.3 volatile关键字"></a>3.3 volatile关键字</h3><p>作用：</p>
<ul>
<li>1、线程间可见<br>  A线程将变量的值更改了，另一个线程需要知道</li>
<li>2、禁止指令重排序<br>  指令重排序：在程序运行中，可能后面的代码比前面的代码先执行（前提是后面的代码不依赖于前面的代码情况下，为了提高cpu利用率，会这样运行）<br>  禁止重排序原理：在两条指令中间加了一层屏障：JSR内存屏障（分四种：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障）<br>  load是读，store是写</li>
</ul>
<h4 id="3-3-1-汇编语言的lock指令"><a href="#3-3-1-汇编语言的lock指令" class="headerlink" title="3.3.1 汇编语言的lock指令:"></a>3.3.1 汇编语言的lock指令:</h4><ul>
<li>用于在多处理器中执行指令时对共享内存的独占使用</li>
<li>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</li>
<li>另外还提供了有序的指令无法越过这个内存屏障的作用。</li>
<li>lock addl实现了volatile的两个作用</li>
</ul>
<h3 id="3-4-Java和go"><a href="#3-4-Java和go" class="headerlink" title="3.4 Java和go"></a>3.4 Java和go</h3><ul>
<li>Java的线程和内核线程是一对一的。</li>
<li>Go的线程和内核是M:N的，而且M远大于N</li>
<li>Java中的线程池：<code>forkjoinPool</code>,每一个线程都有自己的任务队列，但是任务和任务之间它们是不能做同步的，就是说我这个任务执行完了才能执行下一个任务。但是go的routin任务和任务之间是可以同步的，在用户空间模拟了cpu的执行，有类似保存现场恢复现场的功能。</li>
</ul>
<h1 id="二-设计模式"><a href="#二-设计模式" class="headerlink" title="二.设计模式"></a>二.设计模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><h3 id="1-1-饿汉"><a href="#1-1-饿汉" class="headerlink" title="1.1 饿汉"></a>1.1 饿汉</h3><ul>
<li>对外提供一个返回该实例的方法，static用来在jvm启动过程中去创建对象，构造方法私有化，以此来保证在程序运行过程中用到的对象都是只有一个实例。</li>
<li>类加载到内存后，就会实例化一个单例，JVM保证线程安全。</li>
<li>简单实用，推荐使用。</li>
<li>唯一缺点：类装载的时候就完成实例化，不管你是否需要用到它。</li>
</ul>
<h3 id="1-2懒汉："><a href="#1-2懒汉：" class="headerlink" title="1.2懒汉："></a>1.2懒汉：</h3><ul>
<li>什么时候需要用，才会将这个实例给new出来，但是是线程不安全的，因为同一时刻如果多个线程都需要这个实例，产生出来的就不止一个对象，很简单的优化方式就是加synchronized锁，以此来保证只有一个实例。 但是这种锁的粒度太大了，如果在getInstance方法中有业务代码，那么会锁定相关的业务代码。所以就牵涉到一个优化问题</li>
<li>引入DCL：double check lock</li>
</ul>
<p>相关代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Mgr01 &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Mgr01 INSTANCE;</span><br><span class="line">    private Mgr01()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Mgr01 getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (Mgr01.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span> )&#123;</span><br><span class="line">                   <span class="built_in"> INSTANCE </span>= new Mgr01();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DCl不能乱序，所以DCL一定要加volatile。因为在初始化一个对象的时候，在汇编层面有5条指令，大体的流程就是：开辟内存空间-&gt;成员变量初始化-&gt;引用绑定，之所以要用volatile就是为了不让其指令发生重排序，如果不加的话，可能第二步和第三步发生指令重排序，导致成员没有初始化就将引用绑定给变量了，那么其他线程用这个类的实例的时候就会出现问题。</p>
<h1 id="三、存储层"><a href="#三、存储层" class="headerlink" title="三、存储层"></a>三、存储层</h1><h2 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1.Mysql"></a>1.Mysql</h2><h4 id="1-1-隔离级别"><a href="#1-1-隔离级别" class="headerlink" title="1.1 隔离级别"></a>1.1 隔离级别</h4><ul>
<li>读未提交<br>  脏读</li>
<li>读已提交<br>  不可重复读</li>
<li>可重复度*（mysql默认的隔离级别）<br>  幻读</li>
<li>可序列化</li>
</ul>
<h4 id="1-2-事务隔离级别实现原理"><a href="#1-2-事务隔离级别实现原理" class="headerlink" title="1.2 事务隔离级别实现原理"></a>1.2 事务隔离级别实现原理</h4><h5 id="1-2-1-事务隔离的实现-mvcc，多版本并发控制"><a href="#1-2-1-事务隔离的实现-mvcc，多版本并发控制" class="headerlink" title="1.2.1 事务隔离的实现-mvcc，多版本并发控制"></a>1.2.1 事务隔离的实现-mvcc，多版本并发控制</h5><p>在mysql中，不管一个表的数据结构定义成什么样，都会有两个隐藏列：</p>
<ul>
<li>trx_id:每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="mvcc"></p>
<p><strong>mvcc的流程</strong></p>
<ul>
<li>1.事务在查询数据之前，会生成数据库系统当前的一个快照（read view），记录并维护系统当前<code>活跃事务的ID</code>,快照里面存着的是当前时间<code>活跃的事务id</code></li>
<li>2.把快照比作条件用来判断当前事务能够看到哪个版本的数据</li>
<li>3.快照是在<code>查询数据</code>时生成的。</li>
</ul>
<p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="mvcc"></p>
<p>总结：拿着数据比对版本，而不是拿着版本找数据。</p>
<ul>
<li>不同的隔离级别底层就是因为他们的快照不一样。</li>
<li>读未提交就是根本没有快照，每次修改了不用提交就是一个新的版本。每次读都是一次全新的搜索</li>
<li>可重复读是在第一次查询数据的时候生成一次快照，只要我还没提交，我就不会改变我的快照，所以叫可重复读。</li>
<li>序列化就是我不存在快照，就是串行执行，没有并发的概念。</li>
</ul>
<h4 id="1-2-幻读是什么？"><a href="#1-2-幻读是什么？" class="headerlink" title="1.2 幻读是什么？"></a>1.2 幻读是什么？</h4><ul>
<li>幻读主要体现在读-写冲突上，而不可重复读主要体现在读-读冲突上</li>
<li>比如A事务开启之后，读了4条数据，而B事务同时插入了命中A查询条件中的一条数据。A查询之后进行了update，update语句是不会去管快照的，他会直接从B-tree上去读数据，但是这个时候B-tree上有5条数据，它的快照上还是4条，更新之后再次查询，查出了5条，这种现象就是幻读。</li>
<li>为什么是5条？因为在update的时候在trx_id这个隐藏列中有了A事务的事务id，所以在更新之后查询能查得到。</li>
</ul>
<h4 id="1-3-锁"><a href="#1-3-锁" class="headerlink" title="1.3 锁"></a>1.3 锁</h4><ul>
<li>行锁，表锁—-&gt;锁的粒度</li>
<li>乐观锁，悲观锁—-&gt;锁的时机</li>
<li>共享锁，排他锁—-&gt;锁的兼容性</li>
</ul>
<p>mysql的官方文档中有<code>8</code>种锁模式</p>
<ul>
<li>索引锁<br>  记录存在与否和事务加锁成功与否无关，如SELECT * FROM user WHERE id = 5 FOR UPDATE，此时id=5的记录不存在，隔壁事务仍然无法插入记录（假设当前自增的主键id已经是4了）。因为锁定的是索引，故记录实体存在与否没关系。</li>
<li>间隙锁</li>
<li>临键锁<br>  间隙锁一定是开区间，临键锁是是一个左开右闭的区间<br>  间隙锁是不互斥的，即两个事务可以同时持有包含共同间隙的间隙锁。<br>  在RR级别下，如果你使用select … in share mode或者select … for update语句，那么InnoDB会使用临键锁，因而可以防止幻读</li>
<li>共享锁/排他锁</li>
<li>意向共享锁/意向排他锁<br>  共享锁/排他锁都只是行锁，意向共享锁/意向排他锁属于表锁<br>  取得意向共享锁/意向排他锁是取得共享锁/排他锁的前置条件<br>  一个事务在请求共享锁/排他锁时，获取到的结果却可能是行锁，也可能是间隙锁，也可能是临键锁</li>
<li>插入意向锁<br>  插入意向锁是一种特殊的间隙锁<br>  两个事务却不能在同一时间内一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）</li>
<li>自增锁</li>
<li>预测锁<br>  自增锁是一种特殊的表级锁，主要用于事务中插入自增字段，也就是我们最常用的自增主键id。<br>  自增锁有3种模式，决定了并发自增时并发的自增语句如何持有锁</li>
</ul>
<h1 id="四-Java底层"><a href="#四-Java底层" class="headerlink" title="四.Java底层"></a>四.Java底层</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><ul>
<li>引入锁，目的是为了保证数据一致性。</li>
<li>锁住的一定是一个对象，而且同一时刻只能有一个线程拥有锁去做业务逻辑处理</li>
</ul>
<h2 id="2-不持有锁的线程怎么办？"><a href="#2-不持有锁的线程怎么办？" class="headerlink" title="2.不持有锁的线程怎么办？"></a>2.不持有锁的线程怎么办？</h2><ul>
<li>自旋：轻量级锁。</li>
<li>进入等待队列，等待操作系统调度，这个时候是重量级锁。</li>
</ul>
<h2 id="3-synchronized关键字"><a href="#3-synchronized关键字" class="headerlink" title="3.synchronized关键字"></a>3.synchronized关键字</h2><ul>
<li>1.在早期1.0~1.2的时候，操作系统会接管对应的线程，是个重量级锁，效率非常低。</li>
<li>2.jdk1.5之后，诞生了<code>JUC</code>包</li>
<li>3.锁升级：偏向锁（没有竞争）—&gt;轻量级锁（重量级锁）—&gt;重量级锁</li>
</ul>
<h3 id="3-1-AtomicInteger"><a href="#3-1-AtomicInteger" class="headerlink" title="3.1 AtomicInteger"></a>3.1 AtomicInteger</h3><ul>
<li><code>incrementAndGet()</code>用到的就是自旋锁。在这个方法的底层调用的是<code>compareAndSwapInt</code>，比较并交换，简写为<code>CAS</code>.</li>
</ul>
<p><strong>什么叫CAS？</strong></p>
<p>CAS不需要操作系统的调度，只需要在用户空间即可解决。<br><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="cas"></p>
<h3 id="3-2-CAS两大面试题"><a href="#3-2-CAS两大面试题" class="headerlink" title="3.2 CAS两大面试题"></a>3.2 CAS两大面试题</h3><h4 id="3-2-1-ABA问题加版本号即可解决"><a href="#3-2-1-ABA问题加版本号即可解决" class="headerlink" title="3.2.1 ABA问题加版本号即可解决"></a>3.2.1 ABA问题加版本号即可解决</h4><h4 id="3-2-2-CAS修改值的时候的原子性问题"><a href="#3-2-2-CAS修改值的时候的原子性问题" class="headerlink" title="3.2.2 CAS修改值的时候的原子性问题"></a>3.2.2 CAS修改值的时候的原子性问题</h4><ul>
<li>Q:当线程A在判断原值E是否是原值之后，还没有修改之前，如何保证没有其他线程B对其变量进行修改？</li>
<li>A:CAS在最底层是用<code>lock cmpxchg</code>指令来支撑的。在多核cpu下，lock指令是锁总线的作用。最终的CAS实现就是这条指令。</li>
</ul>
<h2 id="4-生成一个对象的过程？"><a href="#4-生成一个对象的过程？" class="headerlink" title="4.生成一个对象的过程？"></a>4.生成一个对象的过程？</h2><p>至少需要三步：</p>
<ul>
<li>1.申请内存空间，用来装new出来的对象。</li>
<li>2.调用构造方法，从默认值变成初始值，此时是半初始化状态</li>
<li>3.建立引用连接</li>
</ul>
<h2 id="5-happens-before原则（JVM规定重排序必须遵守的原则）"><a href="#5-happens-before原则（JVM规定重排序必须遵守的原则）" class="headerlink" title="5.happens-before原则（JVM规定重排序必须遵守的原则）"></a>5.happens-before原则（JVM规定重排序必须遵守的原则）</h2><ul>
<li><code>as if serial</code>:不管如何重排序，单线程执行结果不会改变</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    支持一下呗
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat1.png" alt="Jinping 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Jinping 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

  <div class="followme">
    <p>有问题随时找我，加我微信~</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/111.png">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"><i class="fa fa-tag"></i> 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="prev" title="线上问题的定位与解决方案">
      <i class="fa fa-chevron-left"></i> 线上问题的定位与解决方案
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="多线程相关面试题">
      多线程相关面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MjcwNy8yOTE4NA=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E5%9F%BA%E7%A1%80"><span class="nav-text">一.基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-hashmap"><span class="nav-text">1.hashmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-7%E4%B8%8E8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.1 7与8的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">1.2遍历方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Concurrenthashmap"><span class="nav-text">2.Concurrenthashmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk1-7"><span class="nav-text">jdk1.7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk1-8"><span class="nav-text">jdk1.8</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-text">3.内存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B8%83%E5%B1%80%EF%BC%9A%EF%BC%884%E9%83%A8%E5%88%86%EF%BC%89"><span class="nav-text">3.1 对象在内存中的布局：（4部分）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-text">3.2 锁升级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.2.1 自旋锁和重量级锁的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%97%B6%E5%BB%B6%EF%BC%9A"><span class="nav-text">3.2.2 偏向锁的时延：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%95%88%E7%8E%87%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E5%AE%9A%E6%AF%94%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F%E6%89%93%E5%BC%80%E5%81%8F%E5%90%91%E9%94%81%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%88%E7%8E%87%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="nav-text">3.2.3 偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">3.3 volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84lock%E6%8C%87%E4%BB%A4"><span class="nav-text">3.3.1 汇编语言的lock指令:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-Java%E5%92%8Cgo"><span class="nav-text">3.4 Java和go</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">二.设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-text">1.单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E9%A5%BF%E6%B1%89"><span class="nav-text">1.1 饿汉</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E6%87%92%E6%B1%89%EF%BC%9A"><span class="nav-text">1.2懒汉：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AD%98%E5%82%A8%E5%B1%82"><span class="nav-text">三、存储层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Mysql"><span class="nav-text">1.Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-text">1.1 隔离级别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">1.2 事务隔离级别实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-1-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0-mvcc%EF%BC%8C%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-text">1.2.1 事务隔离的实现-mvcc，多版本并发控制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%B9%BB%E8%AF%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">1.2 幻读是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E9%94%81"><span class="nav-text">1.3 锁</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-Java%E5%BA%95%E5%B1%82"><span class="nav-text">四.Java底层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%94%81"><span class="nav-text">1.锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%8D%E6%8C%81%E6%9C%89%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">2.不持有锁的线程怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">3.synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-AtomicInteger"><span class="nav-text">3.1 AtomicInteger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-CAS%E4%B8%A4%E5%A4%A7%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">3.2 CAS两大面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-ABA%E9%97%AE%E9%A2%98%E5%8A%A0%E7%89%88%E6%9C%AC%E5%8F%B7%E5%8D%B3%E5%8F%AF%E8%A7%A3%E5%86%B3"><span class="nav-text">3.2.1 ABA问题加版本号即可解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-CAS%E4%BF%AE%E6%94%B9%E5%80%BC%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">3.2.2 CAS修改值的时候的原子性问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">4.生成一个对象的过程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-happens-before%E5%8E%9F%E5%88%99%EF%BC%88JVM%E8%A7%84%E5%AE%9A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%BF%85%E9%A1%BB%E9%81%B5%E5%AE%88%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%89"><span class="nav-text">5.happens-before原则（JVM规定重排序必须遵守的原则）</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jinping"
      src="/images/image.png">
  <p class="site-author-name" itemprop="name">Jinping</p>
  <div class="site-description" itemprop="description">程序员要常思考</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/jinping-dev" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;jinping-dev" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:jinping0982@163.com" title="E-Mail → mailto:jinping0982@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/9e1f045b3f8d" title="简书 → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;9e1f045b3f8d" rel="noopener" target="_blank"><i class="fa fa-heartbeat fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">©2018 by Jinping</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>
  <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

</body>
</html>
