<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker(一)构建Docker</title>
    <url>/2020/12/02/Docker-%E4%B8%80-%E6%9E%84%E5%BB%BADocker/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、安装虚拟机"><a href="#一、安装虚拟机" class="headerlink" title="一、安装虚拟机"></a>一、安装虚拟机</h3><h5 id="安装vagrant"><a href="#安装vagrant" class="headerlink" title="安装vagrant"></a>安装vagrant</h5><p><a href="https://www.vagrantup.com/">安装vagrant</a></p>
<p>根据自己的电脑操作系统选择最新版本进行安装即可</p>
<h5 id="安装virtualbox"><a href="#安装virtualbox" class="headerlink" title="安装virtualbox"></a>安装virtualbox</h5><p><a href="https://www.virtualbox.org/wiki/Downloads">安装virtualbox</a></p>
<p><strong>vagrant用于构建虚拟机，virtualbox相当于是一个虚拟机管理工具</strong></p>
<a id="more"></a>

<h5 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h5><p>依次执行如下命令：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">cd</span> <span class="string">local</span></span><br><span class="line"><span class="attr">mkdir</span> <span class="string">centos7</span></span><br><span class="line"><span class="attr">vagrant</span> <span class="string">init centos/7</span></span><br></pre></td></tr></table></figure>
<p>即可在当前目录下看到有一个<code>Vagrantfile</code>文件生成</p>
<p>然后运行<code>vagrant up</code>命令进行构建虚拟机（需要有点耐心）</p>
<p>构建完毕会在当前目录下生成一个文件夹：</p>
<p><img src="/2020/12/02/Docker-%E4%B8%80-%E6%9E%84%E5%BB%BADocker/vagrant.png" alt="构建vagrant"></p>
<p>然后在virtualbox程序中，会有相应的虚拟机生成：</p>
<p><img src="/2020/12/02/Docker-%E4%B8%80-%E6%9E%84%E5%BB%BADocker/box1.png" alt="虚拟机"></p>
<h3 id="二、安装Docker"><a href="#二、安装Docker" class="headerlink" title="二、安装Docker"></a>二、安装Docker</h3><p>参考官方文档：<a href="https://docs.docker.com/">Docker官方文档</a></p>
<p><img src="/2020/12/02/Docker-%E4%B8%80-%E6%9E%84%E5%BB%BADocker/doc.png" alt="虚拟机"></p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p>在当前文件夹下，使用命令<code>vagrant ssh</code>进入构建出来的虚拟机，然后执行如下命令构建Docker：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="built_in">remove</span> docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br><span class="line">sudo yum install -<span class="keyword">y</span> yum-utils</span><br><span class="line">sudo yum-config-manager     --<span class="built_in">add</span>-repo     http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br><span class="line">sudo yum install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<p>到此为止，docker就创建成功并且启动了<br>运行命令:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="keyword">run</span><span class="bash"> hello-world</span></span><br></pre></td></tr></table></figure>
<p>可以看到如下信息<br><img src="/2020/12/02/Docker-%E4%B8%80-%E6%9E%84%E5%BB%BADocker/word.png" alt="helloWorld"></p>
<p>将vagrant添加到docker用户组中</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo gpasswd -a vagrant docker</span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>
<p>重启之后，再次<code>vagrant ssh</code>进入虚拟机，运行docker命令就不必加sudo了</p>
<h3 id="三、vagrant相关命令"><a href="#三、vagrant相关命令" class="headerlink" title="三、vagrant相关命令"></a>三、vagrant相关命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">vagrant init</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">vagrant up</td>
<td align="center">启动虚拟机</td>
</tr>
<tr>
<td align="center">vagrant halt</td>
<td align="center">关闭虚拟机</td>
</tr>
<tr>
<td align="center">vagrant reload</td>
<td align="center">重启虚拟机</td>
</tr>
<tr>
<td align="center">vagrant ssh</td>
<td align="center">SSH至虚拟机</td>
</tr>
<tr>
<td align="center">vagrant suspend</td>
<td align="center">挂起虚拟机</td>
</tr>
<tr>
<td align="center">vagrant resume</td>
<td align="center">唤醒虚拟机</td>
</tr>
<tr>
<td align="center">vagrant status</td>
<td align="center">查看虚拟机运行状态</td>
</tr>
<tr>
<td align="center">vagrant destroy</td>
<td align="center">销毁当前虚拟机</td>
</tr>
<tr>
<td align="center">vagrant box list</td>
<td align="center">查看本地box列表</td>
</tr>
<tr>
<td align="center">vagrant box add</td>
<td align="center">添加box到列表</td>
</tr>
<tr>
<td align="center">vagrant box remove</td>
<td align="center">从box列表移除</td>
</tr>
</tbody></table>
<h3 id="四、彩蛋"><a href="#四、彩蛋" class="headerlink" title="四、彩蛋"></a>四、彩蛋</h3><p>在我们运行<code>vagrant init centos/7</code>之后，就可以看到在当前目录下生成了<code>Vagrantfile</code>文件</p>
<p>我们可以在运行<code>vagrant up</code>的时候即可让虚拟机构建出一个Docker环境，需要修改<code>Vagrantfile</code>文件<br>如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure</span></span><br><span class="line"><span class="comment"># configures the configuration version (we support older styles for</span></span><br><span class="line"><span class="comment"># backwards compatibility). Please don&#x27;t change it unless you know what</span></span><br><span class="line"><span class="comment"># you&#x27;re doing.</span></span><br><span class="line">Vagrant.configure(&quot;2&quot;) <span class="keyword">do</span> |config|</span><br><span class="line">  <span class="comment"># The most common configuration options are documented and commented below.</span></span><br><span class="line">  <span class="comment"># For a complete reference, please see the online documentation at</span></span><br><span class="line">  <span class="comment"># https://docs.vagrantup.com.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Every Vagrant development environment requires a box. You can search for</span></span><br><span class="line">  <span class="comment"># boxes at https://vagrantcloud.com/search.</span></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Disable automatic box update checking. If you disable this, then</span></span><br><span class="line">  <span class="comment"># boxes will only be checked for updates when the user runs</span></span><br><span class="line">  <span class="comment"># `vagrant box outdated`. This is not recommended.</span></span><br><span class="line">  <span class="comment"># config.vm.box_check_update = false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine. In the example below,</span></span><br><span class="line">  <span class="comment"># accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.</span></span><br><span class="line">  <span class="comment"># <span class="doctag">NOTE:</span> This will enable public access to the opened port</span></span><br><span class="line">  <span class="comment"># config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a forwarded port mapping which allows access to a specific port</span></span><br><span class="line">  <span class="comment"># within the machine from a port on the host machine and only allow access</span></span><br><span class="line">  <span class="comment"># via 127.0.0.1 to disable public access</span></span><br><span class="line">  <span class="comment"># config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080, host_ip: &quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a private network, which allows host-only access to the machine</span></span><br><span class="line">  <span class="comment"># using a specific IP.</span></span><br><span class="line">  <span class="comment"># config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Create a public network, which generally matched to bridged network.</span></span><br><span class="line">  <span class="comment"># Bridged networks make the machine appear as another physical device on</span></span><br><span class="line">  <span class="comment"># your network.</span></span><br><span class="line">  <span class="comment"># config.vm.network &quot;public_network&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Share an additional folder to the guest VM. The first argument is</span></span><br><span class="line">  <span class="comment"># the path on the host to the actual folder. The second argument is</span></span><br><span class="line">  <span class="comment"># the path on the guest to mount the folder. And the optional third</span></span><br><span class="line">  <span class="comment"># argument is a set of non-required options.</span></span><br><span class="line">  <span class="comment"># config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Provider-specific configuration so you can fine-tune various</span></span><br><span class="line">  <span class="comment"># backing providers for Vagrant. These expose provider-specific options.</span></span><br><span class="line">  <span class="comment"># Example for VirtualBox:</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># config.vm.provider &quot;virtualbox&quot; do |vb|</span></span><br><span class="line">  <span class="comment">#   # Display the VirtualBox GUI when booting the machine</span></span><br><span class="line">  <span class="comment">#   vb.gui = true</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment">#   # Customize the amount of memory on the VM:</span></span><br><span class="line">  <span class="comment">#   vb.memory = &quot;1024&quot;</span></span><br><span class="line">  <span class="comment"># end</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># View the documentation for the provider you are using for more</span></span><br><span class="line">  <span class="comment"># information on available options.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable provisioning with a shell script. Additional provisioners such as</span></span><br><span class="line">  <span class="comment"># Ansible, Chef, Docker, Puppet and Salt are also available. Please see the</span></span><br><span class="line">  <span class="comment"># documentation for more information about their specific syntax and use.</span></span><br><span class="line">  <span class="comment"># config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL</span></span><br><span class="line">  <span class="comment">#   apt-get update</span></span><br><span class="line">  <span class="comment">#   apt-get install -y apache2</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, inline: &lt;&lt;-SHELL</span><br><span class="line">  sudo yum remove docker docker-<span class="keyword">client</span> docker-<span class="keyword">client</span>-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-<span class="keyword">engine</span></span><br><span class="line">  sudo yum <span class="keyword">install</span> -y yum-utils</span><br><span class="line">  sudo yum-config-manager -y <span class="comment">--add-repo https://download.docker.com/linux/centos/docker-ce.repo</span></span><br><span class="line">  sudo yum -y <span class="keyword">install</span> docker-ce docker-ce-cli containerd.io</span><br><span class="line">  sudo systemctl <span class="keyword">start</span> docker</span><br><span class="line">  SHELL</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(三)Image概述</title>
    <url>/2020/12/07/Docker-%E4%B8%89-Image%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="什么是Image"><a href="#什么是Image" class="headerlink" title="什么是Image"></a>什么是Image</h3><ul>
<li>文件和meta data的集合（root filesystem）</li>
<li>分层的，并且每一层都可以添加改变删除文件，成为一个新的image</li>
<li>不同的image可以共享相同的layer</li>
<li>Image本身是read-only的</li>
</ul>
<p><img src="/2020/12/07/Docker-%E4%B8%89-Image%E6%A6%82%E8%BF%B0/image.png" alt="image"></p>
<a id="more"></a>

<h3 id="Image的获取"><a href="#Image的获取" class="headerlink" title="Image的获取"></a>Image的获取</h3><ul>
<li>通过Dockerfile构建</li>
<li>从<a href="https://hub.docker.com/">docker Registry</a>获取</li>
</ul>
<h3 id="创建一个helloword-Image"><a href="#创建一个helloword-Image" class="headerlink" title="创建一个helloword-Image"></a>创建一个helloword-Image</h3><p>先安装编译C语言的相关环境，然后在当前目录下，创建helloWorld文件夹，然后新建<code>hello.c</code>文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">yum install -y vim</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum install -y gcc</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">yum install glibc-static</span></span><br><span class="line"><span class="attr">vim</span> <span class="string">hello.c</span></span><br></pre></td></tr></table></figure>
<p>然后在hello.c中，编写c语言程序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sudo yum install glib-<span class="keyword">static</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i&lt; <span class="number">10</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello-docker!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后编译：<code>gcc -static hello.c -o hello</code>,，可以在当前目录下看到多了一个hello的可执行文件<br><img src="/2020/12/07/Docker-%E4%B8%89-Image%E6%A6%82%E8%BF%B0/1.png" alt="1"><br>之后编辑<code>Dockerfile</code>文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hello /</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;/hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>然后进行build，运行</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">sudo docker build -t tinner/hello-world .</span><br><span class="line">sudo docker <span class="keyword">run</span><span class="bash"> tinner/hello-world</span></span><br></pre></td></tr></table></figure>
<p>即可看到输出：<br><img src="/2020/12/07/Docker-%E4%B8%89-Image%E6%A6%82%E8%BF%B0/2.png" alt="2"></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(二)Docker架构及底层技术</title>
    <url>/2020/12/07/Docker-%E4%BA%8C-Docker%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="Docker-Platform"><a href="#Docker-Platform" class="headerlink" title="Docker Platform"></a>Docker Platform</h3><p>Docker提供了一个开发、打包、运行app的平台</p>
<p>它将app和底层infrastructure隔离开来</p>
<p><img src="/2020/12/07/Docker-%E4%BA%8C-Docker%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF/1.png" alt="隔离"></p>
<a id="more"></a>

<h3 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h3><p>Docker Engine 是一个 client-server 应用，它主要有以下几个部分构成：</p>
<ul>
<li>后台进程（dockerd）它是一个长期运行的程序，称之为 daemon process。</li>
<li>REST API server：程序可以通过这些 API 与 daemon 进行通信和指示 daemon 要做什么。</li>
<li>CLI接口（docker）：docker 指令。<br><img src="/2020/12/07/Docker-%E4%BA%8C-Docker%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF/engine.png" alt="engine"></li>
</ul>
<p>CLI 使用 Docker REST API，然后直接通过脚本或者 CLI 命令来控制或者与 Docker daemon 进行交互。</p>
<p>Docker daemon 用于创建和管理 Docker 对象，如 images、containers、networks 以及 volumes。</p>
<h3 id="底层技术支持"><a href="#底层技术支持" class="headerlink" title="底层技术支持"></a>底层技术支持</h3><p>Namespaces：做隔离pid、net、ipc、mnt、uts</p>
<p>Control groups：做资源限制</p>
<p>Union file systems：Container和image的分层</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(五)-Docker的文件存储和数据共享</title>
    <url>/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<p><strong>问题</strong></p>
<p>当我创建了一个容器，在这个容器中我有个mysql服务，在这个mysql里面我有各种各样的数据。但是有一天我一不小心删除了这个容器，那么这个容器中的相关服务以及数据也都没有了。这个时候就出问题了。</p>
<p>我们需要一种数据持久化机制来实现我们容器中数据的存储。</p>
<p><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/1.png" alt="1"></p>
<p>默认情况下docker数据是写在了container里面的，当我们将容器删除掉之后是找不到这个容器里面的文件及恢复的，那么我们可以用一种机制类似于mock的方式去将容器中的数据保存在我们的磁盘上，这样就跟容器隔离开了，进而实现数据持久化。</p>
<a id="more"></a>

<h3 id="Docker持久化数据的两种方案"><a href="#Docker持久化数据的两种方案" class="headerlink" title="Docker持久化数据的两种方案"></a>Docker持久化数据的两种方案</h3><ul>
<li>基于本地文件系统的Volume。可以在执行Docker create或Docker run时，通过-v参数将主机的目录作为容器的数据卷。这部分功能便是基于本地文件系统的volume管理。</li>
<li>基于plugin的Volume，支持第三方的存储方案，比如NAS、aws</li>
</ul>
<h3 id="Volume的类型"><a href="#Volume的类型" class="headerlink" title="Volume的类型"></a>Volume的类型</h3><ul>
<li>受管理的data Volome，由docker后台自动创建</li>
<li>绑定挂载的Volome，具体挂载的位置可以由用户指定</li>
</ul>
<h4 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h4><p>我需要从我本地拷贝几份文件到vagrant的虚拟机中，需要安装vagrant的scp插件<code>vagrant plugin install scp</code>。</p>
<p><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/2.png" alt="2"></p>
<ul>
<li>将本地文件拷贝到虚拟机指定目录中<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">vagrant scp <span class="tag">&lt;<span class="name">目标文件夹路径</span>&gt;</span> vmName:<span class="tag">&lt;<span class="name">虚拟机内文件夹路径</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>注意：&lt;虚拟机内文件夹路径&gt;需要预先开通777权限<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo chmod <span class="number">777</span> &lt;虚拟机内文件夹路径&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><p>1.进入虚拟机，查看volume：<br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/3.png" alt="3"></p>
<p>2.创建一个不需要密码登录的mysql应用</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="builtin-name">run</span> -d --name mysql1 -e <span class="attribute">MYSQL_ALLOW_EMPTY_PASSWORD</span>=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure>
<p>3.查看volume相关信息<br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/4.png" alt="4"><br>可以看到它这个volume映射到了虚拟机内部的路径上去</p>
<p>4.再去创建另一个mysql</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="builtin-name">run</span> -d --name mysql2 -e <span class="attribute">MYSQL_ALLOW_EMPTY_PASSWORD</span>=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure>
<p>再去查看volume可以看到多了一个<br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/5.png" alt="5"></p>
<p>5.现在我去停止并且remove掉两个容器</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> rm -f mysql<span class="number">1</span> mysql<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以发现但是他们的volume还在<br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/5.png" alt="5"></p>
<p><strong>但是又有第二个问题，我们的volume的名字并不是特别友好， 我可以给volume起个别名</strong></p>
<p>6.删除这两个volume</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="bash"> rm &lt;id&gt;</span></span><br></pre></td></tr></table></figure>

<p>7.重新创建，指定别名为mysql</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="builtin-name">run</span> -d -v mysql:/var/lib/mysql --name mysql1 -e <span class="attribute">MYSQL_ALLOW_EMPTY_PASSWORD</span>=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/6.png" alt="6"></p>
<p>可以看到有一个mysql的volume</p>
<p>我们的数据都会同步到这个volume里面去</p>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><ul>
<li><p>进入到mysql1中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it mysql1 /bin/bash</span><br><span class="line">mysql -u root</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> docker;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/7.png" alt="7"></p>
</li>
<li><p>然后退出容器</p>
</li>
<li><p>强制删除mysql1</p>
</li>
<li><p>创建mysql3，使用这个volume</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="builtin-name">run</span> -d -v mysql:/var/lib/mysql --name mysql3 -e <span class="attribute">MYSQL_ALLOW_EMPTY_PASSWORD</span>=<span class="literal">true</span> mysql</span><br></pre></td></tr></table></figure></li>
<li><p>进入容器，可以看到mysql3中有docker这个数据库<br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/8.png" alt="8"></p>
</li>
</ul>
<h3 id="bind-Mounting做地址映射"><a href="#bind-Mounting做地址映射" class="headerlink" title="bind Mounting做地址映射"></a>bind Mounting做地址映射</h3><p>只需要在运行容器的时候去指定我们本地的目录和容器的目录的一一对应关系，通过这种方式可以去同步，让我们本地的目录文件和容器的目录文件是同步的。本质是同一个文件同一个目录做映射。</p>
<p>我这里有个脚本文件Dockerfile</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># this same shows how we can extend/change an existing official image <span class="keyword">from</span> Docker Hub</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> nginx:latest</span><br><span class="line"># highly recommend you <span class="keyword">always</span> pin versions <span class="keyword">for</span> anything beyond dev/learn</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/<span class="keyword">share</span>/nginx/html</span><br><span class="line"># change working directory <span class="keyword">to</span> root <span class="keyword">of</span> nginx webhost</span><br><span class="line"># <span class="keyword">using</span> WORKDIR <span class="keyword">is</span> prefered <span class="keyword">to</span> <span class="keyword">using</span> <span class="string">&#x27;RUN cd /some/path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span> <span class="keyword">index</span>.html <span class="keyword">index</span>.html</span><br><span class="line"></span><br><span class="line"># I don<span class="string">&#x27;t have to specify EXPOSE or CMD because they&#x27;</span>re <span class="keyword">in</span> my <span class="keyword">FROM</span></span><br></pre></td></tr></table></figure>

<p>其实就是创建一个nginx服务，然后将我自定义的index.html覆盖到nginx中<br>构建：</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">docker build -t tinner/mynginx .</span><br></pre></td></tr></table></figure>
<p>做端口映射：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">docker run -d -p <span class="number">80</span>:<span class="number">80</span> --name web tinner/mynginx</span><br></pre></td></tr></table></figure>
<p>然后curl 127.0.0.1<br>可以看到首页就是我写的index.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Docker! <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在本地输入(我的虚拟机ip)：<a href="http://192.168.205.10/%EF%BC%8C%E5%90%8C%E6%A0%B7%E4%B9%9F%E8%83%BD%E7%9C%8B%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2">http://192.168.205.10/，同样也能看到自定义页面</a><br><img src="/2021/02/12/Docker-%E4%BA%94-Docker%E7%9A%84%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/9.png" alt="9"></p>
<p>然后删除这个容器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> web</span><br></pre></td></tr></table></figure>

<h4 id="用bind-Mounting进行映射"><a href="#用bind-Mounting进行映射" class="headerlink" title="用bind Mounting进行映射"></a>用bind Mounting进行映射</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">docker run -d -v <span class="variable">$(</span>pwd)<span class="symbol">:/usr/share/nginx/html</span> -p <span class="number">80:80</span> --name web tinner/mynginx</span><br></pre></td></tr></table></figure>

<p>主要是-v参数，$(pwd)就是我当前虚拟机的目录，冒号后面就是我创建出来的容器的指定目录要与$(pwd)目录进行映射。</p>
<p>然后进入容器</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it web <span class="regexp">/bin/</span>bash</span><br><span class="line">touch docker.txt</span><br></pre></td></tr></table></figure>
<p>退出容器，可以看到在虚拟机内部也生成了一个docker.txt文件，同时在我本地也有一份</p>
<p>这是因为我在构建vagrant的时候指定了</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Vagrant.require_version <span class="string">&quot;&gt;= 1.6.0&quot;</span></span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="symbol">:name</span> =&gt; <span class="string">&quot;docker-host&quot;</span>,</span><br><span class="line">        <span class="symbol">:eth1</span> =&gt; <span class="string">&quot;192.168.205.31&quot;</span>,</span><br><span class="line">        <span class="symbol">:mem</span> =&gt; <span class="string">&quot;1024&quot;</span>,</span><br><span class="line">        <span class="symbol">:cpu</span> =&gt; <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="number">2</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line"></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">  boxes.each <span class="keyword">do</span> <span class="params">|opts|</span></span><br><span class="line">    config.vm.define opts[<span class="symbol">:name</span>] <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">      config.vm.hostname = opts[<span class="symbol">:name</span>]</span><br><span class="line">      config.vm.provider <span class="string">&quot;vmware_fusion&quot;</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">        v.vmx[<span class="string">&quot;memsize&quot;</span>] = opts[<span class="symbol">:mem</span>]</span><br><span class="line">        v.vmx[<span class="string">&quot;numvcpus&quot;</span>] = opts[<span class="symbol">:cpu</span>]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      config.vm.provider <span class="string">&quot;virtualbox&quot;</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">        v.customize [<span class="string">&quot;modifyvm&quot;</span>, <span class="symbol">:id</span>, <span class="string">&quot;--memory&quot;</span>, opts[<span class="symbol">:mem</span>]]</span><br><span class="line">        v.customize [<span class="string">&quot;modifyvm&quot;</span>, <span class="symbol">:id</span>, <span class="string">&quot;--cpus&quot;</span>, opts[<span class="symbol">:cpu</span>]]</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      config.vm.network <span class="symbol">:private_network</span>, <span class="symbol">ip:</span> opts[<span class="symbol">:eth1</span>]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  config.vm.synced_folder <span class="string">&quot;./labs&quot;</span>, <span class="string">&quot;/home/vagrant/labs&quot;</span></span><br><span class="line">  config.vm.provision <span class="string">&quot;shell&quot;</span>, <span class="symbol">privileged:</span> <span class="literal">true</span>, <span class="symbol">path:</span> <span class="string">&quot;./setup.sh&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>在倒数第三行，进行了文件的映射，将本地的labs文件夹映射到了我构建出来的虚拟机的”/home/vagrant/labs”目录下，同时，在虚拟机中构建nginx容器的时候，也指定了文件映射，这三处地方实现了映射，进而实现了数据的存储</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="built_in">config</span>.vm.<span class="keyword">synced_folder </span><span class="string">&quot;./labs&quot;</span>, <span class="string">&quot;/home/vagrant/labs&quot;</span></span><br></pre></td></tr></table></figure>
<p>同时，用这种方式可以实现在我们开发过程中同步查看一些改动</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(六)DockerCompose</title>
    <url>/2021/02/15/Docker-%E5%85%AD-DockerCompose/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="前言：构建一个wordpress"><a href="#前言：构建一个wordpress" class="headerlink" title="前言：构建一个wordpress"></a>前言：构建一个wordpress</h3><h4 id="1-创建MySQL的container"><a href="#1-创建MySQL的container" class="headerlink" title="1.创建MySQL的container"></a>1.创建MySQL的container</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -d --name mysql -v mysql-data:/var/lib/mysql -e <span class="attribute">MYSQL_ROOT_PASSWORD</span>=root -e <span class="attribute">MYSQL_DATABASE</span>=wordpress mysql</span><br></pre></td></tr></table></figure>
<p>声明了我的root用户密码为root，同时创建了一个wordpress的数据库，因为我的mysql是在内部使用的不用对提供服务他们使用的是同一个网络，所以不用做端口映射</p>
<h4 id="2-创建wordpress"><a href="#2-创建wordpress" class="headerlink" title="2.创建wordpress"></a>2.创建wordpress</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -d -e <span class="attribute">WORDPRESS_DB_HOST</span>=mysql:3306 --link mysql -p 8080:80 wordpress</span><br></pre></td></tr></table></figure>

<ul>
<li>-e 需要去指定我们的数据库的host，指定我刚刚启动的mysql的容器，</li>
<li>–link 就是link到我们的mysql里面</li>
<li>-p就是将容器中的80端口映射到我们本地的8080端口</li>
</ul>
<p>这个过程就比较复杂，像有些应用有好多个模块我们可能就需要构建好多个container，对它的创建、管理、启动、停止等操作比较繁琐。我们希望可以将多个容器定义成一个组，对这个组进行统一的管理，于是DockerCompose就出现了，DockerCompose就是为了解决这一问题而诞生的。</p>
<a id="more"></a>

<h3 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h3><ul>
<li>DockerCompose建议用于本地开发去部署</li>
<li>DockerCompose是一个工具</li>
<li>这个工具可以通过一个yml文件定义多容器的docker应用</li>
<li>通过一条命令就可以根据yml文件的定义去创建或管理这多个容器</li>
</ul>
<p><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/1.png" alt="1"></p>
<p>现在有三个版本，推荐使用version3，不同的版本文件格式是不一样的，2跟3的区别不是很大，但是2跟3最大的区别就是version2只能用于单机，version3可以用于多机<br><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/2.png" alt="2"></p>
<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>一个service代表一个container，这个container可以从dockerhub的image来创建，或者从本地的<code>Dockerfile</code>build出来的image来创建</p>
<p>service的启动类似<code>docker run</code>，我们可以给其指定network和volume，所以可以给service指定network和volume的引用</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">version</span>: &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line"><span class="attribute">services:</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line">  wordpress:</span><br><span class="line">    image: wordpress</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">    environment:</span><br><span class="line">      WORDPRESS_DB_HOST: mysql</span><br><span class="line">      WORDPRESS_DB_PASSWORD: root</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line"></span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: root</span><br><span class="line">      MYSQL_DATABASE: wordpress</span><br><span class="line">    volumes:</span><br><span class="line">      - mysql-data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - my-bridge</span><br><span class="line"></span><br><span class="line"><span class="attribute">volumes:</span></span><br><span class="line">  mysql-data:</span><br><span class="line"></span><br><span class="line"><span class="attribute">networks:</span></span><br><span class="line">  my-bridge:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li>第一行声明version的版本是3</li>
<li>在service中定义了两个服务，一个WordPress，一个mysql</li>
<li>image属性定义了我们的image</li>
<li>port做了端口映射</li>
<li>environment声明了两个环境变量</li>
<li>networks指定了我们连接的网络是下面自定义的bridge，</li>
<li>在mysql服务中我引用了自定义mysql-data的volume</li>
</ul>
<h3 id="Dockercompose的安装"><a href="#Dockercompose的安装" class="headerlink" title="Dockercompose的安装"></a>Dockercompose的安装</h3><p>如果使用mac或者windows系统，在安装完docker会默认安装上DockerCompose，但是如果是linux系统就需要独立安装</p>
<p><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/3.png" alt="3"></p>
<p>下载dockercompose的可执行文件然到/usr/local/bin/docker-compose目录下面，命名为docker-compose</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.28.2/docker-compose-$(uname -s)-$(uname -m)&quot;</span> -o <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br></pre></td></tr></table></figure>

<p>下载完之后给它一个可执行的权限</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/4.png" alt="4"></p>
<p>下载完成之后就可以根据默认docker-compose命名的yml文件去进行构建了</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose up</span></span><br></pre></td></tr></table></figure>

<p>如果文件不是按照docker-compose.yml命名的，也可以指定yml文件的名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="tag">&lt;<span class="name">yml文件名</span>&gt;</span> up</span><br></pre></td></tr></table></figure>

<p>查看服务ps，可以看到有两个服务在运行中<br><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/5.png" alt="5"></p>
<p>停止服务：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="built_in">stop</span></span><br></pre></td></tr></table></figure>
<p>也可以进行start启动服务</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="literal">start</span></span><br></pre></td></tr></table></figure>
<p>如果用<code>down</code>命令，则不仅会停止服务，<em>而且会删除里面的所有container</em><br><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/6.png" alt="6"></p>
<p>当我们启动的时候，也可以指定参数-d让其后台启动，不会输出大量的log</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose up -d</span></span><br></pre></td></tr></table></figure>

<p>列举我们compose所定义的image</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose images</span></span><br></pre></td></tr></table></figure>

<p>先build再up，<code>docker-compose build</code>命令可以预先根据dockerfile进行构建，并不会启动，但<code>docker-compose up</code>会在启动之前先构建，构建完成再启动</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker-compose build</span></span><br></pre></td></tr></table></figure>
<p>进入container的bash中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="built_in">exec</span> mysql bash</span><br></pre></td></tr></table></figure>

<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>我们根据docker-compose所创建出来的服务只有一个，我们可以通过scale去进行扩展，比我们可以通过scale可以将对应的服务从一个扩展成三个。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">docker-compose <span class="keyword">up</span> --<span class="keyword">help</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/7.png" alt="7"></p>
<p>对应的命令为：（web应用就是通过redis统计pv访问量的）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker-compose up --scale <span class="attribute">web</span>=3 -d</span><br></pre></td></tr></table></figure>

<p><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/8.png" alt="8"></p>
<p>当我们访问的时候，会进行轮询，内部是通过lb进行负载均衡的，有兴趣的可以看看<strong>HAProxy</strong><br><img src="/2021/02/15/Docker-%E5%85%AD-DockerCompose/9.png" alt="9"><br>scale不仅可以支持扩容，还支持缩容， 我们可以控制scale的数量对其进行控制服务实例的数量。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker(四)Docker的网络空间</title>
    <url>/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>在一台linux机器上，不管创建多少个docker容器，他们都有属于自己的ip地址，并且可以相互ping通访问。</p>
<p>为什么会ping通？其中的原理是什么？</p>
<a id="more"></a>

<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><ul>
<li>创建一个基于busybox的容器<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name test1 busybox <span class="regexp">/bin/</span>sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>输入<code>ip -a </code>命令即可查看当前容器下的网络ip地址和命名空间</li>
</ul>
<h2 id="通过实现linux的network-namespace实现两个namespace相通"><a href="#通过实现linux的network-namespace实现两个namespace相通" class="headerlink" title="通过实现linux的network namespace实现两个namespace相通"></a>通过实现linux的network namespace实现两个namespace相通</h2><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/1.png" alt="1"></p>
<h3 id="创建两个network-namespace"><a href="#创建两个network-namespace" class="headerlink" title="创建两个network namespace"></a>创建两个network namespace</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> ip </span>netns <span class="builtin-name">add</span> test1</span><br><span class="line">sudo<span class="built_in"> ip </span>netns <span class="builtin-name">add</span> test2</span><br><span class="line">sudo<span class="built_in"> ip </span>link <span class="builtin-name">add</span> veth-test1<span class="built_in"> type </span>veth<span class="built_in"> peer </span>name veth-test2</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/2.png" alt="2"></p>
<h3 id="linux下查看network-namespace"><a href="#linux下查看network-namespace" class="headerlink" title="linux下查看network namespace"></a>linux下查看network namespace</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ip link</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/3.png" alt="3"></p>
<p>可以看到多了两个命名空间，但是只有mac地址，没有ip地址，而且他们现在的状态都是down的</p>
<h3 id="将veth-test1接口添加到test1上去，同时将veth-test2接口添加到test2上去"><a href="#将veth-test1接口添加到test1上去，同时将veth-test2接口添加到test2上去" class="headerlink" title="将veth-test1接口添加到test1上去，同时将veth-test2接口添加到test2上去"></a>将veth-test1接口添加到test1上去，同时将veth-test2接口添加到test2上去</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> ip </span>link <span class="builtin-name">set</span> veth-test1 netns test1</span><br></pre></td></tr></table></figure>

<p>然后可以看到本地的network namespace少了一个<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/4.png" alt="4"><br>同时在test1的命名空间里，多了一个<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/5.png" alt="5"></p>
<h3 id="test2同理"><a href="#test2同理" class="headerlink" title="test2同理"></a>test2同理</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> ip </span>link <span class="builtin-name">set</span> veth-test2 netns test2</span><br></pre></td></tr></table></figure>

<h3 id="此时两者的状态"><a href="#此时两者的状态" class="headerlink" title="此时两者的状态"></a>此时两者的状态</h3><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/6.png" alt="6"><br>还是没有ip地址，只有mac地址</p>
<h3 id="分配ip地址"><a href="#分配ip地址" class="headerlink" title="分配ip地址"></a>分配ip地址</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> ip </span>netns exec test1<span class="built_in"> ip </span>addr <span class="builtin-name">add</span> 192.168.1.1/24 dev veth-test1</span><br><span class="line">sudo<span class="built_in"> ip </span>netns exec test2<span class="built_in"> ip </span>addr <span class="builtin-name">add</span> 192.168.1.2/24 dev veth-test2</span><br></pre></td></tr></table></figure>

<h3 id="将两个veth-test端口启动"><a href="#将两个veth-test端口启动" class="headerlink" title="将两个veth-test端口启动"></a>将两个veth-test端口启动</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> ip </span>netns exec test1<span class="built_in"> ip </span>link <span class="builtin-name">set</span> dev veth-test1 up</span><br><span class="line">sudo<span class="built_in"> ip </span>netns exec test2<span class="built_in"> ip </span>link <span class="builtin-name">set</span> dev veth-test2 up</span><br></pre></td></tr></table></figure>

<h3 id="查看两个namespace的ip及状态"><a href="#查看两个namespace的ip及状态" class="headerlink" title="查看两个namespace的ip及状态"></a>查看两个namespace的ip及状态</h3><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/7.png" alt="7"></p>
<p>可以看到都有了ip地址，状态都为up。</p>
<p>可以看到test1能够ping通test2的ip地址</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/8.png" alt="8"></p>
<p><strong>这个实验与docker的container网络实现的原理类似。我们创建一个容器，随之也会创建属于这个容器的network namespace</strong></p>
<h2 id="Docker的网络实现"><a href="#Docker的网络实现" class="headerlink" title="Docker的网络实现"></a>Docker的网络实现</h2><p>我现在有一个容器，基于busybox的一个微型image构建的容器</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/11.png" alt="11"></p>
<p>查看docker的network</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/12.png" alt="12"></p>
<p>查看docker的network的详细信息</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker<span class="built_in"> network </span>inspect a11a8b74c466(network的id)</span><br></pre></td></tr></table></figure>

<p>在输出的信息里面会看到关于test1的相关信息</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/13.png" alt="13"></p>
<p>我们可以知道test1的container连接到了bridge的网络上面。</p>
<p>查看本机的ip信息</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/14.png" alt="14"></p>
<p>再来查看test1的container的ip相关信息</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/15.png" alt="15"></p>
<p>给结论：<strong>test1的eth0@if6与本机的veth821ee0b@if5相对应，container最终要映射到本机的docker0的network namespace上去</strong></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="安装bridge-utils"><a href="#安装bridge-utils" class="headerlink" title="安装bridge-utils"></a>安装bridge-utils</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> bridge-utils</span><br></pre></td></tr></table></figure>

<h4 id="运行命令：brctl-show"><a href="#运行命令：brctl-show" class="headerlink" title="运行命令：brctl show"></a>运行命令：<code>brctl show</code></h4><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/16.png" alt="16"></p>
<p>可以看到我们的veth821ee0b接口连接到了docker0的namespace上 </p>
<h4 id="现在我们再创建一个容器："><a href="#现在我们再创建一个容器：" class="headerlink" title="现在我们再创建一个容器："></a>现在我们再创建一个容器：</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --name test2 busybox <span class="regexp">/bin/</span>sh -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>再次查看网络信息，可以看到多了一个接口</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/17.png" alt="17"></p>
<p>然后看到bridge可以对应到两个container</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/18.png" alt="18"></p>
<p>再来运行命令：<code>brctl show</code></p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/19.png" alt="19"></p>
<p>可以看到我们的veth821ee0b接口以及vethbbbd3b9都连接到了docker0的namespace上 </p>
<h4 id="实现原理的拓扑图"><a href="#实现原理的拓扑图" class="headerlink" title="实现原理的拓扑图"></a>实现原理的拓扑图</h4><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/21.png" alt="21"></p>
<p>两个容器分别是两个不同的network namespace，两者通过docker0进行连接。</p>
<p>单个容器如何访问外网？<strong>通过本机的docker0的network namespace</strong></p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/22.png" alt="22"></p>
<h2 id="容器之间的link"><a href="#容器之间的link" class="headerlink" title="容器之间的link"></a>容器之间的link</h2><p>在实际项目中我们不能总是依赖于ip地址，如果容器之间需要相互访问还可以通过另外一种方式:<strong>link</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d <span class="params">--name</span> test2 <span class="params">--link</span> test1 busybox <span class="string">/bin/sh</span> -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure>
<p>在我们创建容器的时候加参数：<code>--link [容器名]</code><br>即可在我们的容器中不仅可以通过ip地址访问我们想要访问的ip，还可以通过容器名访问<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/23.png" alt="23"><br>我们在容器创建的时候就已经指定了对应的容器了。<br>反过来，在test1里面，如果想访问test2的话是不行的，link是单向的，不是双向的<br>link用的其实并不多。</p>
<h2 id="让容器不连接bridge，连接自定义的network-namespace"><a href="#让容器不连接bridge，连接自定义的network-namespace" class="headerlink" title="让容器不连接bridge，连接自定义的network namespace"></a>让容器不连接bridge，连接自定义的network namespace</h2><p>重新构建test2容器</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/24.png" alt="24"></p>
<h3 id="新建network"><a href="#新建network" class="headerlink" title="新建network"></a>新建network</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker<span class="built_in"> network </span>create -d<span class="built_in"> bridge </span>my-bridge</span><br></pre></td></tr></table></figure>

<p>可以看到多了一个my-bridge</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/25.png" alt="25"></p>
<h3 id="新建容器指定连接我自定义的network"><a href="#新建容器指定连接我自定义的network" class="headerlink" title="新建容器指定连接我自定义的network"></a>新建容器指定连接我自定义的network</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d <span class="params">--name</span> test3 <span class="params">--network</span> my-bridge busybox <span class="string">/bin/sh</span> -c <span class="string">&quot;while true; do sleep 3600; done&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/26.png" alt="26"></p>
<p>可以看到有了interface，在创建test3之前是没有interface的</p>
<h3 id="修改test1和test2连接的network"><a href="#修改test1和test2连接的network" class="headerlink" title="修改test1和test2连接的network"></a>修改test1和test2连接的network</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker<span class="built_in"> network </span>connect my-bridge test2</span><br></pre></td></tr></table></figure>

<p>查看my-bridge的信息<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/27.png" alt="27"><br>查看bridge的信息<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/28.png" alt="28"><br>可以看到test2既连接到了bridge上，又连接到了my-bridge上<br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/29.png" alt="29"></p>
<p>在test2上既可以通过ip地址访问test3，又可以通过test3的名称访问test3，这是因为在用户自定义的bridge上的所有容器之间都是默认加了link去进行相互之间的访问的，而且是双向的。这就是系统默认的bridge和用户自定义bridge的区别，在系统默认的bridge上的container默认是不支持link连接的。</p>
<h2 id="容器的端口映射"><a href="#容器的端口映射" class="headerlink" title="容器的端口映射"></a>容器的端口映射</h2><h3 id="创建一个nginx容器"><a href="#创建一个nginx容器" class="headerlink" title="创建一个nginx容器"></a>创建一个nginx容器</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">run</span> <span class="comment">--name web -d nginx</span></span><br></pre></td></tr></table></figure>

<h3 id="查看ngingx的ip地址"><a href="#查看ngingx的ip地址" class="headerlink" title="查看ngingx的ip地址"></a>查看ngingx的ip地址</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker<span class="built_in"> network </span>inspect bridge</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/31.png" alt="31"></p>
<p>为172.17.0.4</p>
<h3 id="访问nginx"><a href="#访问nginx" class="headerlink" title="访问nginx"></a>访问nginx</h3><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/32.png" alt="32"></p>
<p>可以访问到</p>
<p><strong>如何让我的docker-node1对外提供nginx服务呢？就是端口映射</strong></p>
<h3 id="停止并删除web（nginx）容器"><a href="#停止并删除web（nginx）容器" class="headerlink" title="停止并删除web（nginx）容器"></a>停止并删除web（nginx）容器</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">sudo</span> <span class="string">docker stop web</span></span><br><span class="line"><span class="attr">sudo</span> <span class="string">docker rm web</span></span><br></pre></td></tr></table></figure>

<h3 id="重新构建，但是要加参数"><a href="#重新构建，但是要加参数" class="headerlink" title="重新构建，但是要加参数"></a>重新构建，但是要加参数</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sudo docker run --name web -d -p <span class="number">80</span>:<span class="number">80</span> nginx</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/33.png" alt="33"></p>
<p>由于我在构建的时候指定了我的docker-node1的ip地址为192.168.205.10，所以在我本地的浏览器中访问<a href="http://192.168.205.10/%EF%BC%8C%E5%8D%B3%E5%8F%AF">http://192.168.205.10/，即可</a></p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/34.png" alt="34"></p>
<h2 id="none-network"><a href="#none-network" class="headerlink" title="none network"></a>none network</h2><h3 id="新建一个连接到none的network的容器"><a href="#新建一个连接到none的network的容器" class="headerlink" title="新建一个连接到none的network的容器"></a>新建一个连接到none的network的容器</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d <span class="params">--name</span> none-test <span class="params">--network</span> none busybox <span class="string">/bin/sh</span> -c <span class="string">&quot;while true;do sleep 3600;done&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="查看none的状态"><a href="#查看none的状态" class="headerlink" title="查看none的状态"></a>查看none的状态</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker<span class="built_in"> network </span>inspect none</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/35.png" alt="35"></p>
<p>可以看到没有任何的mac的地址和IP地址</p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it none-test /bin/sh</span><br><span class="line">ip a</span><br></pre></td></tr></table></figure>

<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/36.png" alt="36"></p>
<p>没有任何接口和地址</p>
<h3 id="它的作用？"><a href="#它的作用？" class="headerlink" title="它的作用？"></a>它的作用？</h3><p>可能是在存储一些密码等敏感信息的时候出于安全性考虑只有在容器内部才能进行访问的时候才用这种模式（只是猜测）。对外提供不了服务</p>
<h2 id="host方式"><a href="#host方式" class="headerlink" title="host方式"></a>host方式</h2><h3 id="新建一个连接到none的network的容器-1"><a href="#新建一个连接到none的network的容器-1" class="headerlink" title="新建一个连接到none的network的容器"></a>新建一个连接到none的network的容器</h3><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sudo docker run -d <span class="params">--name</span> host-test <span class="params">--network</span> host busybox <span class="string">/bin/sh</span> -c <span class="string">&quot;while true;do sleep 3600;done&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="查看none的状态-1"><a href="#查看none的状态-1" class="headerlink" title="查看none的状态"></a>查看none的状态</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker<span class="built_in"> network </span>inspect host</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/37.png" alt="37"></p>
<p>同样，也没有任何ip地址和mac地址</p>
<h3 id="进入容器-1"><a href="#进入容器-1" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it none-test /bin/sh</span><br><span class="line">ip a</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/38.png" alt="38"></p>
<p>可以看到与容器的ip状态是一致的</p>
<p>这个容器没有自己的独立的network namespace，它是与我的主机所在的network namespace共享一套。</p>
<p>通过这种方式构建的容器带来的问题：<br><strong>由于是与容器主机共享的network namespace，意味着端口可能会冲突。比如创建两个nginx的container，都绑定到host的network上去，就会出问题</strong></p>
<h2 id="构建复杂app"><a href="#构建复杂app" class="headerlink" title="构建复杂app"></a>构建复杂app</h2><h3 id="创建一个redis容器"><a href="#创建一个redis容器" class="headerlink" title="创建一个redis容器"></a>创建一个redis容器</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -d <span class="comment">--name redis redis</span></span><br></pre></td></tr></table></figure>

<p>为什么没有指定端口映射？</p>
<ul>
<li>是因为我这个redis不是对外提供服务的，而是在我的容器内部进行访问的，没必要暴露到外面</li>
</ul>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="builtin-name">run</span> -d --link redis -p 5000:5000 --name fast-redis -e <span class="attribute">REDIS_HOST</span>=redis jinping/flask-redis</span><br></pre></td></tr></table></figure>
<h3 id="进入服务，可以看到环境变量"><a href="#进入服务，可以看到环境变量" class="headerlink" title="进入服务，可以看到环境变量"></a>进入服务，可以看到环境变量</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker exec -it fast-redis <span class="regexp">/bin/</span>sh</span><br><span class="line">env</span><br></pre></td></tr></table></figure>
<p><strong>-e 是设置环境变量的</strong></p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/39.png" alt="39"></p>
<p>在我们当前容器的内部，是能够ping通redis的</p>
<p>所以当我们执行curl 127.0.0.1:5000时，可以输出相应的pv</p>
<p>当我回到我的vagrant时,由于在容器中指定了端口映射，所以一样可以输出pv</p>
<p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/41.png" alt="41"></p>
<p><strong>推荐：一个模块一个容器，只要搞清楚他们之间的部署关系就可以了</strong><br><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/42.png" alt="42"></p>
<h2 id="处于不同的linux机器间的docker通信"><a href="#处于不同的linux机器间的docker通信" class="headerlink" title="处于不同的linux机器间的docker通信"></a>处于不同的linux机器间的docker通信</h2><p><img src="/2021/01/17/Docker-%E5%9B%9B-Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4/43.png" alt="43"></p>
<p>VXLAN的方式<br>分布式存储：etcd<br><a href="https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks.md">https://github.com/docker/labs/blob/master/networking/concepts/06-overlay-networks.md</a></p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink初识</title>
    <url>/2020/11/02/Flink%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="一-引入Flink的目的"><a href="#一-引入Flink的目的" class="headerlink" title="一.引入Flink的目的"></a>一.引入Flink的目的</h1><ul>
<li>低延迟</li>
<li>高吞吐</li>
<li>结果的准确性和良好的容错性</li>
</ul>
<h1 id="二、例子（实现wordCount）"><a href="#二、例子（实现wordCount）" class="headerlink" title="二、例子（实现wordCount）"></a>二、例子（实现wordCount）</h1><a id="more"></a>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package com.xesonline.demo</span><br><span class="line"></span><br><span class="line">import org.apache.flink.api.scala.&#123;DataSet, ExecutionEnvironment&#125;</span><br><span class="line">import org.apache.flink.api.scala._</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Classname WordCount</span></span><br><span class="line"><span class="comment"> * @Description</span></span><br><span class="line"><span class="comment"> * @Date 2020/11/3 3:06 下午</span></span><br><span class="line"><span class="comment"> * @Created by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//批处理的wordCount</span></span><br><span class="line"><span class="keyword">object</span> WordCount &#123;</span><br><span class="line"></span><br><span class="line">  def main(args: Array<span class="literal">[S<span class="identifier">tring</span>]</span>)&#123;</span><br><span class="line">    <span class="comment">//创建执行环境</span></span><br><span class="line">    <span class="keyword">val</span> env:ExecutionEnvironment= <span class="module-access"><span class="module"><span class="identifier">ExecutionEnvironment</span>.</span></span>getExecutionEnvironment;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> inputPath : String = <span class="string">&quot;/Users/jinping/Desktop/flink/ss-flink-scala/src/main/resources/word.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">val</span> inputDataSet : DataSet<span class="literal">[S<span class="identifier">tring</span>]</span> = env.read<span class="constructor">TextFile(<span class="params">inputPath</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数据进行转换处理，先分词</span></span><br><span class="line">    <span class="keyword">val</span> resultDataset:DataSet<span class="literal">[(S<span class="identifier">tring</span>,I<span class="identifier">nt</span>)]</span> = inputDataSet</span><br><span class="line">      .flat<span class="constructor">Map(<span class="params">_</span>.<span class="params">split</span>(<span class="string">&quot; &quot;</span>)</span>)</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .group<span class="constructor">By(0)</span><span class="comment">//以第一个元素作为key进行分组</span></span><br><span class="line">      .sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    resultDataset.print<span class="literal">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Gateway</title>
    <url>/2020/08/18/Gateway/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="什么是微服务网关"><a href="#什么是微服务网关" class="headerlink" title="什么是微服务网关"></a>什么是微服务网关</h3><p>微服务网关是整个微服务API请求的入口，可以实现日志拦截、权限控制、解决跨域问题、限流、熔断、负载均衡、黑名单与白名单拦截、授权等。</p>
<h3 id="过滤器与网关的区别"><a href="#过滤器与网关的区别" class="headerlink" title="过滤器与网关的区别"></a>过滤器与网关的区别</h3><p>过滤器用于拦截单个服务<br>网关拦截整个的微服务</p>
<h3 id="Zuul与Gateway有那些区别"><a href="#Zuul与Gateway有那些区别" class="headerlink" title="Zuul与Gateway有那些区别"></a>Zuul与Gateway有那些区别</h3><ul>
<li>Zuul网关属于netfix公司开源的产品属于第一代微服务网关</li>
<li>Gateway属于SpringCloud自研发的第二代微服务网关，相比来说SpringCloudGateway性能比Zuul性能要好：</li>
<li>Zuul基于Servlet实现的，阻塞式的Api， 不支持长连接。</li>
<li>SpringCloudGateway基于Spring5（最大的特点就是响应式编程）构建，能够实现响应式非阻塞式的Api，支持长连接，能够更好的整合Spring体系的产品</li>
</ul>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2、配置文件"><a href="#2、配置文件" class="headerlink" title="2、配置文件"></a>2、配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tinner-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#nacos注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">locator:</span></span><br><span class="line">          <span class="comment"># 开启以服务id去注册中心上获取转发地址</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 路由策略</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">tinner</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://tinner-member</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=1</span></span><br><span class="line">          <span class="comment">#匹配规则</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/tinner/**</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何保证微服务接口的安全"><a href="#如何保证微服务接口的安全" class="headerlink" title="如何保证微服务接口的安全"></a>如何保证微服务接口的安全</h3><p><strong>接口分为内网和外网接口</strong></p>
<ul>
<li>外网接口 基于OATUH2.0构建开放平台 比如appid、appsocet获取accesstoken调用接口。</li>
<li>内网接口：都是当前内网中实现通讯，相对于来说比较安全的。<blockquote>
<p>1.需要保证接口幂等性问题（基于Token）<br>2.接口采用安全加密传输 https协议<br>3.防止数据被篡改 md5验证签名<br>4.使用微服务网关实现Api授权认证等、黑名单白名单。<br>5.对我们的接口实现服务的保护 隔离、熔断、降级等等。</p>
</blockquote>
</li>
</ul>
<p>最后使用apiswagger管理我们的微服务接口。</p>
<h3 id="集群架构设计"><a href="#集群架构设计" class="headerlink" title="集群架构设计"></a>集群架构设计</h3><p><strong>问题：如果我们的网关宕机了，会导致整个微服务无法访问，怎么解决？</strong><br>在微服务之前，我们会接入网关，单机的gateway可能会发生宕机的风险，所以我们会接入集群，但是一般不会将请求直接打入到gateway去进行服务的分发，而是在gateway之前加入nginx，让nginx去转发请求到某台gateway服务上去。<br><strong>那么问题又来了：如果nginx宕机了怎么办？</strong><br>解决方案：nginx也加入集群，然后在nginx集群之上加入lvs技术，去实现整个微服务网关的架构<br><strong>关于lvs</strong><br>lvs不可能宕机，因为lvs是一个虚拟ip的技术，ip地址可以进行切换，使用lvs+keeplived可以实现集群的高可用</p>
<h3 id="实现动态网关"><a href="#实现动态网关" class="headerlink" title="实现动态网关"></a>实现动态网关</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>任何配置都实现不用重启网关服务器都可以及时刷新网关配置。</p>
<h4 id="2-方案"><a href="#2-方案" class="headerlink" title="2.方案"></a>2.方案</h4><ul>
<li>基于数据库形式实现，阅读性比较高</li>
<li>基于配置中心实现,不建议使用，阅读性差，需要定义json格式配置</li>
</ul>
<p><strong>注意：</strong>配置中心实现维护性比较差，建议采用数据库形式设计。</p>
<p>网关已经提供了api接口，供我们直接新增和修改</p>
<p><strong>思路：</strong><br>默认加载的时候：</p>
<ul>
<li>&lt;1&gt; 当网关服务启动的时候，从数据库中查询网关的配置</li>
<li>&lt;2&gt; 将数据库的内容读取到网关中</li>
</ul>
<p>网关配置需要更新的：</p>
<ul>
<li>&lt;1&gt; 更新数据库</li>
<li>&lt;2&gt; 调用网关api进行更新</li>
</ul>
<h4 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h4><h5 id="1-mysql表"><a href="#1-mysql表" class="headerlink" title="1)mysql表"></a>1)mysql表</h5><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `tinner_gateway` (</span><br><span class="line">  `id` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `route_id` varchar(11)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `route_name` varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `route_pattern` varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `route_type` varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  `route_url` varchar(255)<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=2<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=latin1;</span><br></pre></td></tr></table></figure>

<h5 id="2-程序代码"><a href="#2-程序代码" class="headerlink" title="2)程序代码"></a>2)程序代码</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @Classname GatewayService</span></span><br><span class="line"><span class="comment"> * @Description</span></span><br><span class="line"><span class="comment"> * @Date 2020/8/20 11:27 上午</span></span><br><span class="line"><span class="comment"> * @Created by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@Service</span><br><span class="line">public <span class="keyword">class</span> GatewayService implements ApplicationEventPublisherAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> RouteDefinitionWriter routeDefinitionWriter;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    <span class="keyword">private</span> TinnerGatewayMapper tinnerGatewayMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void set<span class="constructor">ApplicationEventPublisher(ApplicationEventPublisher <span class="params">applicationEventPublisher</span>)</span> &#123;</span><br><span class="line">        this.publisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init<span class="constructor">AllRoute()</span> &#123;</span><br><span class="line">        <span class="comment">// 从数据库查询配置的网关配置</span></span><br><span class="line">        List&lt;GateWayEntity&gt; gateWayEntities = tinnerGatewayMapper.gate<span class="constructor">WayAll()</span>;</span><br><span class="line">        <span class="keyword">for</span> (GateWayEntity gw : gateWayEntities) &#123;</span><br><span class="line">            load<span class="constructor">Route(<span class="params">gw</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String load<span class="constructor">Route(GateWayEntity <span class="params">gateWayEntity</span>)</span> &#123;</span><br><span class="line">        RouteDefinition definition = <span class="keyword">new</span> <span class="constructor">RouteDefinition()</span>;</span><br><span class="line">        Map&lt;String, String&gt; predicateParams = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        PredicateDefinition predicate = <span class="keyword">new</span> <span class="constructor">PredicateDefinition()</span>;</span><br><span class="line">        FilterDefinition filterDefinition = <span class="keyword">new</span> <span class="constructor">FilterDefinition()</span>;</span><br><span class="line">        Map&lt;String, String&gt; filterParams = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 如果配置路由type为0的话 则从注册中心获取服务</span></span><br><span class="line">        URI uri = null;</span><br><span class="line">        <span class="keyword">if</span> (gateWayEntity.get<span class="constructor">RouteType()</span>.equals(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            uri = uri = <span class="module-access"><span class="module"><span class="identifier">UriComponentsBuilder</span>.</span></span>from<span class="constructor">UriString(<span class="string">&quot;lb://&quot;</span> + <span class="params">gateWayEntity</span>.<span class="params">getRouteUrl</span>()</span> + <span class="string">&quot;/&quot;</span>).build<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">Uri()</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            uri = <span class="module-access"><span class="module"><span class="identifier">UriComponentsBuilder</span>.</span></span>from<span class="constructor">HttpUrl(<span class="params">gateWayEntity</span>.<span class="params">getRouteUrl</span>()</span>).build<span class="literal">()</span>.<span class="keyword">to</span><span class="constructor">Uri()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        URI uri = UriComponentsBuilder.fromUriString(&quot;lb://tinner-member/&quot;).build().toUri();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义的路由唯一的id</span></span><br><span class="line">        definition.set<span class="constructor">Id(<span class="params">gateWayEntity</span>.<span class="params">getRouteId</span>()</span>);</span><br><span class="line">        predicate.set<span class="constructor">Name(<span class="string">&quot;Path&quot;</span>)</span>;</span><br><span class="line">        <span class="comment">//路由转发地址</span></span><br><span class="line">        predicateParams.put(<span class="string">&quot;pattern&quot;</span>, gateWayEntity.get<span class="constructor">Routepattern()</span>);</span><br><span class="line">        predicate.set<span class="constructor">Args(<span class="params">predicateParams</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 名称是固定的, 路径去前缀</span></span><br><span class="line">        filterDefinition.set<span class="constructor">Name(<span class="string">&quot;StripPrefix&quot;</span>)</span>;</span><br><span class="line">        filterParams.put(<span class="string">&quot;_genkey_0&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        filterDefinition.set<span class="constructor">Args(<span class="params">filterParams</span>)</span>;</span><br><span class="line">        definition.set<span class="constructor">Predicates(Arrays.<span class="params">asList</span>(<span class="params">predicate</span>)</span>);</span><br><span class="line">        definition.set<span class="constructor">Filters(Arrays.<span class="params">asList</span>(<span class="params">filterDefinition</span>)</span>);</span><br><span class="line">        definition.set<span class="constructor">Uri(<span class="params">uri</span>)</span>;</span><br><span class="line">        routeDefinitionWriter.save(<span class="module-access"><span class="module"><span class="identifier">Mono</span>.</span></span>just(definition)).subscribe<span class="literal">()</span>;</span><br><span class="line">        this.publisher.publish<span class="constructor">Event(<span class="params">new</span> RefreshRoutesEvent(<span class="params">this</span>)</span>);</span><br><span class="line">        return <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink深入了解</title>
    <url>/2020/11/03/Flink%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="一、Flink运行架构"><a href="#一、Flink运行架构" class="headerlink" title="一、Flink运行架构"></a>一、Flink运行架构</h1><h2 id="1-Flink运行时的组件"><a href="#1-Flink运行时的组件" class="headerlink" title="1.Flink运行时的组件"></a>1.Flink运行时的组件</h2><p>Flink 运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作： 作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager）， 以及分发器（Dispatcher）。因为 Flink 是用 Java 和 Scala 实现的，所以所有组件都会运行在Java 虚拟机上。每个组件的职责如下：</p>
<p><img src="/2020/11/03/Flink%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/1.jpg" alt="Flink深入了解"></p>
<a id="more"></a>

<ul>
<li><strong>JobManager:</strong> 控制一个应用程序执行的主进程，也就是说， 每个应用程序都会被一个不同的JobManager 所控制执行。JobManager 会先接收到要执行的应用程序，这个应用程序会包括： 作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的 JAR 包。JobManager 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。JobManager 会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（ slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager 上。而在运行过程中，JobManager 会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</li>
<li><strong>TaskManager:</strong> Flink 中的工作进程。通常在 Flink 中会有多个 TaskManager 运行，每一个 TaskManager<br>都包含了一定数量的插槽（slots）。插槽的数量限制了 TaskManager 能够执行的任务数量。启动之后， TaskManager 会向资源管理器注册它的插槽；收到资源管理器的指令后， TaskManager 就会将一个或者多个插槽提供给 JobManager 调用。JobManager 就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager 可以跟其它运行同一应用程序的 TaskManager 交换数据。</li>
<li><strong>ResourceManager:</strong> 主要负责管理任务管理器（TaskManager）的插槽（slot），Slot是 Flink 中定义的处理资源单元。Flink 为不同的环境和资源管理工具提供了不同资源管理器，比如YARN、Mesos、K8s，以及 standalone 部署。当 JobManager 申请插槽资源时，ResourceManager 会将有空闲插槽的TaskManager 分配给 JobManager。如果 ResourceManager 没有足够的插槽来满足 JobManager 的请求，它还可以向资源提供平台发起会话，以提供启动 TaskManager 进程的容器。另外，ResourceManager 还负责终止空闲的 TaskManager，释放计算资源。</li>
<li><strong>Dispacher:</strong> 分发器，可以跨作业运行，它为应用提交提供了 REST 接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个 JobManager。由于是 REST 接口，所以 Dispatcher 可以作为集群的一个 HTTP 接入点，这样就能够不受防火墙阻挡。Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。Dispatcher 在架构中可能并不是必需的，这取决于应用提交运行的方式。</li>
</ul>
<h2 id="2-任务提交流程"><a href="#2-任务提交流程" class="headerlink" title="2.任务提交流程"></a>2.任务提交流程</h2><p>我们来看看当一个应用提交执行时，Flink 的各个组件是如何交互协作的：</p>
<p><img src="/2020/11/03/Flink%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/2.png" alt="Flink深入了解"></p>
<p>上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如 YARN，Mesos，Kubernetes，standalone 等），其中一些步骤可以被省略，或是有些组件会运行在同一个 JVM 进程中。</p>
<p>具体地，如果我们将 Flink 集群部署到 YARN 上，那么就会有如下的提交流程：</p>
<p><img src="/2020/11/03/Flink%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/3.png" alt="Flink深入了解"></p>
<p>Flink 任务提交后， Client 向 HDFS 上传 Flink 的 Jar 包和配置， 之后向 Yarn ResourceManager 提交任务， ResourceManager 分配 Container 资源并通知对应的NodeManager 启动 ApplicationMaster， ApplicationMaster 启动后加载 Flink 的 Jar 包和配置构建环境，然后启动 JobManager，之后 ApplicationMaster 向 ResourceManager 申请资源启动 TaskManager ， ResourceManager 分配 Container  资 源 后 ， 由ApplicationMaster 通 知 资 源 所 在 节 点 的 NodeManager 启动 TaskManager ， NodeManager 加载 Flink 的 Jar 包和配置构建环境并启动 TaskManager，TaskManager 启动后向 JobManager 发送心跳包， 并等待 JobManager 向其分配任务。</p>
<h2 id="3-任务调度原理"><a href="#3-任务调度原理" class="headerlink" title="3.任务调度原理"></a>3.任务调度原理</h2><p><img src="/2020/11/03/Flink%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/4.png" alt="Flink深入了解"></p>
<ul>
<li>客户端不是运行时和程序执行的一部分，但它用于准备并发送dataflow(JobGraph)给 Master(JobManager)， 然后， 客户端断开连接或者维持连接以等待接收计算结果。</li>
</ul>
<ul>
<li>当Flink集群启动后,首先会启动<code>一个JobManger和一个或多个的TaskManager</code>。由<code>Client</code>提交任务给<code>JobManager</code>,JobManager再调度任务到各个TaskManager去执行，然后<code>TaskManager</code>将心跳和统计信息汇报给<code>JobManager</code>。<code>TaskManager</code>之间以流的形式进行数据的传输。上述三者均为独立的 JVM 进程。</li>
<li><code>Client</code>为提交Job的客户端，可以是运行在任何机器上（ 与 JobManager 环境连通即可）。提交 Job 后， Client 可以结束进程（ Streaming 的任务），也可以不结束并等待结果返回。</li>
<li><code>JobManager</code>主要负责调度Job并协调<code>Task</code>做<code>checkpoint</code>(职责上很像Storm的Nimbus)。从Client处接收到Job和JAR包等资源后，会生成优化后的执行计划，并以Task的单元调度到各个<code>TaskManager</code>去执行。</li>
<li><code>TaskManager</code>在启动的时候就设置好了槽位数（<code>Slot</code>），每个<code>slot</code>能启动一个Task,Task为线程。从<code>JobManager</code>处接收需要部署的Task，部署启动后，与自己的上游建立Netty连接,接收数据并处理。</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Gateway详解</title>
    <url>/2020/08/20/Gateway%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、词汇表"><a href="#一、词汇表" class="headerlink" title="一、词汇表"></a>一、词汇表</h3><ul>
<li><strong>路由：</strong>是网关基本的模块，分别为id、目标uri、一组谓词+过滤器一起组合而成，如果谓词匹配成功，则路由匹配成功。</li>
<li><strong>谓词：</strong>匹配Http请求参数</li>
<li><strong>过滤器：</strong>对下游的服务器之前和之后实现处理。</li>
</ul>
<a id="more"></a>

<h3 id="二、过滤器举例"><a href="#二、过滤器举例" class="headerlink" title="二、过滤器举例"></a>二、过滤器举例</h3><h4 id="1-匹配时间之后"><a href="#1-匹配时间之后" class="headerlink" title="1.匹配时间之后"></a>1.匹配时间之后</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- id: mayikt</span><br><span class="line">  uri: http:<span class="comment">//www.mayikt.com/</span></span><br><span class="line">  ###匹配规则</span><br><span class="line">  predicates:</span><br><span class="line">    - After=<span class="number">2017</span><span class="number">-01</span><span class="number">-20</span>T17:<span class="number">42</span>:<span class="number">47.789</span><span class="number">-07</span>:<span class="number">00</span>[America/Denver]</span><br></pre></td></tr></table></figure>
<p>此路由与 2017 年 1 月 20 日 17:42 MountainTime（Denver）之后的所有请求相匹配。</p>
<h4 id="2-匹配对应的host"><a href="#2-匹配对应的host" class="headerlink" title="2.匹配对应的host"></a>2.匹配对应的host</h4><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">- id: meite</span><br><span class="line">  uri: http:<span class="comment">//www.tinner.com/</span></span><br><span class="line">  ###匹配规则</span><br><span class="line">  predicates:</span><br><span class="line">    - Host=meta.tinner.com</span><br></pre></td></tr></table></figure>
<p>访问 mete.tinner.com 转发到<a href="http://www.tinner.com/">http://www.tinner.com/</a></p>
<h4 id="3-权重谓词"><a href="#3-权重谓词" class="headerlink" title="3.权重谓词"></a>3.权重谓词</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_high</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">http://www.tinner.com/yushengjun</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">2</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">weight_low</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">http://www.tinner.com</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Weight=group1,</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>根据权重比例实现转发,这条路线会将约80％的流量转发至<a href="http://www.tinner.com/yushengjun%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%BA%A620%EF%BC%85%E7%9A%84%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E8%87%B3http://www.tinner.com%E3%80%82">http://www.tinner.com/yushengjun，并将约20％的流量转发至http://www.tinner.com。</a><br>…<br>还有更多，参考:<a href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#gatewayfilter-factories">官方文档</a></p>
<h3 id="三、GateWay解决跨域的问题"><a href="#三、GateWay解决跨域的问题" class="headerlink" title="三、GateWay解决跨域的问题"></a>三、GateWay解决跨域的问题</h3><p><strong>解决跨域的问题</strong></p>
<ul>
<li>1.HttpClient转发</li>
<li>2.使用过滤器允许接口可以跨域 响应头设置</li>
<li>3.Jsonp 不支持我们的post 属于前端解决</li>
<li>4.Nginx解决跨域的问题保持我们域名和端口一致性</li>
<li>5.Nginx也是通过配置文件解决跨域的问题</li>
<li>6.基于微服务网关解决跨域问题，需要保持域名和端口一致性</li>
<li>7.使用网关代码允许所有的服务可以跨域的问题</li>
<li>8.使用SpringBoot注解形式@CrossOrigin</li>
</ul>
<p>网关代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">*/</span><br><span class="line">@Component</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> CrossOriginFilter implements GlobalFilter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="built_in">public</span> Mono&lt;<span class="type">Void</span>&gt; <span class="keyword">filter</span>(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line">        HttpHeaders headers = response.getHeaders();</span><br><span class="line">        headers.<span class="keyword">add</span>(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, &quot;*&quot;);</span><br><span class="line">        headers.<span class="keyword">add</span>(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS, &quot;POST, GET, PUT, OPTIONS, DELETE, PATCH&quot;);</span><br><span class="line">        headers.<span class="keyword">add</span>(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, &quot;true&quot;);</span><br><span class="line">        headers.<span class="keyword">add</span>(HttpHeaders.ACCESS_CONTROL_ALLOW_HEADERS, &quot;*&quot;);</span><br><span class="line">        headers.<span class="keyword">add</span>(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, &quot;*&quot;);</span><br><span class="line">        <span class="keyword">return</span> chain.<span class="keyword">filter</span>(exchange);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、网关GateWay源码分析"><a href="#四、网关GateWay源码分析" class="headerlink" title="四、网关GateWay源码分析"></a>四、网关GateWay源码分析</h3><ul>
<li>1.客户端向网关发送Http请求，会到达<code>DispatcherHandler</code>接受请求，匹配到<code>RoutePredicateHandlerMapping</code>。</li>
<li>2.根据RoutePredicateHandlerMapping匹配到具体的路由策略。</li>
<li>3.FilteringWebHandler获取的路由的GatewayFilter数组，创建 GatewayFilterChain 处理过滤请求执行我们的代理业务逻辑访问。<br><img src="/2020/08/20/Gateway%E8%AF%A6%E8%A7%A3/1.png" alt="Gateway详解1"></li>
</ul>
<h4 id="SpringBoot项目源码的入口"><a href="#SpringBoot项目源码的入口" class="headerlink" title="SpringBoot项目源码的入口"></a>SpringBoot项目源码的入口</h4><ul>
<li>1.GatewayClassPathWarningAutoConfiguration—–&gt;检查是否配置我们webfux依赖。</li>
<li>2.GatewayAutoConfiguration—–&gt;核心配置类加载了我们Gateway需要的注入的类。</li>
<li>3.GatewayLoadBalancerClientAutoConfiguration—–&gt;网关需要使用的负载均衡(Lb//“服务名”  根据服务名称查找真实地址)</li>
<li>4.GatewayRedisAutoConfiguration—–&gt;网关整合Redis整合Lua实现限流</li>
<li>5.GatewayDiscoveryClientAutoConfiguration—–&gt;服务注册与发现功能</li>
</ul>
<p><strong>注意：</strong>gateway启动时，对于一个请求默认会有8个过滤器进行装配。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS原理</title>
    <url>/2021/07/20/HTTPS%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
HTTP请求都是明文传输的，所谓的明文指的是没有经过加密的信息，如果HTTP请求被黑客拦截，并且里面含有银行卡密码等敏感数据的话，会非常危险。为了解决这个问题，Netscape 公司制定了HTTPS协议，HTTPS可以将数据加密传输，也就是传输的是密文，即便黑客在传输过程中拦截到数据也无法破译，这就保证了网络通信的安全。

<h1 id="一-密码学基础"><a href="#一-密码学基础" class="headerlink" title="一.密码学基础"></a>一.密码学基础</h1><h2 id="明文"><a href="#明文" class="headerlink" title="明文"></a>明文</h2><p>明文指的是未被加密过的原始数据</p>
<h2 id="密文"><a href="#密文" class="headerlink" title="密文"></a>密文</h2><p>明文被某种加密算法加密之后，会变成密文，从而确保原始数据的安全。密文也可以被解密，得到原始的明文。</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数。密钥分为<code>对称密钥</code>与<code>非对称密钥</code>，分别应用在对称加密和非对称加密上。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。</p>
<ul>
<li>加密：明文+加密算法+私钥—&gt;密文</li>
<li>解密：密文+解密算法+私钥—&gt;明文</li>
</ul>
<p>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即<code>公钥</code>和<code>私钥</code>，且二者成对出现。</p>
<p>私钥被自己保存，不能对外泄露。<br>公钥指的是公共的密钥，任何人都可以获得该密钥。<br>用公钥或私钥中的任何一个进行加密，用另一个进行解密。<br><strong>公钥和私钥是一一对应的</strong><br>被公钥加密过的密文只能被私钥解密，过程如下：</p>
<ul>
<li>明文 + 加密算法 + 公钥 —&gt; 密文， 密文 + 解密算法 + 私钥 —&gt; 明文</li>
</ul>
<p>被私钥加密过的密文只能被公钥解密，过程如下：</p>
<ul>
<li>明文 + 加密算法 + 私钥 —&gt; 密文， 密文 + 解密算法 + 公钥 —&gt; 明文</li>
</ul>
<p>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>
<h1 id="二-HTTPS通信过程"><a href="#二-HTTPS通信过程" class="headerlink" title="二.HTTPS通信过程"></a>二.HTTPS通信过程</h1><p><strong>HTTPS协议 = HTTP协议 + SSL/TLS协议</strong>，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输，由此可以看出HTTPS是由HTTP和SSL/TLS一起合作完成的。</p>
<p>SSL的全称是Secure Sockets Layer，即安全套接层协议，是为网络通信提供安全及数据完整性的一种安全协议。SSL协议在1994年被Netscape发明，后来各个浏览器均支持SSL，其最新的版本是3.0</p>
<p>TLS的全称是Transport Layer Security，即安全传输层协议，最新版本的TLS（Transport Layer Security，传输层安全协议）是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是它们所支持的加密算法不同，所以TLS与SSL3.0不能互操作。虽然TLS与SSL3.0在加密算法上不同，但是在我们理解HTTPS的过程中，我们可以把SSL和TLS看做是同一个协议。</p>
<p>HTTPS为了兼顾安全与效率，<strong>同时使用了对称加密和非对称加密</strong>。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，<strong>对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</strong></p>
<p><img src="/2021/07/20/HTTPS%E5%8E%9F%E7%90%86/1.png" alt="8个步骤"><br>HTTPS在传输的过程中会涉及到三个密钥：</p>
<ul>
<li>服务器端的公钥和私钥，用来进行非对称加密</li>
<li>客户端生成的随机密钥，用来进行对称加密</li>
</ul>
<p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步：</p>
<ol>
<li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li>
<li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。</li>
<li>服务器将自己的公钥发送给客户端。</li>
<li>客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为<code>client key</code>，即客户端密钥。然后<strong>用服务器的公钥对客户端密钥进行非对称加密</strong>，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。</li>
<li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li>
<li>然后服务器将加密后的密文发送给客户端。</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。</li>
</ol>
<h1 id="三-CA"><a href="#三-CA" class="headerlink" title="三.CA"></a>三.CA</h1><p>CA是Certification Authority的缩写，它代表世界上那些权威的证书颁发机构。</p>
<h2 id="1-CA需要做什么"><a href="#1-CA需要做什么" class="headerlink" title="1.CA需要做什么"></a>1.CA需要做什么</h2><p>CA 要验证这个域名真的是你的：通常就是通过 DNS 记录或者就是你在指定 URI 下放置一个特殊文件，让 CA 可以在外网环境下访问到它。<br>CA 是一个非常关键的角色，因为它签出来的任何证书都是被信任的，所以这要求每个 CA 都不能乱来。</p>
<p>Let’s Encrypt 机构提供了免费的证书，那有什么区别呢？<br>Let’s Encrypt 它只验证了这个域名是你的，然后就可以给你免费签发证书，这个证书的有效期是 3 个月，到期要自己去更新。因为它只验证了你的域名，所以这类证书又称为 DV 证书（Domain Validation）。</p>
<p>而一些收费的 CA 可以签发 OV 证书（Organization Validation）或 EV 证书（Extended Validation），他们不仅会验证这个域名真的是你的，还会人工验证你的公司是否符合他们的各项签发标准，所以收费也比较贵。通常这些证书的有效期是 1 年。</p>
<p>对于浏览器来说，通常会根据你的证书是 DV 还是 OV，来呈现不同的样式，所以有一种花钱的证书更香的感觉。</p>
<p>但是从技术上来说，它们都是提供一样的保护级别的，在最新的 Chrome 上，它没有区别对待，一律显示一个锁。</p>
<h2 id="2-证书申请"><a href="#2-证书申请" class="headerlink" title="2.证书申请"></a>2.证书申请</h2><p>首先我们要生成一个 CSR，它的全称是 Certificate Signing Request，这个文件包含了你要申请的证书的各种信息，这和在某个 CA 的后台填写一个申请表单是一个意思，只是这样可以规范所有 CA 遵守一致的规则。<br>这里我们需要使用一个叫 openssl 的软件，执行下面的命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">openssl</span> <span class="selector-tag">req</span> <span class="selector-tag">-new</span> <span class="selector-tag">-newkey</span> <span class="selector-tag">rsa</span><span class="selector-pseudo">:2048</span> <span class="selector-tag">-nodes</span> <span class="selector-tag">-keyout</span> <span class="selector-tag">jinping</span><span class="selector-class">.xyz</span><span class="selector-class">.key</span> <span class="selector-tag">-out</span> <span class="selector-tag">jinping</span><span class="selector-class">.xyz</span><span class="selector-class">.csr</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/20/HTTPS%E5%8E%9F%E7%90%86/2.png" alt="openssl"><br>进入交互界面后，需要你填写国家、城市、公司名字、部门名字、申请的域名、邮箱地址。有些 CA 支持中文，大部分不支持，这里建议都是用英文字符。</p>
<p>然后我们就会得到两个文本文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">jinping</span><span class="selector-class">.xyz</span><span class="selector-class">.csr</span>  </span><br><span class="line"><span class="selector-tag">jinping</span><span class="selector-class">.xyz</span><span class="selector-class">.key</span></span><br></pre></td></tr></table></figure>
<p>其中一个是 CSR 文件，用来发给 CA 申请证书的，另一个是私钥。私钥需要好好保存，等证书申请完成以后要用。<br>从域名的角度，证书分为单域名、通配符域名、多域名证书。以单域名 jinping.xyz 为例子，通配符和多域名也很好理解，在填写域名的时候按照格式填就可以了。<br>生成出来的 jinping.xyz.csr 文件，它的内容是这样的</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-----<span class="keyword">BEGIN</span> CERTIFICATE REQUEST-----</span><br><span class="line">MIIC+TCCAeECAQAwgYkxCzAJBgNVBAYTAmNuMRAwDgYDVQQIDAdiZWlqaW5nMQ4w</span><br><span class="line">DAYDVQQHDAVjaGluYTEQMA4GA1UECgwHeW9uZ2h1aTEQMA4GA1UECwwHc2VjdGlv</span><br><span class="line">bjEQMA4GA1UEAwwHamlucGluZzEiMCAGCSqGSIb3DQEJARYTamlucGluZzA5ODJA</span><br><span class="line">MTYzLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBANC5kvprdmFm</span><br><span class="line">gk+W0Fw1Co+kj2h97jj5ibZtoytUyq3nlHEXdrXMqnsz1sR4mBa3J8qbQZ2FkEB4</span><br><span class="line">ShU7gynTS+zlI7Vq7tU29TC1vZGhNUo3TlhSj412VXxjImlCvh+gAhQbHkkFsMlv</span><br><span class="line">n3YNphdlI/Du36jYcecJ1J4CznY6RYdPstbqBeltVuREFZL6gr34n8WDRlU333pI</span><br><span class="line">jONMnwFa8JVmQO<span class="regexp">/6TOvJn7xfc9HMdq7Uvz7RLk0mOdCY8NfW5603/</span>IoFxQ5YaLGh</span><br><span class="line">ULb9v0omprxGiTm+keC0m6LB3Y0JFZdkOwyGkznEsLJ+vZ7NA11YGKKb4zmLjNg1</span><br><span class="line">pQp1aavWxBECAwEAAaAqMBEGCSqGSIb3DQEJAjEEDAJ5aDAVBgkqhkiG9w0BCQcx</span><br><span class="line">CAwGMDUwNDAxMA0GCSqGSIb3DQEBCwUAA4IBAQBvL6QvPB+weRBudlPTEYv4GEY3</span><br><span class="line">I5JxhdxAB57wWzDmn96xRuChlPMyRHd6XiMXM2nnv02GCNDyPP6Zx6C80rQFbNvz</span><br><span class="line">qa9298wGhFX2jRFXVW/Z1zsdn1sXk2B3Pa7dW0FEgAN+uc+CbV2HALdtRvAiFxvc</span><br><span class="line">enWm9aMShhk2rpl0NPZ1Xa5bY0zM+Ew3Qq/W0zCuJVLuV+<span class="number">7</span>Rf8CRP1RNZD7FoEST</span><br><span class="line">miKvBTE0fG0WAjdPmXznAfbraP/cljdMk+Ccn9tQ+SgCfa5aedXPAFxgs1KW1LJ3</span><br><span class="line">vi6X5Jvoz0BhABNPz3xVYGqOV82/UR+MP5PVZvbXO6lWLghmXj2twSwH4pXy</span><br><span class="line">-----<span class="keyword">END</span> CERTIFICATE REQUEST-----</span><br></pre></td></tr></table></figure>
<p>进入 <a href="https://decoder.link/result">https://decoder.link/result</a> 进行 decode，可以得到：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Certificate</span> Request:</span><br><span class="line">    <span class="attribute">Data</span>:</span><br><span class="line">        <span class="attribute">Version</span>: <span class="number">1</span> (<span class="number">0</span>x<span class="number">0</span>)</span><br><span class="line">        <span class="attribute">Subject</span>: C = cn, ST = beijing, L = china, O = yonghui, OU = section, CN = jinping, emailAddress = jinping<span class="number">0982</span>@<span class="number">163</span>.com</span><br><span class="line">        <span class="attribute">Subject</span> Public Key Info:</span><br><span class="line">            <span class="attribute">Public</span> Key Algorithm: rsaEncryption</span><br><span class="line">                <span class="attribute">Public</span>-Key: (<span class="number">2048</span> bit)</span><br><span class="line">                <span class="attribute">Modulus</span>:</span><br><span class="line">                    <span class="attribute">00</span>:d<span class="number">0</span>:b<span class="number">9</span>:<span class="number">92</span>:fa:<span class="number">6</span>b:<span class="number">76</span>:<span class="number">61</span>:<span class="number">66</span>:<span class="number">82</span>:<span class="number">4</span>f:<span class="number">96</span>:d<span class="number">0</span>:<span class="number">5</span>c:<span class="number">35</span>:</span><br><span class="line">                    <span class="attribute">0a</span>:<span class="number">8</span>f:a<span class="number">4</span>:<span class="number">8</span>f:<span class="number">68</span>:<span class="number">7</span>d:ee:<span class="number">38</span>:f<span class="number">9</span>:<span class="number">89</span>:b<span class="number">6</span>:<span class="number">6</span>d:a<span class="number">3</span>:<span class="number">2</span>b:<span class="number">54</span>:</span><br><span class="line">                    <span class="attribute">ca</span>:ad:e<span class="number">7</span>:<span class="number">94</span>:<span class="number">71</span>:<span class="number">17</span>:<span class="number">76</span>:b<span class="number">5</span>:cc:aa:<span class="number">7</span>b:<span class="number">33</span>:d<span class="number">6</span>:c<span class="number">4</span>:<span class="number">78</span>:</span><br><span class="line">                    <span class="attribute">98</span>:<span class="number">16</span>:b<span class="number">7</span>:<span class="number">27</span>:ca:<span class="number">9</span>b:<span class="number">41</span>:<span class="number">9</span>d:<span class="number">85</span>:<span class="number">90</span>:<span class="number">40</span>:<span class="number">78</span>:<span class="number">4</span>a:<span class="number">15</span>:<span class="number">3</span>b:</span><br><span class="line">                    <span class="attribute">83</span>:<span class="number">29</span>:d<span class="number">3</span>:<span class="number">4</span>b:ec:e<span class="number">5</span>:<span class="number">23</span>:b<span class="number">5</span>:<span class="number">6</span>a:ee:d<span class="number">5</span>:<span class="number">36</span>:f<span class="number">5</span>:<span class="number">30</span>:b<span class="number">5</span>:</span><br><span class="line">                    <span class="attribute">bd</span>:<span class="number">91</span>:a<span class="number">1</span>:<span class="number">35</span>:<span class="number">4</span>a:<span class="number">37</span>:<span class="number">4</span>e:<span class="number">58</span>:<span class="number">52</span>:<span class="number">8</span>f:<span class="number">8</span>d:<span class="number">76</span>:<span class="number">55</span>:<span class="number">7</span>c:<span class="number">63</span>:</span><br><span class="line">                    <span class="attribute">22</span>:<span class="number">69</span>:<span class="number">42</span>:be:<span class="number">1</span>f:a<span class="number">0</span>:<span class="number">02</span>:<span class="number">14</span>:<span class="number">1</span>b:<span class="number">1</span>e:<span class="number">49</span>:<span class="number">05</span>:b<span class="number">0</span>:c<span class="number">9</span>:<span class="number">6</span>f:</span><br><span class="line">                    <span class="attribute">9f</span>:<span class="number">76</span>:<span class="number">0</span>d:a<span class="number">6</span>:<span class="number">17</span>:<span class="number">65</span>:<span class="number">23</span>:f<span class="number">0</span>:ee:df:a<span class="number">8</span>:d<span class="number">8</span>:<span class="number">71</span>:e<span class="number">7</span>:<span class="number">09</span>:</span><br><span class="line">                    <span class="attribute">d4</span>:<span class="number">9</span>e:<span class="number">02</span>:ce:<span class="number">76</span>:<span class="number">3</span>a:<span class="number">45</span>:<span class="number">87</span>:<span class="number">4</span>f:b<span class="number">2</span>:d<span class="number">6</span>:ea:<span class="number">05</span>:e<span class="number">9</span>:<span class="number">6</span>d:</span><br><span class="line">                    <span class="attribute">56</span>:e<span class="number">4</span>:<span class="number">44</span>:<span class="number">15</span>:<span class="number">92</span>:fa:<span class="number">82</span>:bd:f<span class="number">8</span>:<span class="number">9</span>f:c<span class="number">5</span>:<span class="number">83</span>:<span class="number">46</span>:<span class="number">55</span>:<span class="number">37</span>:</span><br><span class="line">                    <span class="attribute">df</span>:<span class="number">7</span>a:<span class="number">48</span>:<span class="number">8</span>c:e<span class="number">3</span>:<span class="number">4</span>c:<span class="number">9</span>f:<span class="number">01</span>:<span class="number">5</span>a:f<span class="number">0</span>:<span class="number">95</span>:<span class="number">66</span>:<span class="number">40</span>:ef:fa:</span><br><span class="line">                    <span class="attribute">4c</span>:eb:c<span class="number">9</span>:<span class="number">9</span>f:bc:<span class="number">5</span>f:<span class="number">73</span>:d<span class="number">1</span>:cc:<span class="number">76</span>:ae:d<span class="number">4</span>:bf:<span class="number">3</span>e:d<span class="number">1</span>:</span><br><span class="line">                    <span class="attribute">2e</span>:<span class="number">4</span>d:<span class="number">26</span>:<span class="number">39</span>:d<span class="number">0</span>:<span class="number">98</span>:f<span class="number">0</span>:d<span class="number">7</span>:d<span class="number">6</span>:e<span class="number">7</span>:ad:<span class="number">37</span>:fc:<span class="number">8</span>a:<span class="number">05</span>:</span><br><span class="line">                    <span class="attribute">c5</span>:<span class="number">0</span>e:<span class="number">58</span>:<span class="number">68</span>:b<span class="number">1</span>:a<span class="number">1</span>:<span class="number">50</span>:b<span class="number">6</span>:fd:bf:<span class="number">4</span>a:<span class="number">26</span>:a<span class="number">6</span>:bc:<span class="number">46</span>:</span><br><span class="line">                    <span class="attribute">89</span>:<span class="number">39</span>:be:<span class="number">91</span>:e<span class="number">0</span>:b<span class="number">4</span>:<span class="number">9</span>b:a<span class="number">2</span>:c<span class="number">1</span>:dd:<span class="number">8</span>d:<span class="number">09</span>:<span class="number">15</span>:<span class="number">97</span>:<span class="number">64</span>:</span><br><span class="line">                    <span class="attribute">3b</span>:<span class="number">0</span>c:<span class="number">86</span>:<span class="number">93</span>:<span class="number">39</span>:c<span class="number">4</span>:b<span class="number">0</span>:b<span class="number">2</span>:<span class="number">7</span>e:bd:<span class="number">9</span>e:cd:<span class="number">03</span>:<span class="number">5</span>d:<span class="number">58</span>:</span><br><span class="line">                    <span class="attribute">18</span>:a<span class="number">2</span>:<span class="number">9</span>b:e<span class="number">3</span>:<span class="number">39</span>:<span class="number">8</span>b:<span class="number">8</span>c:d<span class="number">8</span>:<span class="number">35</span>:a<span class="number">5</span>:<span class="number">0</span>a:<span class="number">75</span>:<span class="number">69</span>:ab:d<span class="number">6</span>:</span><br><span class="line">                    <span class="attribute">c4</span>:<span class="number">11</span></span><br><span class="line">                <span class="attribute">Exponent</span>: <span class="number">65537</span> (<span class="number">0</span>x<span class="number">10001</span>)</span><br><span class="line">        <span class="attribute">Attributes</span>:</span><br><span class="line">            <span class="attribute">unstructuredName</span>         :yh</span><br><span class="line">            <span class="attribute">challengePassword</span>        :<span class="number">050401</span></span><br><span class="line">    <span class="attribute">Signature</span> Algorithm: sha<span class="number">256</span>WithRSAEncryption</span><br><span class="line">         <span class="attribute">6f</span>:<span class="number">2</span>f:a<span class="number">4</span>:<span class="number">2</span>f:<span class="number">3</span>c:<span class="number">1</span>f:b<span class="number">0</span>:<span class="number">79</span>:<span class="number">10</span>:<span class="number">6</span>e:<span class="number">76</span>:<span class="number">53</span>:d<span class="number">3</span>:<span class="number">11</span>:<span class="number">8</span>b:f<span class="number">8</span>:<span class="number">18</span>:<span class="number">46</span>:</span><br><span class="line">         <span class="attribute">37</span>:<span class="number">23</span>:<span class="number">92</span>:<span class="number">71</span>:<span class="number">85</span>:dc:<span class="number">40</span>:<span class="number">07</span>:<span class="number">9</span>e:f<span class="number">0</span>:<span class="number">5</span>b:<span class="number">30</span>:e<span class="number">6</span>:<span class="number">9</span>f:de:b<span class="number">1</span>:<span class="number">46</span>:e<span class="number">0</span>:</span><br><span class="line">         <span class="attribute">a1</span>:<span class="number">94</span>:f<span class="number">3</span>:<span class="number">32</span>:<span class="number">44</span>:<span class="number">77</span>:<span class="number">7</span>a:<span class="number">5</span>e:<span class="number">23</span>:<span class="number">17</span>:<span class="number">33</span>:<span class="number">69</span>:e<span class="number">7</span>:bf:<span class="number">4</span>d:<span class="number">86</span>:<span class="number">08</span>:d<span class="number">0</span>:</span><br><span class="line">         <span class="attribute">f2</span>:<span class="number">3</span>c:fe:<span class="number">99</span>:c<span class="number">7</span>:a<span class="number">0</span>:bc:d<span class="number">2</span>:b<span class="number">4</span>:<span class="number">05</span>:<span class="number">6</span>c:db:f<span class="number">3</span>:a<span class="number">9</span>:af:<span class="number">76</span>:f<span class="number">7</span>:cc:</span><br><span class="line">         <span class="attribute">06</span>:<span class="number">84</span>:<span class="number">55</span>:f<span class="number">6</span>:<span class="number">8</span>d:<span class="number">11</span>:<span class="number">57</span>:<span class="number">55</span>:<span class="number">6</span>f:d<span class="number">9</span>:d<span class="number">7</span>:<span class="number">3</span>b:<span class="number">1</span>d:<span class="number">9</span>f:<span class="number">5</span>b:<span class="number">17</span>:<span class="number">93</span>:<span class="number">60</span>:</span><br><span class="line">         <span class="attribute">77</span>:<span class="number">3</span>d:ae:dd:<span class="number">5</span>b:<span class="number">41</span>:<span class="number">44</span>:<span class="number">80</span>:<span class="number">03</span>:<span class="number">7</span>e:b<span class="number">9</span>:cf:<span class="number">82</span>:<span class="number">6</span>d:<span class="number">5</span>d:<span class="number">87</span>:<span class="number">00</span>:b<span class="number">7</span>:</span><br><span class="line">         <span class="attribute">6d</span>:<span class="number">46</span>:f<span class="number">0</span>:<span class="number">22</span>:<span class="number">17</span>:<span class="number">1</span>b:dc:<span class="number">7</span>a:<span class="number">75</span>:a<span class="number">6</span>:f<span class="number">5</span>:a<span class="number">3</span>:<span class="number">12</span>:<span class="number">86</span>:<span class="number">19</span>:<span class="number">36</span>:ae:<span class="number">99</span>:</span><br><span class="line">         <span class="attribute">74</span>:<span class="number">34</span>:f<span class="number">6</span>:<span class="number">75</span>:<span class="number">5</span>d:ae:<span class="number">5</span>b:<span class="number">63</span>:<span class="number">4</span>c:cc:f<span class="number">8</span>:<span class="number">4</span>c:<span class="number">37</span>:<span class="number">42</span>:af:d<span class="number">6</span>:d<span class="number">3</span>:<span class="number">30</span>:</span><br><span class="line">         <span class="attribute">ae</span>:<span class="number">25</span>:<span class="number">52</span>:ee:<span class="number">57</span>:ee:d<span class="number">1</span>:<span class="number">7</span>f:c<span class="number">0</span>:<span class="number">91</span>:<span class="number">3</span>f:<span class="number">54</span>:<span class="number">4</span>d:<span class="number">64</span>:<span class="number">3</span>e:c<span class="number">5</span>:a<span class="number">0</span>:<span class="number">44</span>:</span><br><span class="line">         <span class="attribute">93</span>:<span class="number">9</span>a:<span class="number">22</span>:af:<span class="number">05</span>:<span class="number">31</span>:<span class="number">34</span>:<span class="number">7</span>c:<span class="number">6</span>d:<span class="number">16</span>:<span class="number">02</span>:<span class="number">37</span>:<span class="number">4</span>f:<span class="number">99</span>:<span class="number">7</span>c:e<span class="number">7</span>:<span class="number">01</span>:f<span class="number">6</span>:</span><br><span class="line">         <span class="attribute">eb</span>:<span class="number">68</span>:ff:dc:<span class="number">96</span>:<span class="number">37</span>:<span class="number">4</span>c:<span class="number">93</span>:e<span class="number">0</span>:<span class="number">9</span>c:<span class="number">9</span>f:db:<span class="number">50</span>:f<span class="number">9</span>:<span class="number">28</span>:<span class="number">02</span>:<span class="number">7</span>d:ae:</span><br><span class="line">         <span class="attribute">5a</span>:<span class="number">79</span>:d<span class="number">5</span>:cf:<span class="number">00</span>:<span class="number">5</span>c:<span class="number">60</span>:b<span class="number">3</span>:<span class="number">52</span>:<span class="number">96</span>:d<span class="number">4</span>:b<span class="number">2</span>:<span class="number">77</span>:be:<span class="number">2</span>e:<span class="number">97</span>:e<span class="number">4</span>:<span class="number">9</span>b:</span><br><span class="line">         <span class="attribute">e8</span>:cf:<span class="number">40</span>:<span class="number">61</span>:<span class="number">00</span>:<span class="number">13</span>:<span class="number">4</span>f:cf:<span class="number">7</span>c:<span class="number">55</span>:<span class="number">60</span>:<span class="number">6</span>a:<span class="number">8</span>e:<span class="number">57</span>:cd:bf:<span class="number">51</span>:<span class="number">1</span>f:</span><br><span class="line">         <span class="attribute">8c</span>:<span class="number">3</span>f:<span class="number">93</span>:d<span class="number">5</span>:<span class="number">66</span>:f<span class="number">6</span>:d<span class="number">7</span>:<span class="number">3</span>b:a<span class="number">9</span>:<span class="number">56</span>:<span class="number">2</span>e:<span class="number">08</span>:<span class="number">66</span>:<span class="number">5</span>e:<span class="number">3</span>d:ad:c<span class="number">1</span>:<span class="number">2</span>c:</span><br><span class="line">         <span class="attribute">07</span>:e<span class="number">2</span>:<span class="number">95</span>:f<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>主要包含三部分：</p>
<ul>
<li>第一部分：Subject 中是我填写的域名的基本信息，这里面，我们只需要关注 CN 字段就行：jinping。CN 是 Common Name 的缩写。</li>
<li>第二部分：Subject Public Key Info 是公钥部分，这里指定了服务器使用的加密算法是 RSA，公钥长度是 2048 位。</li>
<li>第三部分：签名，使用了 <code>sha256WithRSAEncryption</code> 算法。也就是说首先将上面的所有信息进行 sha256 散列得到 hash 值，然后使用 RSA 算法对 hash 值进行加密，而加密的秘钥就是之前生成的私钥。</li>
</ul>
<blockquote>
<p>为什么这里要加第三部分的签名？其实就是为了防止你的 CSR 文件在发给 CA 的过程中被中间人拦截，然后修改了里面的信息再发给 CA。<br>CA 的校验过程是：利用里面的公钥将签名进行解密得到里面的散列值，然后 CA 也会利用 CSR 里面的信息计算一遍散列值，如果两者相等，那么说明证书没有被中间人修改过，反之就是被修改过</p>
</blockquote>
<h2 id="3-证书组成"><a href="#3-证书组成" class="headerlink" title="3.证书组成"></a>3.证书组成</h2><p>CA 收到我们的 CSR 文件以后，CA 会进行审核，前面说过了，审核这个域名是不是你的，如果需要，还有人工审核公司信息。审核通过后，它就会发给我们证书文件了，每家 CA 出来的文件名可能略有不同，但是表达的信息是一样的。</p>
<p>主要有以下几个文件：</p>
<p>域名证书：jinping.xyz.pem 或叫 cert.pem<br>证书链：fullchain.pem<br>这些文件可能是 .pem 也可能是 .crt 后缀，但都是文本文件，可以直接打开查看它们的信息：</p>
<p>域名证书的文件内容通常是这样的：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="params">-----BEGIN</span> CERTIFICATE<span class="params">-----</span></span><br><span class="line">MIIFTzCCBDegAwIBAgISAy4b8ie6L/ACCJt/V7x/OR0iMA0GCSqGSIb3DQEBCwUA</span><br><span class="line">MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD</span><br><span class="line"><span class="string">......</span></span><br><span class="line">Ecbqh4AoB33mZhp9ptJb1N1RSlZREI0FlbX0kUd6VowKUPhH8Iex6jxQpJHwRkpq</span><br><span class="line">YJaWKrUxGWuJurOcN7b3HXn6yw==</span><br><span class="line"><span class="params">-----END</span> CERTIFICATE<span class="params">-----</span></span><br></pre></td></tr></table></figure>
<p>证书链文件通常是这样的：(证书链文件的第一部分，和证书文件的内容是一模一样的。)</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIFTzCCBDegAwIBAgISAy4b8ie6L/ACCJt/V7x/OR0iMA0GCSqGSIb3DQEBCwUA</span><br><span class="line">MEoxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1MZXQncyBFbmNyeXB0MSMwIQYDVQQD</span><br><span class="line">.......</span><br><span class="line">Ecbqh4AoB33mZhp9ptJb1N1RSlZREI0FlbX0kUd6VowKUPhH8Iex6jxQpJHwRkpq</span><br><span class="line">YJaWKrUxGWuJurOcN7b3HXn6yw==</span><br><span class="line">-----END CERTIFICATE-----</span><br><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIEkjCCA3qgAwIBAgIQCgFBQgAAAVOFc2oLheynCDANBgkqhkiG9w0BAQsFADA/</span><br><span class="line">MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT</span><br><span class="line">.......</span><br><span class="line">PfZ<span class="code">+G6Z6h7mjem0Y+</span>iWlkYcV4PIWL1iwBi8saCbGS5jN2p8M<span class="code">+X+</span>Q7UNKEkROb3N6</span><br><span class="line">KOqkqm57TH2H3eDJAkSnh6/DNFu0Qg==</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果 CA 还给你发了 chain.pem 文件，其实它的内容肯定就是证书链文件内容裁减掉第一部分的证书内容而已。</p>
</blockquote>
<p>我们需要的其实就是一个证书链。CA 给我们颁发的证书，其实就是一个证书链文件</p>
<h2 id="4-文件内容"><a href="#4-文件内容" class="headerlink" title="4.文件内容"></a>4.文件内容</h2><p>decode后的结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: <span class="number">3</span> (<span class="number">0x2</span>)</span><br><span class="line">        Serial Number:</span><br><span class="line">            <span class="number">02</span>:ac:<span class="number">5</span>c:<span class="number">26</span>:<span class="number">6</span>a:<span class="number">0</span>b:<span class="number">40</span>:<span class="number">9</span>b:<span class="number">8f</span>:<span class="number">0</span>b:<span class="number">79</span>:f2:ae:<span class="number">46</span>:<span class="number">25</span>:<span class="number">77</span></span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">        <span class="comment">//证书颁发机构</span></span><br><span class="line">        Issuer: C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA</span><br><span class="line">        <span class="comment">//证书有效期</span></span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov <span class="number">10</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2006</span> GMT</span><br><span class="line">            Not After : Nov <span class="number">10</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="number">2031</span> GMT</span><br><span class="line">        <span class="comment">// 证书申请信息</span></span><br><span class="line">        Subject: C = US, O = DigiCert Inc, OU = www.digicert.com, CN = DigiCert High Assurance EV Root CA</span><br><span class="line">        <span class="comment">// 公钥</span></span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (<span class="number">2048</span> bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    <span class="number">00</span>:c6:cc:e5:<span class="number">73</span>:e6:fb:d4:bb:e5:<span class="number">2</span>d:<span class="number">2</span>d:<span class="number">32</span>:a6:df:</span><br><span class="line">                    e5:<span class="number">81</span>:<span class="number">3f</span>:c9:cd:<span class="number">25</span>:<span class="number">49</span>:b6:<span class="number">71</span>:<span class="number">2</span>a:c3:d5:<span class="number">94</span>:<span class="number">34</span>:<span class="number">67</span>:</span><br><span class="line">                    a2:<span class="number">0</span>a:<span class="number">1</span>c:b0:<span class="number">5f</span>:<span class="number">69</span>:a6:<span class="number">40</span>:b1:c4:b7:b2:<span class="number">8f</span>:d0:<span class="number">98</span>:</span><br><span class="line">                    a4:a9:<span class="number">41</span>:<span class="number">59</span>:<span class="number">3</span>a:d3:dc:<span class="number">94</span>:d6:<span class="number">3</span>c:db:<span class="number">74</span>:<span class="number">38</span>:a4:<span class="number">4</span>a:</span><br><span class="line">                    cc:<span class="number">4</span>d:<span class="number">25</span>:<span class="number">82</span>:f7:<span class="number">4</span>a:a5:<span class="number">53</span>:<span class="number">12</span>:<span class="number">38</span>:ee:f3:<span class="number">49</span>:<span class="number">6</span>d:<span class="number">71</span>:</span><br><span class="line">                    <span class="number">91</span>:<span class="number">7</span>e:<span class="number">63</span>:b6:ab:a6:<span class="number">5f</span>:c3:a4:<span class="number">84</span>:f8:<span class="number">4f</span>:<span class="number">62</span>:<span class="number">51</span>:be:</span><br><span class="line">                    f8:c5:ec:db:<span class="number">38</span>:<span class="number">92</span>:e3:<span class="number">06</span>:e5:<span class="number">08</span>:<span class="number">91</span>:<span class="number">0</span>c:c4:<span class="number">28</span>:<span class="number">41</span>:</span><br><span class="line">                    <span class="number">55</span>:fb:cb:<span class="number">5</span>a:<span class="number">89</span>:<span class="number">15</span>:<span class="number">7</span>e:<span class="number">71</span>:e8:<span class="number">35</span>:bf:<span class="number">4</span>d:<span class="number">72</span>:<span class="number">09</span>:<span class="number">3</span>d:</span><br><span class="line">                    be:<span class="number">3</span>a:<span class="number">38</span>:<span class="number">50</span>:<span class="number">5</span>b:<span class="number">77</span>:<span class="number">31</span>:<span class="number">1</span>b:<span class="number">8</span>d:b3:c7:<span class="number">24</span>:<span class="number">45</span>:<span class="number">9</span>a:a7:</span><br><span class="line">                    ac:<span class="number">6</span>d:<span class="number">00</span>:<span class="number">14</span>:<span class="number">5</span>a:<span class="number">04</span>:b7:ba:<span class="number">13</span>:eb:<span class="number">51</span>:<span class="number">0</span>a:<span class="number">98</span>:<span class="number">41</span>:<span class="number">41</span>:</span><br><span class="line">                    <span class="number">22</span>:<span class="number">4</span>e:<span class="number">65</span>:<span class="number">61</span>:<span class="number">87</span>:<span class="number">81</span>:<span class="number">41</span>:<span class="number">50</span>:a6:<span class="number">79</span>:<span class="number">5</span>c:<span class="number">89</span>:de:<span class="number">19</span>:<span class="number">4</span>a:</span><br><span class="line">                    <span class="number">57</span>:d5:<span class="number">2</span>e:e6:<span class="number">5</span>d:<span class="number">1</span>c:<span class="number">53</span>:<span class="number">2</span>c:<span class="number">7</span>e:<span class="number">98</span>:cd:<span class="number">1</span>a:<span class="number">06</span>:<span class="number">16</span>:a4:</span><br><span class="line">                    <span class="number">68</span>:<span class="number">73</span>:d0:<span class="number">34</span>:<span class="number">04</span>:<span class="number">13</span>:<span class="number">5</span>c:a1:<span class="number">71</span>:d3:<span class="number">5</span>a:<span class="number">7</span>c:<span class="number">55</span>:db:<span class="number">5</span>e:</span><br><span class="line">                    <span class="number">64</span>:e1:<span class="number">37</span>:<span class="number">87</span>:<span class="number">30</span>:<span class="number">56</span>:<span class="number">04</span>:e5:<span class="number">11</span>:b4:<span class="number">29</span>:<span class="number">80</span>:<span class="number">12</span>:f1:<span class="number">79</span>:</span><br><span class="line">                    <span class="number">39</span>:<span class="number">88</span>:a2:<span class="number">02</span>:<span class="number">11</span>:<span class="number">7</span>c:<span class="number">27</span>:<span class="number">66</span>:b7:<span class="number">88</span>:b7:<span class="number">78</span>:f2:ca:<span class="number">0</span>a:</span><br><span class="line">                    a8:<span class="number">38</span>:ab:<span class="number">0</span>a:<span class="number">64</span>:c2:bf:<span class="number">66</span>:<span class="number">5</span>d:<span class="number">95</span>:<span class="number">84</span>:c1:a1:<span class="number">25</span>:<span class="number">1</span>e:</span><br><span class="line">                    <span class="number">87</span>:<span class="number">5</span>d:<span class="number">1</span>a:<span class="number">50</span>:<span class="number">0</span>b:<span class="number">20</span>:<span class="number">12</span>:cc:<span class="number">41</span>:bb:<span class="number">6</span>e:<span class="number">0</span>b:<span class="number">51</span>:<span class="number">38</span>:b8:</span><br><span class="line">                    <span class="number">4</span>b:cb</span><br><span class="line">                Exponent: <span class="number">65537</span> (<span class="number">0x10001</span>)</span><br><span class="line">        <span class="comment">// 这部分内容我们忽略</span></span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature, Certificate Sign, CRL Sign</span><br><span class="line">            X509v3 Basic Constraints: critical</span><br><span class="line">                CA:TRUE</span><br><span class="line">            X509v3 Subject Key Identifier: </span><br><span class="line">                B1:<span class="number">3</span>E:C3:<span class="number">69</span>:<span class="number">03</span>:F8:BF:<span class="number">47</span>:<span class="number">01</span>:D4:<span class="number">98</span>:<span class="number">26</span>:<span class="number">1</span>A:<span class="number">08</span>:<span class="number">02</span>:EF:<span class="number">63</span>:<span class="number">64</span>:<span class="number">2</span>B:C3</span><br><span class="line">            X509v3 Authority Key Identifier: </span><br><span class="line">                keyid:B1:<span class="number">3</span>E:C3:<span class="number">69</span>:<span class="number">03</span>:F8:BF:<span class="number">47</span>:<span class="number">01</span>:D4:<span class="number">98</span>:<span class="number">26</span>:<span class="number">1</span>A:<span class="number">08</span>:<span class="number">02</span>:EF:<span class="number">63</span>:<span class="number">64</span>:<span class="number">2</span>B:C3</span><br><span class="line">    <span class="comment">// 签名</span></span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">         <span class="number">1</span>c:<span class="number">1</span>a:<span class="number">06</span>:<span class="number">97</span>:dc:d7:<span class="number">9</span>c:<span class="number">9f</span>:<span class="number">3</span>c:<span class="number">88</span>:<span class="number">66</span>:<span class="number">06</span>:<span class="number">08</span>:<span class="number">57</span>:<span class="number">21</span>:db:<span class="number">21</span>:<span class="number">47</span>:</span><br><span class="line">         f8:<span class="number">2</span>a:<span class="number">67</span>:aa:bf:<span class="number">18</span>:<span class="number">32</span>:<span class="number">76</span>:<span class="number">40</span>:<span class="number">10</span>:<span class="number">57</span>:c1:<span class="number">8</span>a:f3:<span class="number">7</span>a:d9:<span class="number">11</span>:<span class="number">65</span>:</span><br><span class="line">         <span class="number">8</span>e:<span class="number">35</span>:fa:<span class="number">9</span>e:fc:<span class="number">45</span>:b5:<span class="number">9</span>e:d9:<span class="number">4</span>c:<span class="number">31</span>:<span class="number">4</span>b:b8:<span class="number">91</span>:e8:<span class="number">43</span>:<span class="number">2</span>c:<span class="number">8</span>e:</span><br><span class="line">         b3:<span class="number">78</span>:ce:db:e3:<span class="number">53</span>:<span class="number">79</span>:<span class="number">71</span>:d6:e5:<span class="number">21</span>:<span class="number">94</span>:<span class="number">01</span>:da:<span class="number">55</span>:<span class="number">87</span>:<span class="number">9</span>a:<span class="number">24</span>:</span><br><span class="line">         <span class="number">64</span>:f6:<span class="number">8</span>a:<span class="number">66</span>:cc:de:<span class="number">9</span>c:<span class="number">37</span>:cd:a8:<span class="number">34</span>:b1:<span class="number">69</span>:<span class="number">9</span>b:<span class="number">23</span>:c8:<span class="number">9</span>e:<span class="number">78</span>:</span><br><span class="line">         <span class="number">22</span>:<span class="number">2</span>b:<span class="number">70</span>:<span class="number">43</span>:e3:<span class="number">55</span>:<span class="number">47</span>:<span class="number">31</span>:<span class="number">61</span>:<span class="number">19</span>:ef:<span class="number">58</span>:c5:<span class="number">85</span>:<span class="number">2f</span>:<span class="number">4</span>e:<span class="number">30</span>:f6:</span><br><span class="line">         a0:<span class="number">31</span>:<span class="number">16</span>:<span class="number">23</span>:c8:e7:e2:<span class="number">65</span>:<span class="number">16</span>:<span class="number">33</span>:cb:bf:<span class="number">1</span>a:<span class="number">1</span>b:a0:<span class="number">3</span>d:f8:ca:</span><br><span class="line">         <span class="number">5</span>e:<span class="number">8</span>b:<span class="number">31</span>:<span class="number">8</span>b:<span class="number">60</span>:<span class="number">08</span>:<span class="number">89</span>:<span class="number">2</span>d:<span class="number">0</span>c:<span class="number">06</span>:<span class="number">5</span>c:<span class="number">52</span>:b7:c4:f9:<span class="number">0</span>a:<span class="number">98</span>:d1:</span><br><span class="line">         <span class="number">15</span>:<span class="number">5f</span>:<span class="number">9f</span>:<span class="number">12</span>:be:<span class="number">7</span>c:<span class="number">36</span>:<span class="number">63</span>:<span class="number">38</span>:bd:<span class="number">44</span>:a4:<span class="number">7f</span>:e4:<span class="number">26</span>:<span class="number">2</span>b:<span class="number">0</span>a:c4:</span><br><span class="line">         <span class="number">97</span>:<span class="number">69</span>:<span class="number">0</span>d:e9:<span class="number">8</span>c:e2:c0:<span class="number">10</span>:<span class="number">57</span>:b8:c8:<span class="number">76</span>:<span class="number">12</span>:<span class="number">91</span>:<span class="number">55</span>:f2:<span class="number">48</span>:<span class="number">69</span>:</span><br><span class="line">         d8:bc:<span class="number">2</span>a:<span class="number">02</span>:<span class="number">5</span>b:<span class="number">0f</span>:<span class="number">44</span>:d4:<span class="number">20</span>:<span class="number">31</span>:db:f4:ba:<span class="number">70</span>:<span class="number">26</span>:<span class="number">5</span>d:<span class="number">90</span>:<span class="number">60</span>:</span><br><span class="line">         <span class="number">9</span>e:bc:<span class="number">4</span>b:<span class="number">17</span>:<span class="number">09</span>:<span class="number">2f</span>:b4:cb:<span class="number">1</span>e:<span class="number">43</span>:<span class="number">68</span>:c9:<span class="number">07</span>:<span class="number">27</span>:c1:d2:<span class="number">5</span>c:f7:</span><br><span class="line">         ea:<span class="number">21</span>:b9:<span class="number">68</span>:<span class="number">12</span>:<span class="number">9</span>c:<span class="number">3</span>c:<span class="number">9</span>c:bf:<span class="number">9</span>e:fc:<span class="number">80</span>:<span class="number">5</span>c:<span class="number">9</span>b:<span class="number">63</span>:cd:ec:<span class="number">47</span>:</span><br><span class="line">         aa:<span class="number">25</span>:<span class="number">27</span>:<span class="number">67</span>:a0:<span class="number">37</span>:f3:<span class="number">00</span>:<span class="number">82</span>:<span class="number">7</span>d:<span class="number">54</span>:d7:a9:f8:e9:<span class="number">2</span>e:<span class="number">13</span>:a3:</span><br><span class="line">         <span class="number">77</span>:e8:<span class="number">1f</span>:<span class="number">4</span>a</span><br></pre></td></tr></table></figure>
<p>证书中主要包含：</p>
<ul>
<li>证书颁发机构：用于寻找链中的下一个验证节点</li>
<li>证书的有效期：比如浏览器要根据这个值来判断证书是否已过期</li>
<li>证书申请信息：比如浏览器要判断改证书是否可用于当前访问的域名</li>
<li>公钥：用于后续和服务端通信的秘钥，这个公钥和当初生成 CSR 时的公钥是一个东西，因为只有它是和服务器的私钥是一对的</li>
<li>签名：用于验证证书内容没有被篡改</li>
</ul>
<p><strong>这里简单说一说这个证书里面的公钥和签名：</strong></p>
<p>前面在介绍生成 CSR 的时候，我们说过了，签名部分，是服务器使用私钥加密 hash 值得到的，同时在 CSR 中包含了公钥，这样 CA 在收到这个文件后，可以用 CSR 文件中的公钥来解密签名，进而做校验。<br>而这里不一样，这个证书是 CA 给我们的，自然这个签名也是 CA 使用它自己的私钥进行加密的，但是这里的公钥是我们服务器的公钥，显然不能用于解密签名。<br>那对于用户浏览器来说，在收到这个证书以后，怎么校验这个证书的签名呢？显然浏览器需要得到 CA 的公钥。下一节我们就将详细描述这个过程。</p>
<h1 id="四-HTTPS验证过程"><a href="#四-HTTPS验证过程" class="headerlink" title="四.HTTPS验证过程"></a>四.HTTPS验证过程</h1><p>下面将使用 jinping.xyz 这个域名的证书来分析。<br><img src="/2021/07/20/HTTPS%E5%8E%9F%E7%90%86/3.png" alt="CA"><br>首先，我们可以看到，这个证书链由 3 个证书组成。jinping.xyz 证书由中间证书 R3 签发，中间证书由 DST Root CA X3 签发，而 DST Root CA X3 是一个受信任的根证书。</p>
<p>流程如下：</p>
<ol>
<li>用户访问 <a href="https://jinping.xyz,服务器返回/">https://jinping.xyz，服务器返回</a> CA 给的证书链，其中包含了 jinping.xyz 证书以及中间证书；</li>
<li>浏览器首先需要判断 jinping.xyz 的证书是不是可信的，关键的一步就是要解密证书的签名部分。因为证书是由中间证书签发的，所以要用中间证书里面的公钥来进行解密；</li>
<li>第 2 步初步判断了 jinping.xyz 的证书是合法的，但是，这个是基于中间证书合法的基础上来的，所以接下来要判断中间证书是否是合法的；</li>
<li>根据中间证书里面的信息，可以知道它是由 DST Root CA X3 签发的，由于证书链只有两个节点，所以要到操作系统的根证书库中查找，由于这个证书是一个使用非常广泛的根证书，所以在系统中可以找到它。然后利用根证书的公钥来解密中间证书的签名部分，进而判断中间证书是否合法，如果合法，整个流程就通了</li>
</ol>
<p>我们思考一下：</p>
<ul>
<li>这个系统要工作好，关键就是最终一定要走到本地根证书库，一环验证一环，实现整个链路证书的可信任；</li>
<li>中间证书有多少层都可以，只要能一直传递到根证书就行；</li>
<li>本地的根证书是由操作系统内置的，如果你的使用场景中，根证书不在系统预装里面，需要手动导入根证书；</li>
<li>另外，我这里使用了操作系统内置这个说法，其实也不准确吧，各大浏览器厂商可以自己内置这个根证书库，这样我想信任谁就信任谁，而不是听 Microsoft、Apple… 这些操作系统厂商的。</li>
</ul>
<p>脑洞大开一下，如果你想开一家 CA 公司，技术上是没什么成本的，但是你要说服各大操作系统、浏览器厂商，把你家的根证书内置到里面，这就有点难了。当然，还有另一条路可以走，那就是不要搞根证书，基于某个 CA 搞个中间证书，然后用这个中间证书去签发证书就可以了。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>http，ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>HopSpot虚拟机对象</title>
    <url>/2021/07/20/HopSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<hr>
<h1 id="一-对象的创建"><a href="#一-对象的创建" class="headerlink" title="一.对象的创建"></a>一.对象的创建</h1><p>虚拟机遇到new指令，先检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的<a href="/2021/07/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" title="类加载">类加载</a>过程。</p>
<h2 id="1-分配内存"><a href="#1-分配内存" class="headerlink" title="1.分配内存"></a>1.分配内存</h2><p>类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定。</p>
<a id="more"></a>

<h2 id="2-内存分配方式"><a href="#2-内存分配方式" class="headerlink" title="2.内存分配方式"></a>2.内存分配方式</h2><ul>
<li>指针碰撞：如果Java堆中的内存规整，用过的内存放在一边，空闲的放在另外一边，中间放一个指针作为分界点的指示器。分配内存就是把指针向空闲空间挪动一段与对象大小相等的距离。</li>
<li>空闲列表：如果Java堆中的内存不规整，无法使用指针碰撞的方法，需要维护一个表，记录哪些内存块是可用的，在分配时从列表中找到一块足够大的内存块来划分给对象实例，然后更新列表记录。选择哪种分配方式由Java堆是否规整决定，而<strong>Java堆是否规整由所采用的垃圾收集器是否带有压缩整理功能决定。</strong></li>
</ul>
<h2 id="3-并发问题"><a href="#3-并发问题" class="headerlink" title="3.并发问题"></a>3.并发问题</h2><p>创建对象是很频繁的行为，虚拟机采用如下两种方式来保证线程安全：</p>
<ul>
<li>CAS配上失败重试：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>TLAB： 将内存分配安排在每个线程独有的空间进行，每个线程首先在堆内存中分配一小块内存，称为本地分配缓存(TLAB : Thread Local Allocation Buffer)。分配内存时，只需要在自己的分配缓存中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</li>
</ul>
<h2 id="4-初始化零值"><a href="#4-初始化零值" class="headerlink" title="4.初始化零值"></a>4.初始化零值</h2><p>内存分配完成后，虚拟机将分配到的内存空间初始化为零值（不包括对象头），这一步保证了对象的实例字段在Java代码中可以不赋初始值就使用。</p>
<h2 id="5-对象头设置"><a href="#5-对象头设置" class="headerlink" title="5.对象头设置"></a>5.对象头设置</h2><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。</p>
<p>另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h2 id="6-执行init方法"><a href="#6-执行init方法" class="headerlink" title="6.执行init方法"></a>6.执行init方法</h2><p>从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，init 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 init 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<hr>
<h1 id="二-对象的内存布局"><a href="#二-对象的内存布局" class="headerlink" title="二.对象的内存布局"></a>二.对象的内存布局</h1><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p>Hotspot虚拟机的对象头包括两部分信息</p>
<ul>
<li>第一部分用于存储对象自身的自身运行时数据（哈希码、GC分代年龄、锁状态标志等等）</li>
<li>另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</li>
</ul>
<p>实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。包括父类继承的内容和子类中定义的内容。</p>
<p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<hr>
<h1 id="三-对象的访问定位"><a href="#三-对象的访问定位" class="headerlink" title="三.对象的访问定位"></a>三.对象的访问定位</h1><p>Java程序通过栈上的reference数据操作堆上的具体对象。主流的访问方式由使用句柄和直接指针两种。</p>
<ul>
<li>句柄：如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</li>
<li>直接指针： 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li>
</ul>
<p>这两种对象访问方式各有优势：</p>
<ul>
<li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改</li>
<li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。（大部分是使用第二种方法来访问的）</li>
</ul>
<p><strong>HotSpot使用直接指针的方式进行对象访问。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的hashcode和equals</title>
    <url>/2020/12/24/Java%E4%B8%AD%E7%9A%84hashcode%E5%92%8Cequals/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="关于hashcode"><a href="#关于hashcode" class="headerlink" title="关于hashcode"></a>关于hashcode</h2><p>1、hashcode的存在主要是用于查找的快捷性，如Hashtable、HashMap等，hashcode是用来在散列存储结构中确定对象的存储地址的。</p>
<p>2、如果两个对象相同，就是适用于<code>equals(java.lang.Object)</code>方法，那么这两个对象的hashcode方法一定要相同。</p>
<p>3、如果对象的equals方法被重写，那么对象的hashcode方法也尽量重写，并且产生hashcode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点。</p>
<p>4、两个对象的hashcode相同，并不一定表示两个对象就相同，也就是不一定适用于<code>equals(java.lang.Object)</code>方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在一个篮子中”。</p>
<a id="more"></a>
<p><strong>再次归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象是否相等的</strong></p>
<h2 id="关于equals"><a href="#关于equals" class="headerlink" title="关于equals"></a>关于equals</h2><p>1、equals和==</p>
<ul>
<li>==用于比较引用和比较基本数据类型时具有不同的功能：<br>  比较基本数据类型，如果两个值相同，则结果为true；<br>  而在比较引用时，如果引用指向内存中的同一对象，结果为true。</li>
</ul>
<p>2、equals作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达，因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。</p>
<p>3、Object类的equals()方法的比较规则为：如果两个对象的类型一致，并且内容一致，则返回true。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域</title>
    <url>/2021/07/19/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域，如图所示：<br><img src="/2021/07/19/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/1.png" alt="Java内存区域"></p>
<a id="more"></a>

<h1 id="一-线程私有的"><a href="#一-线程私有的" class="headerlink" title="一.线程私有的"></a>一.线程私有的</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><p>占据一块较小的内存空间，可以看做当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于jvm的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此未来线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们成这类内存区域为“线程私有”的内存。</p>
<ul>
<li>如果线程正在执行的是一个Java方法，这个计数器记录的则是正在执行的虚拟机字节码指令的地址；</li>
<li>如果正在执行的是Native方法，这个计数器则为空（undefined）。</li>
</ul>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h2 id="2-Java虚拟机栈"><a href="#2-Java虚拟机栈" class="headerlink" title="2.Java虚拟机栈"></a>2.Java虚拟机栈</h2><p>线程私有，生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧  用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量表空间（slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。(大小指的是变量槽的数量)</p>
<p>在Java虚拟机规范中，对此区域规定了两种异常状况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出Stack OverflowError异常；</li>
<li>如果虚拟机栈可以动态扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li>
</ul>
<h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用非常相似，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机中使用到的native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接把本地方法栈和虚拟机栈合二为一，</p>
<p>与虚拟机栈一样也会抛出Stack OverflowError异常和OutOfMemoryError异常。</p>
<h1 id="二-线程共享的"><a href="#二-线程共享的" class="headerlink" title="二.线程共享的"></a>二.线程共享的</h1><h2 id="1-Java堆"><a href="#1-Java堆" class="headerlink" title="1.Java堆"></a>1.Java堆</h2><p>对于大多数应用来说，堆空间是jvm内存中最大的一块。Java堆是被所有线程共享，虚拟机启动时创建，此内存区域唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也就变得不那么绝对了。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。从内存回收角度看，由于现在收集器基本都采用分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间，From Survivor空间，To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存。（如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。）</p>
<h2 id="2-方法区（永久代）"><a href="#2-方法区（永久代）" class="headerlink" title="2.方法区（永久代）"></a>2.方法区（永久代）</h2><p>和堆一样所有线程共享，主要用于存储已被jvm加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。也叫“非堆”。</p>
<p>（在JDK1.7发布的HotSpot中，已经把字符串常量池移除方法区了。）</p>
<p>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3.常量池"></a>3.常量池</h2><p><strong>运行时常量池是方法区的一部分</strong>。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>Java虚拟机对class文件每一部分的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范才会被jvm认可。但对于运行时常量池，Java虚拟机规范没做任何细节要求。</p>
<p>运行时常量池有个重要特性是动态性，Java语言不要求常量一定只在编译期才能产生，也就是并非预置入class文件中常量池的内容才能进入方法区的运行时常量池，运行期间也有可能将新的常量放入池中，这种特性使用最多的是String类的intern()方法。</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制。当常量池无法再申请到内存时会抛出outOfMemeryError异常。</p>
<h2 id="4-直接内存"><a href="#4-直接内存" class="headerlink" title="4.直接内存"></a>4.直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分。但是这部分也被经常访问，而且也可能导致OOM异常。</p>
<p>在jdk1.4中新加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型与线程</title>
    <url>/2021/04/04/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、物理机中的效率与一致性"><a href="#一、物理机中的效率与一致性" class="headerlink" title="一、物理机中的效率与一致性"></a>一、物理机中的效率与一致性</h3><h4 id="1-高速缓存（Cache）的引入"><a href="#1-高速缓存（Cache）的引入" class="headerlink" title="1. 高速缓存（Cache）的引入"></a>1. 高速缓存（Cache）的引入</h4><p>“让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的性能”之间的因果关系，看起来利索当然，实际上他们之间的关系并没有想象中那么简单，其中一个重要的复杂性的来源是绝大多数的运算任务都不可能只靠处理器“计算”就能完成。</p>
<p>处理器只要要与内存交互，如读取运算数据、存储计算结果等，这个IO操作就是很难消除的（无法仅靠寄存器来完成所有运算任务）。</p>
<p>由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的<code>高速缓存（Cache）</code>来作为内存与处理器之间的缓冲：</p>
<blockquote>
<p>将运算需要使用的数据复制到内存中，让运算能快速进行，当运算结束后再从缓存同步到内存之中，这样就无需等待缓慢的内存读写了。</p>
</blockquote>
<a id="more"></a>

<h4 id="2-缓存一致性问题"><a href="#2-缓存一致性问题" class="headerlink" title="2. 缓存一致性问题"></a>2. 缓存一致性问题</h4><p>在多路处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主内存（Main Memory），这种系统称为<code>共享内存多核系统</code>。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。</p>
<p>为了解决缓存数据一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来操作。比如：MSI、MESI、MOSI等。</p>
<h4 id="3-乱序执行优化"><a href="#3-乱序执行优化" class="headerlink" title="3.乱序执行优化"></a>3.乱序执行优化</h4><p>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p>
<p>与处理器的乱序执行优化类似，Java虚拟机的即使编译器中也有指令重排序优化。</p>
<h3 id="二、Java内存模型"><a href="#二、Java内存模型" class="headerlink" title="二、Java内存模型"></a>二、Java内存模型</h3><h4 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1.主内存与工作内存"></a>1.主内存与工作内存</h4>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>多线程</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的四种引用</title>
    <url>/2020/10/27/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>Java里面有四种引用类型：强、软、弱、虚</p>
<p><img src="/2020/10/27/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/3.png" alt="四种引用"></p>
<h2 id="一-强引用"><a href="#一-强引用" class="headerlink" title="一.强引用"></a>一.强引用</h2><p>就是我们普通的引用。作为一个垃圾来说，什么时候才会被回收呢？当一个对象实例没有任何引用指向它的时候，它就是可以被回收的。当对象被回收的时候，会调用对象的<code>finalize</code>方法。</p>
<ul>
<li>最普遍的引用：<code>Object obj = new Object</code></li>
<li>抛出OutOfMemoryError终止程序也不会回收具有强引用的对象</li>
<li>通过将对象设置为null来弱化引用，使其被回收</li>
</ul>
<a id="more"></a>

<h2 id="二-软引用"><a href="#二-软引用" class="headerlink" title="二.软引用"></a>二.软引用</h2><p>代码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T_SoftReference</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        SoftReference&lt;<span class="keyword">byte</span>[]&gt; m = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> *<span class="number">10</span>]);</span><br><span class="line">        System.out.<span class="built_in">println</span>(m.<span class="built_in">get</span>());</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(m.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再分配一个数组，heap将装不下，这时候系统会垃圾回收，先回收一次，如果不够，会把软引用干掉</span></span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">15</span>];</span><br><span class="line">        System.out.<span class="built_in">println</span>(m.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//软引用非常适合缓存使用</span></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">-Xmx24M</span><br><span class="line">输出：</span><br><span class="line">[<span class="symbol">B@</span><span class="number">5387f</span>9e0</span><br><span class="line">[<span class="symbol">B@</span><span class="number">5387f</span>9e0</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>软引用不会立即被垃圾回收器回收，只有当堆内存不足时，会将软引用的对象进行回收，软引用可以用来做缓存使用。</p>
<ul>
<li>对象处在有用但非必须的状态</li>
<li>只有当内存空间不足时，GC会回收该引用对象的内存</li>
<li>可以实现高速缓存</li>
</ul>
<h2 id="三-弱引用"><a href="#三-弱引用" class="headerlink" title="三.弱引用"></a>三.弱引用</h2><p>弱引用只要被gc看到，就会立即回收这个对象。</p>
<ul>
<li>非必须的对象，比软引用更弱一些</li>
<li>GC时会被回收</li>
<li>被回收的概率也不大，因为GC线程优先级比较低</li>
<li>适用于引用偶尔被使用且不影响垃圾收集的对象</li>
</ul>
<p><strong>ThreadLocal</strong></p>
<ul>
<li><p>threadLocal隶属于一个线程，每个thread中都有一个ThreadLocalMap对象，这个对象以当前线程的threadlocal对象为key，要set的值为value进行存储，当get的时候先拿到当前线程，然后根据当前线程拿到<code>ThreadLocalMap</code>对象，然后根据threadlocal这个key拿到对应的值<br><img src="/2020/10/27/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/1.jpg" alt="threadlocalmaps"></p>
</li>
<li><p>而当我们set值的时候，是对entry进行set值操作，这个<code>Entry</code>对象继承了<code>WeakReference</code>，而这个entry里面的key指向了threadLocal对象，是一个弱引用。<br><img src="/2020/10/27/Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8/2.jpg" alt="threadlocalmaps"></p>
</li>
<li><p>为什么entry中的key要弱引用thread对象？如果是强引用的话，当我们的tl不用的时候(将tl = null)那么在我们的内存中，始终有一个key指向内存中的threadLocal对象，那么就不会被回收，就会发生内存泄漏问题。而弱引用就不会。</p>
</li>
<li><p>但是还是有内存泄漏存在，Threadlocal被回收，key的值变为null，则导致整value再也无法被访问到，因此依然存在内存泄漏。当你不想用这个数据的时候，需要调用<code>tl.remove()</code>.</p>
</li>
</ul>
<p><strong>！注意：线程池慎用ThreadLocal！！！</strong></p>
<h2 id="四-虚引用"><a href="#四-虚引用" class="headerlink" title="四.虚引用"></a>四.虚引用</h2><ul>
<li>不会决定对象的生命周期</li>
<li>任何时候都可能会被垃圾回收期回收</li>
<li>主要跟踪对象被垃圾回收期回收的活动，起哨兵作用</li>
<li>必须与引用队列ReferenceQueue联合使用</li>
</ul>
<p>gc在发现虚引用的对象的时候并不会真正地将其回收，而是会将他的引用放到引用队列中，作为垃圾回收线程会不断地去检查这个队列，发现什么时候有虚引用指向了一个对象，才会对其进行回收。</p>
<p><strong>用途：</strong>在于管理直接内存，堆外内存。</p>
<h2 id="五-引用队列（ReferenceQueue）"><a href="#五-引用队列（ReferenceQueue）" class="headerlink" title="五.引用队列（ReferenceQueue）"></a>五.引用队列（ReferenceQueue）</h2><ul>
<li>无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达</li>
<li>存储关联的且被GC的软引用、弱引用及虚引用</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/2021/07/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<hr>
<h1 id="一-对象的创建"><a href="#一-对象的创建" class="headerlink" title="一.对象的创建"></a>一.对象的创建</h1><p>当Java虚拟机遇到一条字节码new指令的时候，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<a id="more"></a>
<hr>
<h1 id="二-类加载的时机"><a href="#二-类加载的时机" class="headerlink" title="二.类加载的时机"></a>二.类加载的时机</h1><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历<code>加载（loading）</code>、<code>验证（Verfication）</code>、<code>准备（Preparation）</code>、<code>解析（Resolution）</code>、<code>初始化（Initialization）</code>、<code>使用（Using）</code>、<code>卸载（Unloading）</code>七个阶段，其中<em>验证、准备、解析三个部分统称为连接（Linking）</em>。</p>
<p><img src="/2021/07/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png" alt="Java类加载机制"></p>
<p>加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p>
<p><strong>对于初始化阶段，有且只有六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</strong></p>
<ol>
<li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码有：</p>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
</li>
<li><p>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</p>
</li>
<li><p>当虚拟机启动时，用户需要制定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</p>
</li>
<li><p>当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</p>
</li>
<li><p>当一个接口中定义JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</p>
</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，这六种场景的行为称为对一个类型进行<strong>主动引用</strong>。除此之外，所有引用类型的方式都不会触发初始化，被称为<strong>被动引用</strong>。</p>
<h2 id="接口与类的区别"><a href="#接口与类的区别" class="headerlink" title="接口与类的区别"></a>接口与类的区别</h2><p>接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：<br>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口（如引用接口中定义的常量）的时候才会初始化。</p>
<hr>
<h1 id="三-类加载的过程"><a href="#三-类加载的过程" class="headerlink" title="三.类加载的过程"></a>三.类加载的过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>对于数组类而言，情况有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。一个数组类（下面简称为C）创建过程中遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个纬度的类型）是引用类型，那就递归采用默认的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上（一个类型必须与类加载器一起确定唯一性）。</li>
<li>如果数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问</li>
</ul>
<p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段主要包括：</p>
<ul>
<li>文件格式验证，验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理</li>
<li>元数据验证，对字节码描述的信息进行语义分析</li>
<li>字节码验证，通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证，最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在<strong>解析</strong>阶段中发生。</li>
</ul>
<blockquote>
<p>在生产环境的实施阶段可以考虑使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间</p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p>
<ul>
<li>这个阶段仅对类变量，不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</li>
<li>初始值都是各种基础数据类型的默认值，而非程序员声明时的赋值。</li>
</ul>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<ul>
<li>类或接口的解析</li>
<li>字段解析</li>
<li>方法解析</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>类的初始化阶段是类加载过程的最后一个步骤。</p>
<p>在准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</p>
<hr>
<h1 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4.类加载器"></a>4.类加载器</h1><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但是它在Java程序中起到的作用却远超类加载阶段。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个唯一独立的类名称空间。比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那么这两个类就必不相等。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分</li>
<li>其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全部继承于抽象类java.lang.ClassLoader</li>
</ol>
<p>绝大多数的Java程序都会使用以下三个系统提供的类加载器来进行加载：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器负责加载存放在<JAVA_HOME>/lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null替代即可。</JAVA_HOME></li>
<li>扩展类加载器（Extension Class Loader）:这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>/lib/ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。这是一种Java系统类库的扩展机制。</JAVA_HOME></li>
<li>应用程序类加载器（Application Class Loader）：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystemClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。</li>
</ol>
<p><img src="/2021/07/20/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.png" alt="双亲委派模型"></p>
<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<h3 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h3><p>如果一个类加载器收到了类加载器的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。</p>
<p>精确到代码：</p>
<blockquote>
<p>先检查请求加载的类型是否已被加载过，若没有则调用父加载器的loadClass()当法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
</blockquote>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，被存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p>
<p>双亲委派模型对于保证Java程序的稳定运作极为重要。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven解决jar包冲突</title>
    <url>/2020/07/13/Maven%E8%A7%A3%E5%86%B3jar%E5%8C%85%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、Maven中jar包冲突产生原因"><a href="#一、Maven中jar包冲突产生原因" class="headerlink" title="一、Maven中jar包冲突产生原因"></a>一、Maven中jar包冲突产生原因</h3><p>MAVEN项目运行中如果报如下错误：</p>
<ul>
<li>Caused by:java.lang.NoSuchMethodError</li>
<li>Caused by: java.lang.ClassNotFoundException<br>十有八九是Maven jar包冲突造成的。那么jar包冲突是如何产生的？<br>首先我们需要了解jar包依赖的传递性。<h5 id="1、依赖传递"><a href="#1、依赖传递" class="headerlink" title="1、依赖传递"></a>1、依赖传递</h5>当我们需要A的依赖的时候，就会在pom.xml中引入A的jar包；而引入的A的jar包中可能又依赖B的jar包，这样Maven在解析pom.xml的时候，会依次将A、B 的jar包全部都引入进来。</li>
</ul>
<a id="more"></a>

<p>举个例子：<br>在Spring Boot应用中导入Hystrix和原生Guava的jar包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--原生Guava API--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>20.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--hystrix依赖（包含对Guava的依赖）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>利用<code>Maven Helper</code>插件得到项目导入的jar包依赖树：<br><img src="https://upload-images.jianshu.io/upload_images/15200008-d6cc2115ee502001.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Maven helper"><br>从图中可以看出Hystrix包含对Guava jar包依赖的引用： Hystrix -&gt; Guava，所以在引入Hystrix的依赖的时候，会将Guava的依赖也引入进来。</p>
<h5 id="2-jar包冲突原理"><a href="#2-jar包冲突原理" class="headerlink" title="2.jar包冲突原理"></a>2.jar包冲突原理</h5><p>假设有如下依赖关系：</p>
<ul>
<li><p>A-&gt;B-&gt;C-&gt;D1(log 15.0)：A中包含对B的依赖，B中包含对C的依赖，C中包含对D1的依赖，假设是D1是日志jar包，version为15.0</p>
</li>
<li><p>E-&gt;F-&gt;D2(log 16.0)：E中包含对F的依赖，F包含对D2的依赖，假设是D2是同一个日志jar包，version为16.0</p>
</li>
</ul>
<p>当pom.xml文件中引入A、E两个依赖后，根据Maven传递依赖的原则，D1、D2都会被引入，而D1、D2是同一个依赖D的不同版本。<br>当我们在调用D2中的method1()方法，而D1中是15.0版本（method1可能是D升级后增加的方法），可能没有这个方法，这样JVM在加载A中D1依赖的时候，找不到method1方法，就会报NoSuchMethodError的错误，此时就产生了jar包冲突。</p>
<p>注：</p>
<blockquote>
<p>如果在调用method2()方法的时候，D1、D2都含有这个方法（且升级的版本D2没有改动这个方法，这样即使D有多个版本，也不会产生版本冲突的问题。）</p>
</blockquote>
<p>举个例子：</p>
<p>利用Maven Helper插件分析得出：Guava这个依赖包产生冲突。<br>我们之前导入了Guava的原生jar包，版本号是20.0；而现在提示Guava产生冲突，且冲突发生位置是Hystrix所在的jar包，所以可以猜测Hystrix中包含了对Guava不同版本的jar包的引用。</p>
<p>为了验证我们的猜想，使用Maven Helper插件找到Hystrix依赖的jar：<br><img src="https://upload-images.jianshu.io/upload_images/15200008-5877bb2f0f136f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-a05b5161000a3e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hystrix-javanica依赖"></p>
<p>可以看到：Hystrix jar中所依赖的Guava jar包是15.0版本的，而我们之前在pom.xml中引入的原生Guava jar包是20.0版本的，这样Guava就有15.0 与20.0这两个版本，因此发生了jar包冲突。</p>
<h3 id="二、-Maven中jar包冲突的解决方案"><a href="#二、-Maven中jar包冲突的解决方案" class="headerlink" title="二、 Maven中jar包冲突的解决方案"></a>二、 Maven中jar包冲突的解决方案</h3><p>Maven 解析 pom.xml 文件时，同一个 jar 包只会保留一个，那么面对多个版本的jar包，需要怎么解决呢？</p>
<h5 id="1、-Maven默认处理策略"><a href="#1、-Maven默认处理策略" class="headerlink" title="1、 Maven默认处理策略"></a>1、 Maven默认处理策略</h5><p><strong>最短路径优先</strong></p>
<p>Maven 面对 D1 和 D2 时，会默认选择最短路径的那个 jar 包，即 D2。E-&gt;F-&gt;D2 比 A-&gt;B-&gt;C-&gt;D1 路径短 1。</p>
<p><strong>最先声明优先</strong></p>
<p>如果路径一样的话，如： A-&gt;B-&gt;C1, E-&gt;F-&gt;C2 ，两个依赖路径长度都是 2，那么就选择最先声明。</p>
<h5 id="2、移除依赖：用于排除某项依赖的依赖jar包"><a href="#2、移除依赖：用于排除某项依赖的依赖jar包" class="headerlink" title="2、移除依赖：用于排除某项依赖的依赖jar包"></a>2、移除依赖：用于排除某项依赖的依赖jar包</h5><p>（1）我们可以借助Maven Helper插件中的Dependency Analyzer分析冲突的jar包，然后在对应标红版本的jar包上面点击execlude，就可以将该jar包排除出去。</p>
<p>再刷新以后冲突就会消失。</p>
<p>（2）手动排除<br>或者手动在pom.xml中使用<exclusion>标签去排除冲突的jar包（上面利用插件Maven Helper中的execlude方法其实等同于该方法）：</exclusion></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--hystrix依赖（包含对Guava的依赖）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="3-版本锁定原则：一般用在继承项目的父项目中"><a href="#3-版本锁定原则：一般用在继承项目的父项目中" class="headerlink" title="3 版本锁定原则：一般用在继承项目的父项目中"></a>3 版本锁定原则：一般用在继承项目的父项目中</h5><p>正常项目都是多模块的项目，如moduleA和moduleB共同依赖X这个依赖的话，那么可以将X抽取出来，同时设置其版本号，这样X依赖在升级的时候，不需要分别对moduleA和moduleB模块中的依赖X进行升级，避免太多地方（moduleC、moduleD….）引用X依赖的时候忘记升级造成jar包冲突，这也是实际项目开发中比较常见的方法。</p>
<p>首先定义一个父pom.xml，将公共依赖放在该pom.xml中进行声明：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>spring4.2.4<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">             <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.versio&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>这样如moduleA和moduleB在引用Spring-beans jar包的时候，直接使用父pom.xml中定义的公共依赖就可以：<br>moduleA在其pom.xml使用spring-bean的jar包(不用再定义版本)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>moduleB在其pom.xml使用spring-bean的jar包如上类似：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="三、相关命令"><a href="#三、相关命令" class="headerlink" title="三、相关命令"></a>三、相关命令</h3><p>如果不用<code>Maven Helper</code>这个从插件，maven还支持用命令的方式进行分析jar包冲突：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn</span> dependency:tree</span><br></pre></td></tr></table></figure>
<p>以上命令是输出到控制台，还可以输出到文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mvn dependency:tree&gt;<span class="regexp">/Users/</span>tinner<span class="regexp">/Desktop/</span><span class="number">1</span>.txt</span><br></pre></td></tr></table></figure>
<p>查询指定jar包的冲突:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mvn dependency:tree -Dverbose <span class="attribute">-Dincludes</span>=com.google.guava</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql(一)InnoDB存储引擎</title>
    <url>/2020/12/06/Mysql-%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="InnoDB页简介"><a href="#InnoDB页简介" class="headerlink" title="InnoDB页简介"></a>InnoDB页简介</h3><p>InnoDB是一个将表中的数据存储到磁盘上的存储引擎。它将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位。InnoDB中页的大小一般为16KB。也就是说在一般情况下，一次至少从磁盘中读取16KB的内容到内存中，一次至少把内存中的16KB的内容刷新到磁盘中。</p>
<blockquote>
<p>系统变量<code>innodb_page_size</code>表明了InnoDB存储引擎中的页大小，默认为16384（单位是字节，也就是16KB）。这个变量只能在第一次初始化的Mysql数据目录时指定，之后就再也不能更改了。</p>
</blockquote>
<a id="more"></a>
<h3 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h3><p>我们平时都是以记录为单位向表中插入数据的，这些记录在磁盘上的存放形式也被成为行格式或者记录格式。</p>
<p>大体上目前有4种行格式：</p>
<ul>
<li>compact</li>
<li>redundant</li>
<li>dynamic</li>
<li>compressed</li>
</ul>
<p>在创建表或修改表结构时指定行格式的语法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">CREATE 表名(列的信息<span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>) <span class="attribute">ROW_FORMAT</span>=行格式名称;</span><br><span class="line">ALTER TABLE 表名 <span class="attribute">ROW_FORMAT</span>=行格式名称;</span><br></pre></td></tr></table></figure>

<h4 id="compact行格式"><a href="#compact行格式" class="headerlink" title="compact行格式"></a>compact行格式</h4><p><img src="/2020/12/06/Mysql-%E4%B8%80-InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/compact.png" alt="compact行格式"></p>
<h5 id="1-记录的额外信息"><a href="#1-记录的额外信息" class="headerlink" title="1.记录的额外信息"></a>1.记录的额外信息</h5><p>这部分信息是服务器为了更高地管理记录而不得不额外添加的一些信息，这些额外信息分为三个部分，分别是变长字段长度列表、NULL值和记录头信息</p>
<p>（1）变长字段长度列表（被定义为VARCHAR(M)、各种TEXT类型、各种BLOB类型）</p>
<p>变长字段占用的存储空间分为两部分:</p>
<ul>
<li>真正的数据内容</li>
<li>该数据占用的字节数</li>
</ul>
<p>变长字段长度的数据特点：</p>
<ul>
<li>各变长字段的真实数据占用的字节数按照列的顺序逆序存放</li>
<li>如果该变长字段允许存储的最大字节数（varchar(M)中的M*SHOW CHARSET结果中的Maxlen列[每个字符集都不相同]W的值）超过255个字节，并且真实数据占用的字节数（L）超过127字节，则使用2字节来表示真实数据占用的字节数，否则使用1字节</li>
<li>变长字段长度列表中只存储值为非NULL的列的长度，不存放值为NULL的内容长度</li>
<li>如果表中所有的列都不是变长的数据类型或者所有列的值都是NULL的话，就不需要有变长字段长度列表</li>
</ul>
<p>（2）NULL值列表</p>
<p>compact行格式把一条记录中值为NULL的列统一管理起来，存储到NULL值列表中。处理的流程如下：</p>
<ul>
<li>首先统计表中允许存储NULL的列有哪些</li>
<li>如果表中没有允许存储NULL的列，则NULL值列表就不存在，否则将每个允许存储NULL的列对应一个二进制位，二进制位按照列的顺序逆序排列（二进制位的值为1时，代表该列的值为NULL；为0时不为NULL）</li>
<li>Mysql规定NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补0</li>
</ul>
<p>（3）记录头信息</p>
<p>记录头信息由固定的5个字节组成（40个二进制位）</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">大小（位）</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">预留位1</td>
<td align="center">1</td>
<td align="left">没有使用</td>
</tr>
<tr>
<td align="center">预留位2</td>
<td align="center">1</td>
<td align="left">没有使用</td>
</tr>
<tr>
<td align="center">delete_flag</td>
<td align="center">1</td>
<td align="left">标记该记录是否被删除</td>
</tr>
<tr>
<td align="center">min_rec_flag</td>
<td align="center">1</td>
<td align="left">B+树的每层非叶子节点中最小的目录项记录都会添加该标记</td>
</tr>
<tr>
<td align="center">n_owned</td>
<td align="center">4</td>
<td align="left">一个页面中的记录会被分成若干个组，每个组中有一个记录是“带头大哥”，记录的n_owned值代表组中所有的记录条数。其余的都是小弟，记录的为0</td>
</tr>
<tr>
<td align="center">heap_no</td>
<td align="center">13</td>
<td align="left">表示当前记录在页面堆中的相对位置</td>
</tr>
<tr>
<td align="center">record_type</td>
<td align="center">3</td>
<td align="left">表示当前记录的类型：0-普通记录；1-B+树非叶子节点的目录项记录；2-Infimum记录；3-Supremum记录</td>
</tr>
<tr>
<td align="center">next_record</td>
<td align="center">16</td>
<td align="left">表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<h5 id="2-记录的真实数据"><a href="#2-记录的真实数据" class="headerlink" title="2.记录的真实数据"></a>2.记录的真实数据</h5><p>对于我们定义的数据列来说，对于每个记录mysql都会默认地添加一些隐藏列：</p>
<table>
<thead>
<tr>
<th align="center">列名</th>
<th align="center">是否必需</th>
<th align="center">占用空间</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">row_id</td>
<td align="center">否</td>
<td align="center">6个字节</td>
<td align="center">行ID，唯一标识一条记录</td>
</tr>
<tr>
<td align="center">trx_id</td>
<td align="center">是</td>
<td align="center">6个字节</td>
<td align="center">事务ID</td>
</tr>
<tr>
<td align="center">roll_pointer</td>
<td align="center">是</td>
<td align="center">7个字节</td>
<td align="center">回滚指针</td>
</tr>
</tbody></table>
<p><strong>InnoDB的主键生成策略</strong><br>优先使用用户自定义的主键作为主键；如果用户没有定义主键，则选取一个不允许为null值的UNIQUE键作为主键；以上两种条件都没有，则会默认添加一个名为row_id的隐藏列作为主键</p>
<p><strong>隐藏列和真实数据的排列</strong></p>
<ul>
<li>在实际存储中，隐藏列会按照row_id、trx_id、roll_pointer的顺序排列在最前面</li>
<li>紧接着就会按照创建表的字段顺序依次排列在三个隐藏列的后面（NULL值不会冗余存储）</li>
</ul>
<h5 id="3-CHAR-M-列的存储格式"><a href="#3-CHAR-M-列的存储格式" class="headerlink" title="3.CHAR(M)列的存储格式"></a>3.CHAR(M)列的存储格式</h5><p>在mysql中有如下字符集：</p>
<ul>
<li>ascii采用固定的一个字节来编码一个字符，是一个定长的编码字符集</li>
<li>gbk表示一个字符需要1~2个字节</li>
<li>utf8表示一个字符需要1~3个字节</li>
</ul>
<p>对于CHAR(M)类型的列来讲：</p>
<ul>
<li>采用定长的编码字符集，该列占用的字节数不会被加到变长字段长度列表中</li>
<li>采用变长的编码字符集，该列占用的字节数会被加到变长字段长度列表中</li>
</ul>
<blockquote>
<p>另外当采用变长的字符集编码格式的时候对于CHAR(M)还规定：CHAR(M)至少要求占用M个字节。比如utf8格式的话，定义CHAR(10)，长度就是10~30字节，即使存储空字符串也会占用十个字节。这主要是希望未来在更新该列时，在新值的字节长度大于旧值的字节长度但不大于10个字节时，可以在该记录处直接更新而不用重新分配空间</p>
</blockquote>
<h4 id="redundant行格式"><a href="#redundant行格式" class="headerlink" title="redundant行格式"></a>redundant行格式</h4><p>在5.0之前在使用的一种格式，很古老,比较原始的行格式，是非紧凑的，比其他三种占用的存储空间多</p>
<h3 id="溢出列"><a href="#溢出列" class="headerlink" title="溢出列"></a>溢出列</h3><p>在compact和redundant行格式中，对于占用存储空间非常多的列，在记录的真实数据处只会存储该列的一部分数据，而把剩余的数据分散存储到其他的页中，然后在记录的真实数据处用20字节存储指向这些页的地址，从而可以找到剩余数据所在的页（剩余数据的多个页面使用链表连接起来）</p>
<p>如果一条记录的某个列中存储的数据占用的字节数非常多时，该列就可能成为溢出列</p>
<h3 id="dynamic行格式和compressed行格式"><a href="#dynamic行格式和compressed行格式" class="headerlink" title="dynamic行格式和compressed行格式"></a>dynamic行格式和compressed行格式</h3><p>5.7默认的行格式是<code>dynamic</code></p>
<p>共同点：</p>
<ul>
<li>他们都是继承于compact行格式</li>
<li>在处理溢出页的时候不会在记录的真实数据处存储该溢出列的真实数据的前n个字节的数据，而是将该列的所有真实数据都存储到溢出页中，只在记录的真实数据处存储20个字节大小的指向溢出页的地址（当然，这20字节还包括真实数据占用的字节数）</li>
</ul>
<p>不同点：</p>
<ul>
<li>compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql(二)Mysql的数据目录</title>
    <url>/2020/12/07/Mysql-%E4%BA%8C-Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="数据库和文件系统的关系"><a href="#数据库和文件系统的关系" class="headerlink" title="数据库和文件系统的关系"></a>数据库和文件系统的关系</h3><p>像InnoDB、MyISAM这样的存储引擎都是把数据存储在文件系统中上。当我们想读取数据的时候，这些存储引擎会从文件系统中把数据读出来返回给我们；当我们想写入数据的时候，这些存储引擎会把这些数据又写回操作系统。</p>
<a id="more"></a>

<h3 id="Mysql数据目录"><a href="#Mysql数据目录" class="headerlink" title="Mysql数据目录"></a>Mysql数据目录</h3><p>Mysql服务器程序在启动时，会到文件系统的某个目录下加载一些数据，之后在运行过程中产生的数据也会存储到这个目录下的某些文件中。这个目录就称为数据目录。</p>
<h5 id="确定Mysql中的数据目录"><a href="#确定Mysql中的数据目录" class="headerlink" title="确定Mysql中的数据目录"></a>确定Mysql中的数据目录</h5><p>运行如下命令：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="emphasis">&#x27;datadir&#x27;</span>;</span><br><span class="line"><span class="code">+---------------+</span>-----------------------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value                 |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------+</span></span><br><span class="line"><span class="emphasis">| datadir       | /usr/local/var/mysql/ |</span></span><br><span class="line"><span class="emphasis">+---------------+-----------------------+</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<p>即可看到数据目录在我们计算机中的位置</p>
<h5 id="创建数据库的时候都发生了什么"><a href="#创建数据库的时候都发生了什么" class="headerlink" title="创建数据库的时候都发生了什么"></a>创建数据库的时候都发生了什么</h5><p>在我们使用“CREATE DATABASE 数据库名”语句创建一个数据库的时候，会在文件系统中发生：</p>
<ul>
<li>在数据目录下创建一个与数据库名同名的子目录（或者说是文件夹）</li>
<li>在与该数据库名同名的子目录下创建一个名为db.opt的文件。这个文件中包含了该数据库的一些属性，比如该数据库的字符集和比较规则</li>
</ul>
<h5 id="数据库的文件表示"><a href="#数据库的文件表示" class="headerlink" title="数据库的文件表示"></a>数据库的文件表示</h5><p>我先来查看我当前拥有的数据库</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line"><span class="code">+--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line"><span class="code">+--------------------+</span></span><br><span class="line">| information<span class="emphasis">_schema |</span></span><br><span class="line"><span class="emphasis">| gateway_</span>config     |</span><br><span class="line">| mysql              |</span><br><span class="line">| nacos<span class="emphasis">_config       |</span></span><br><span class="line"><span class="emphasis">| performance_</span>schema |</span><br><span class="line">| sys                |</span><br><span class="line">| tinner             |</span><br><span class="line"><span class="code">+--------------------+</span></span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到，当前在我的计算机上有7个数据库，其中gateway_config、nacos_config和tinner是我自定义的，其余4个数据库都是Mysql自带的系统数据库</p>
<p>再来看看我的目录结构<br><img src="/2020/12/07/Mysql-%E4%BA%8C-Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/1.png" alt="目录结构"><br>自己看会发现，除了information_schema这个系统数据库外，其他数据库在数据目录下都有对应的子目录</p>
<h5 id="表在文件系统中的表示"><a href="#表在文件系统中的表示" class="headerlink" title="表在文件系统中的表示"></a>表在文件系统中的表示</h5><p>我们的数据其实都是以记录的形式插入到表中的。每个表的信息可以分为两种：</p>
<ul>
<li>表结构的定义</li>
<li>表中的数据</li>
</ul>
<p>MyISAM和InooDB都在数据目录下对应的数据库子目录创建了一个专门用于描述<code>表结构</code>的文件，文件名是<code>表名.frm</code>，以二进制格式存储。</p>
<p>而在数据存入文件上MyISAM和InooDB产生了分歧：</p>
<h6 id="lt-1-gt-InnoDB："><a href="#lt-1-gt-InnoDB：" class="headerlink" title="&lt;1&gt;InnoDB："></a>&lt;1&gt;InnoDB：</h6><ul>
<li>InnoDB使用页为基本单位来管理存储空间的，默认的页大小为16KB</li>
<li>对于InnoDB存储引擎来说，每个索引都对应着一棵B+树，该树的每个节点都是一个数据页。数据页之间没有必要是物理连续的，因为数据页之间有双向链表来维护这些页的顺序</li>
<li>InnoDB的聚簇索引的叶子节点存储了完整的用户记录，也就是“索引即数据，数据即索引”</li>
</ul>
<p><strong>1.系统表空间</strong></p>
<p>在默认情况下，InnoDB会在数据目录下创建爱你一个名为ibdata1、大小为12MB的文件，这个文件就是对应的系统表空间在文件系统上的表示。这个文件是自扩展文件，当不够用的时候它会自己增加文件大小</p>
<p>在一个Mysql服务器中，系统表空间只有一份。从Mysql5.5.7到Mysql5.6.5之间的各个版本中，表中的数据都会被默认存储到这个系统表空间。</p>
<p><strong>2.独立表空间</strong></p>
<p>在Mysql5.6.6以及之后的版本中，InnoDB会为每个表建立一个独立表空间。在存储表数据时，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，该文件为<code>表名.ibd</code>。</p>
<p>假如我在tinner库下创建了s1表，那么在对应的tinner目录下回生成两个文件：</p>
<ul>
<li>s1.frm</li>
<li>s1.ibd<br><img src="/2020/12/07/Mysql-%E4%BA%8C-Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/2.png" alt="innodb"><br>其中ibd文件用来存储表中的数据</li>
</ul>
<p>当我们想刻意将表数据都存储到系统表空间时，在配置文件中修改：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[server]</span></span><br><span class="line"><span class="selector-tag">innodb_file_per_table</span><span class="selector-pseudo">:0</span></span><br></pre></td></tr></table></figure>
<p>当innodb_file_per_table为0时，代表使用系统表空间，为1时使用独立表空间。不过只对新增的表有效</p>
<p>将已经存储到系统表空间中的表转移到独立表空间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">TABLESPACE</span> innodb_file_per_table;</span><br></pre></td></tr></table></figure>

<p>将已经存储到独立表空间的表转移到系统表空间:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">TABLESPACE</span> innodb_system;</span><br></pre></td></tr></table></figure>

<p><strong>3其他类型的表空间</strong><br>通用表空间、undo表空间、临时表空间等</p>
<h6 id="lt-2-gt-MyISAM："><a href="#lt-2-gt-MyISAM：" class="headerlink" title="&lt;2&gt;MyISAM："></a>&lt;2&gt;MyISAM：</h6><p>MyISAM中的索引相当于全部都是二级索引，该存储引擎的数据和索引是分开存放的。没有表空间一说。在创建爱你表之后会创建如下三个文件：</p>
<ul>
<li>表名.frm</li>
<li>表名.MYD</li>
<li>表名.MYI</li>
</ul>
<p><img src="/2020/12/07/Mysql-%E4%BA%8C-Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/2.png" alt="myisam"></p>
<p>其中，表名.MYD表示表的数据文件，表名MYI表示表的索引文件。</p>
<h5 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h5><p>除了上面说的这些童虎自己存储的数据以外，数据目录下还包含了一些确保程序更好运行的额外文件，主要包括：</p>
<ul>
<li>服务器进程文件：每运行一个mysql服务器程序，都意味着启动一个进程。mysql服务器会把自己的进程ID写到这个文件中</li>
<li>服务器日志文件</li>
<li>ssl和rsa证书与秘钥文件：主要是为了客户端和服务器安全通信而创建的一些文件</li>
</ul>
<h3 id="文件系统对数据库的影响"><a href="#文件系统对数据库的影响" class="headerlink" title="文件系统对数据库的影响"></a>文件系统对数据库的影响</h3><ul>
<li>数据库名称和表名不得超过文件系统所允许的最大长度</li>
<li>特殊字符的问题：比如创建‘test?’表，则生成了‘test@003f.frm’文件</li>
<li>文件长度受文件系统最大长度限制</li>
</ul>
<h3 id="Mysql系统数据库简介"><a href="#Mysql系统数据库简介" class="headerlink" title="Mysql系统数据库简介"></a>Mysql系统数据库简介</h3><p>在前文看到除了我自定义的3个数据库，还有4个数据库，属于系统自带的数据库</p>
<ul>
<li>mysql：存储了Mysql的用户账户和权限信息、一些存储过程和事件的定义信息、一些运行过程中产生的日志信息、一些帮助信息以及时区信息等</li>
<li>information_schema：存放元数据信息，保存着服务器维护的所有其他数据库的信息（表、视图、触发器、列、索引等）</li>
<li>performance_schema：存放运行过程中的状态信息，算是对Mysql服务器的一个性能监控</li>
<li>sys：通过视图的形式将information_schema和performance_schema结合起来</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos和其他注册中心的比较</title>
    <url>/2020/08/17/Nacos%E5%92%8C%E5%85%B6%E4%BB%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="CAP定律"><a href="#CAP定律" class="headerlink" title="CAP定律"></a>CAP定律</h3><p>这个定理的内容是指的是在一个分布式系统中、<code>Consistency（一致性）</code>、 <code>Availability（可用性）</code>、<code>Partition tolerance（分区容错性）</code>，三者不可得兼。</p>
<p><strong>一致性(C)：</strong> 在分布式系统中，如果服务器集群，每个节点在同时刻访问必须要保持数据的一致性。<br><strong>可用性(A)：</strong> 集群节点中，部分节点出现故障后任然可以使用 （高可用）<br><strong>分区容错性(P)：</strong> 在分布式系统中网络会存在脑裂的问题，部分Server与整个集群失去节点联系，无法组成一个群体。</p>
<p>只有在CP和AP选择一个平衡点</p>
<p>两种情况：</p>
<ul>
<li>CP情况下，虽然我们服务不能用，但是必须要保证数据的一致性</li>
<li>AP情况下，可以短暂保证数据不一致，但是最终可以一致性，不管怎么样，要保证我的服务可用。<br>注册中心大多数采用<strong>AP</strong> 模式<a id="more"></a>

</li>
</ul>
<h3 id="Nacos、Eureka、Zookeeper比较"><a href="#Nacos、Eureka、Zookeeper比较" class="headerlink" title="Nacos、Eureka、Zookeeper比较"></a>Nacos、Eureka、Zookeeper比较</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><pre><code>都可以实现分布式服务注册中心</code></pre>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><h5 id="1-Zookeeper"><a href="#1-Zookeeper" class="headerlink" title="1.Zookeeper"></a>1.Zookeeper</h5><p>Zookeeper采用CP保证数据一致性的问题，原理采用Zab原子广播协议，当我们的zk领导因为某种原因宕机的情况下，会自动触发重新选一个新的领导角色，整个选举的过程为了保证数据的一致性的问题，在选举的过程中整个zk环境是不可以使用的，可能短暂无法使用到zk，意味着微服务采用该模式的情况下可能无法实现通讯（本地有缓存除外）。ZK可以运行的节点必须满足过半机制，整个zk才可以使用。</p>
<h5 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2.Eureka"></a>2.Eureka</h5><p>Eureka采用AP的设计理念架构注册中心，完全去中心化思想，也就是说没有主从之分。每个节点都是均等的，采用相互注册原理，你中有我我中有你，只要有最后有一个节点存在就可以保证整个微服务可以实现通讯。</p>
<blockquote>
<p>中心化：必须要围绕一个领导角色为核心，选举为领导和跟随者角色<br>去中心化：每个角色都是均等的</p>
</blockquote>
<h5 id="3-Eureka"><a href="#3-Eureka" class="headerlink" title="3.Eureka"></a>3.Eureka</h5><p>Nacos从1.0版本支持CP和AP混合模式集群，默认是采用AP保证服务可用性，CP的形式底层集群通过<em>raft协议</em>保证数据的一致性问题。如果我们采用AP模式，注册服务的实例仅支持临时注册形式，在网络分区产生抖动的情况下，仍然可以继续注册我们的服务列表。如果选择CP模式，必须保证数据的强一致性问题，如果网络分区产生抖动的情况下，是无法注册我们的服务列表，但是选择CP模式可以支持注册实例持久。</p>
<p><strong>什么情况下选择AP和CP呢？</strong><br>必须要求读取接口的地质保证强一致性的问题，可以采用CP模式，一般AP的情况是可以的。</p>
<p><strong>如何实现切换模式？</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nacos_server</span>:<span class="number">8848</span><span class="regexp">/nacos/</span>v1<span class="regexp">/ns/</span>operator/switches?entry=serverMode&amp;value=CP</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 必须是发送PUT请求！！！</p>
<p>我们在使用注册中心时，可以允许读取的数据短暂不一致，但是要保证注册中心能够使用，<strong>可用性优先级最高</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos整合SpringCloud</title>
    <url>/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/2.png" alt="项目结构"></p>
<a id="more"></a>

<h3 id="主项目maven依赖"><a href="#主项目maven依赖" class="headerlink" title="主项目maven依赖"></a>主项目maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  springboot 整合web组件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="会员服务-生产者"><a href="#会员服务-生产者" class="headerlink" title="会员服务(生产者)"></a>会员服务(生产者)</h3><h5 id="服务接口"><a href="#服务接口" class="headerlink" title="服务接口"></a>服务接口</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">&quot;<span class="subst">$&#123;server.port&#125;</span>&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会员服务提供的接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">&quot;/getUser&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String getUser(Integer userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello nacos,端口号:&quot;</span> + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tinner-member</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#nacos注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>在这里我直接使用负载均衡进行调用了，所以要启动两个服务来模拟实现集群（修改端口号），关于idea中支持一套代码启动两个服务的设置：<br><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/3.png" alt="项目结构"></p>
<h3 id="订单服务-消费者"><a href="#订单服务-消费者" class="headerlink" title="订单服务(消费者)"></a>订单服务(消费者)</h3><h5 id="订单调用会员服务"><a href="#订单调用会员服务" class="headerlink" title="订单调用会员服务"></a>订单调用会员服务</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> OrderController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 3:44 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orderToMember&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">orderToMember</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.根据服务名称从注册中心获取到集群的列表地址</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;tinner-member&quot;</span>);</span><br><span class="line">        <span class="comment">//2.列表任意选择一个，实现本地rpc调用 rest</span></span><br><span class="line"><span class="comment">//        ServiceInstance serviceInstance = instances.get(0);</span></span><br><span class="line">        ServiceInstance singleAddress = loadBalancer.getSingleAddress(instances);</span><br><span class="line">        String result = restTemplate.getForObject(singleAddress.getUri() + <span class="string">&quot;/getUser&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;订单调用会员返回结果：&quot;</span>+ result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> LoadBalancer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 4:19 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据多个不同的地址，返回单个调用rpc地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInstanceList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServiceInstance getSingleAddress(<span class="keyword">List</span>&lt;ServiceInstance&gt; serviceInstanceList);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> RotationLoadBalancer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 轮询的方式进行负载均衡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 4:29 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotationLoadBalancer</span> <span class="keyword">implements</span> <span class="title">LoadBalancer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问次数</span></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger requireNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询的方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceInstanceList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceInstance <span class="title">getSingleAddress</span><span class="params">(List&lt;ServiceInstance&gt; serviceInstanceList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceInstanceList.get(requireNum.incrementAndGet() % serviceInstanceList.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>1、分别以8080、8081端口启动两个tinner-member服务，可以看到在nacos控制台中注册了两个<code>tinner-member</code>服务<br><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/4.png" alt="运行效果"><br>2、启动order服务，调用order的接口，多次调用，可以依次看到轮询访问<code>tinner-member</code>服务<br><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/5.png" alt="运行效果"><br><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/6.png" alt="运行效果"><br>3、如果在控制台中将某个节点下掉，由于轮询的时候是动态获取服务列表的，所以对于调用方并没有感知，依旧能为order提供服务<br><img src="/2020/08/05/Nacos%E6%95%B4%E5%90%88SpringCloud/7.png" alt="运行效果"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenFeign客户端</title>
    <url>/2020/08/11/OpenFeign%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><ul>
<li>SpringCloud第一代采用feign，第二代采用OpenFeign</li>
<li>OpenFeign是一个Web声明式的Http客户端调用工具，提供接口和注解形式调用。底层封装的是httpclient技术</li>
<li>Openfeign是springCloud自己研发的。而feign是netflix研发的，自2016年之后不再维护了</li>
</ul>
<h3 id="二、使用时的注意事项"><a href="#二、使用时的注意事项" class="headerlink" title="二、使用时的注意事项"></a>二、使用时的注意事项</h3><ul>
<li>如果请求参数中没有指定注解的话，默认发送的是post请求。所以如果要发get请求，需要在参数上加<code>@RequestParam</code>注解</li>
<li>feign客户端支持负载均衡，用的ribbon</li>
<li>在微服务中服务的名称不能带下划线<a id="more"></a>

</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(<span class="string">&quot;tinner-member&quot;</span>)</span><br><span class="line">public interface UserServiceFeign &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供发布接口</span></span><br><span class="line"><span class="comment">     * @param userId</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/getUser&quot;</span>)</span><br><span class="line">    String getUser(<span class="variable">@RequestParam</span>(<span class="string">&quot;userId&quot;</span>) Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、项目结构"><a href="#三、项目结构" class="headerlink" title="三、项目结构"></a>三、项目结构</h3><p><img src="/2020/08/11/OpenFeign%E5%AE%A2%E6%88%B7%E7%AB%AF/1.png" alt="项目结构"></p>
<h3 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h3><h4 id="1、父pom文件"><a href="#1、父pom文件" class="headerlink" title="1、父pom文件"></a>1、父pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--服务注册与发现--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2、会员服务接口UserService"><a href="#2、会员服务接口UserService" class="headerlink" title="2、会员服务接口UserService"></a>2、会员服务接口UserService</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供会员接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param userId</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/getUser&quot;</span>)</span><br><span class="line">    String getUser(<span class="variable">@RequestParam</span>(<span class="string">&quot;userId&quot;</span>) Long userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3、会员服务实现类UserServiceImpl"><a href="#3、会员服务实现类UserServiceImpl" class="headerlink" title="3、会员服务实现类UserServiceImpl"></a>3、会员服务实现类UserServiceImpl</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是会员服务&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4、订单服务OrderServiceImpl"><a href="#4、订单服务OrderServiceImpl" class="headerlink" title="4、订单服务OrderServiceImpl"></a>4、订单服务OrderServiceImpl</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceFeign userServiceFeign;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">&quot;/orderFeignToUser&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String orderFeignToUser()&#123;</span><br><span class="line">        String user = userServiceFeign.getUser(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我是订单服务调用会员服务的接口，返回结果：&quot;</span>+ user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、feign客户端"><a href="#5、feign客户端" class="headerlink" title="5、feign客户端"></a>5、feign客户端</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(<span class="string">&quot;tinner-member&quot;</span>)</span><br><span class="line">public interface UserServiceFeign &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供发布接口</span></span><br><span class="line"><span class="comment">     * @param userId</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/getUser&quot;</span>)</span><br><span class="line">    String getUser(<span class="variable">@RequestParam</span>(<span class="string">&quot;userId&quot;</span>) Integer userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、运行效果"><a href="#五、运行效果" class="headerlink" title="五、运行效果"></a>五、运行效果</h3><p><img src="/2020/08/11/OpenFeign%E5%AE%A2%E6%88%B7%E7%AB%AF/2.jpg" alt="项目结构"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>ShardingSphere</title>
    <url>/2020/08/11/ShardingSphere/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、分布式数据库的核心功能"><a href="#一、分布式数据库的核心功能" class="headerlink" title="一、分布式数据库的核心功能"></a>一、分布式数据库的核心功能</h3><h4 id="1、分布式存储"><a href="#1、分布式存储" class="headerlink" title="1、分布式存储"></a>1、分布式存储</h4><p>数据的存储不再受单机存储的制约，可以通过服务器的数量增加存储量</p>
<h4 id="2、计算存储分离"><a href="#2、计算存储分离" class="headerlink" title="2、计算存储分离"></a>2、计算存储分离</h4><p>数据量多了，对应的算例也多了，如果每一台分布式存储里面都有一个计算节点，那么就会造成浪费。存储和计算的需求对系统的要求可能是不同的。用计算存储相分离，当我们需要提高算力的时候增加计算几点，当我    们需要增加存储量的时候增加存储节点，而计算节点是无状态的。</p>
<a id="more"></a>

<h4 id="3、分布式事务"><a href="#3、分布式事务" class="headerlink" title="3、分布式事务"></a>3、分布式事务</h4><p>因为我们把数据库通过分布式的形式分开了之后，事务就是一个很麻烦的事情。所以做一个高性能的、完全支持ACID原义的分布式事务引擎</p>
<h4 id="4、弹性伸缩"><a href="#4、弹性伸缩" class="headerlink" title="4、弹性伸缩"></a>4、弹性伸缩</h4><p>可以随时随地动态地对数据节点进行扩容和缩容</p>
<h4 id="5、多数据副本"><a href="#5、多数据副本" class="headerlink" title="5、多数据副本"></a>5、多数据副本</h4><p>自动将数据以强一致、高性能的方式复制至跨机多副本</p>
<h4 id="6、HTAP"><a href="#6、HTAP" class="headerlink" title="6、HTAP"></a>6、HTAP</h4><p>当我们先将数据以行存、列存的方式进行存储的时候，我们完全可以通过同样的一条sql去访问OLTP事务型和OLAP分析型查询。<br><strong>实现方案</strong></p>
<ul>
<li>newsql（进取型）<br>国内的tidb。以更高的性能换取稳定性的缺失和运维经验的不足。newsql是属于重新设计的数据库的存储结构。需要经过时间的积累去验证。</li>
<li>中间件（稳定型）<br>牺牲部分性能以保证稳定性和运维经验的复用。存储仍然用的mysql或oracle，添加了中间件性能一定会有所下降，因为中间肯定会做一些事情。</li>
</ul>
<p><strong>newSQL的分类</strong></p>
<ul>
<li>新架构</li>
<li>透明化分片中间件</li>
<li>云数据库</li>
</ul>
<h3 id="二、实现与规划（4-x）"><a href="#二、实现与规划（4-x）" class="headerlink" title="二、实现与规划（4.x）"></a>二、实现与规划（4.x）</h3><p>ShardingSphere由两个组件构成：<code>Sharding-JDBC</code>和<code>Sharding-Proxy</code></p>
<ul>
<li>Sharding-JDBC是和业务的应用端部署在一起的</li>
<li>Sharding-Proxy是一个独立的进程，是中心化的应用，是无状态的，跨语言的。dba可以把它当数据库去用。一般在管理端用。</li>
<li>注册中心里面包含了相关配置，所以proxy和jdbc是共享的。<br><img src="/2020/08/11/ShardingSphere/1.jpg" alt="项目结构"><h4 id="1、数据分片"><a href="#1、数据分片" class="headerlink" title="1、数据分片"></a>1、数据分片</h4><img src="/2020/08/11/ShardingSphere/5.jpg" alt="项目结构"><h4 id="2、分布式事务"><a href="#2、分布式事务" class="headerlink" title="2、分布式事务"></a>2、分布式事务</h4>事务分为两种类型：</li>
<li><code>强一致性事务</code>：XA，谷歌的BigTable论文：Percolator等两阶段方式的分布式事务（刚性事务）。<br>最大的问题就是：并发性能急剧下降，可用性急剧下降，提交阶段失败阶段</li>
<li><code>柔性事务</code>：base，一阶段事务。强调最终一致性，不要求强一致性<br>问题：一致性和隔离性，业务侵入。</li>
</ul>
<p><code>sharding-sphere</code>提供了一个很好的事务管理:<code>sharding-transaction</code><br><img src="/2020/08/11/ShardingSphere/2.jpg" alt="项目结构"><br>参考：<a href="https://blog.csdn.net/ShardingSphere/article/details/99317423">https://blog.csdn.net/ShardingSphere/article/details/99317423</a><br>分布式事务解决方案：<code>JDTX</code><br><img src="/2020/08/11/ShardingSphere/3.jpg" alt="项目结构"><br><code>MVCC引擎</code>：JDTX的核心，基于内存的，比数据库要快。MVCC只会存当前事务的热数据<br><code>WAL模块</code>：当事务已经进入了WAL模块之后，事务已经算是结束了，不用真正落到数据库去<br>JDTX设计亮点:<br><img src="/2020/08/11/ShardingSphere/4.jpg" alt="项目结构"><br>参考：<a href="https://wenku.baidu.com/view/218d5d5a824d2b160b4e767f5acfa1c7aa0082fa.html">https://wenku.baidu.com/view/218d5d5a824d2b160b4e767f5acfa1c7aa0082fa.html</a><br>JDTX自研了一个MVCC的引擎，不管是mysql还是其他，都是用的mvcc去做的事务的隔离级别。</p>
<blockquote>
<p>事务有两种实现方式：<br>    一种是多版本快照（MVCC）<br>    另一种就是加锁</p>
</blockquote>
<p>mysql是加锁+MVCC</p>
<h4 id="3、弹性伸缩"><a href="#3、弹性伸缩" class="headerlink" title="3、弹性伸缩"></a>3、弹性伸缩</h4><p>分为两部分：</p>
<ul>
<li><code>迁移引擎</code>:把它当成了mysql的从库，迁移的时候有全量数据的迁移和增量数据的迁移，全量数据有一个历史数据迁移作业，它会把当前这一个位点的所有数据通过分布式调度迁移到新的库去，我们的业务数据还是写到旧库中去。通过订阅binlog的当时去把binlog伪装成一个mysql的从    库，通过ShardingScaling迁移到新库去。把应用切到新的数据库的访问去。</li>
<li><code>调度引擎</code>（用了elasticJob）</li>
</ul>
<h4 id="4、分布式治理"><a href="#4、分布式治理" class="headerlink" title="4、分布式治理"></a>4、分布式治理</h4><h6 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h6><ul>
<li>配置动态化</li>
<li>跨机房高可用</li>
<li>熔断、禁用、失效转移<h6 id="数据治理"><a href="#数据治理" class="headerlink" title="数据治理"></a>数据治理</h6></li>
<li>数据权限管理</li>
<li>数据脱敏</li>
<li>全链路数据压测</li>
<li>sql审核</li>
<li>sql防火墙<h6 id="可观察性"><a href="#可观察性" class="headerlink" title="可观察性"></a>可观察性</h6></li>
<li>APM统计</li>
<li>调用链</li>
<li>应用拓扑图</li>
<li>监控报警</li>
</ul>
<h3 id="三、开源与社区"><a href="#三、开源与社区" class="headerlink" title="三、开源与社区"></a>三、开源与社区</h3><h4 id="1、可插拔架构"><a href="#1、可插拔架构" class="headerlink" title="1、可插拔架构"></a>1、可插拔架构</h4><h4 id="2、易用性提升"><a href="#2、易用性提升" class="headerlink" title="2、易用性提升"></a>2、易用性提升</h4><h4 id="3、sql兼容度提升"><a href="#3、sql兼容度提升" class="headerlink" title="3、sql兼容度提升"></a>3、sql兼容度提升</h4><h4 id="4、多数据副本"><a href="#4、多数据副本" class="headerlink" title="4、多数据副本"></a>4、多数据副本</h4><h4 id="5、云原生"><a href="#5、云原生" class="headerlink" title="5、云原生"></a>5、云原生</h4><h4 id="6、多元数据融合平台"><a href="#6、多元数据融合平台" class="headerlink" title="6、多元数据融合平台"></a>6、多元数据融合平台</h4>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>ShardingSphere</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring初探</title>
    <url>/2020/11/22/Spring%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<a id="more"></a>
<h2 id="一、Spring发展的几个大致阶段"><a href="#一、Spring发展的几个大致阶段" class="headerlink" title="一、Spring发展的几个大致阶段"></a>一、Spring发展的几个大致阶段</h2><p>SpringCore最初应用的是工厂模式（DI）和代理模式（AOP），用来解耦应用组件；SpringMVC用来解决web应用的开发；又发现每次开发都需要写很多配置样板代码，为了更方便地整合引入了SpringBoot一些列stater；SringCloud的意义在于推动了微服务架构的落地。</p>
<h2 id="二、IOC-Inversion-of-Control-控制反转"><a href="#二、IOC-Inversion-of-Control-控制反转" class="headerlink" title="二、IOC(Inversion of Control):控制反转"></a>二、IOC(Inversion of Control):控制反转</h2><p>不是一种技术，而是一种思想，是SpringCore最核心的部分</p>
<ul>
<li>IOC的优势<br>  1.避免在各处使用new来创建类，并且可以做到统一维护<br>  2.创建实例的时候不需要了解其中的细节</li>
<li>IOC支持的功能<br>  <strong>依赖注入</strong><br>  依赖检查<br>  <strong>自动装配</strong><br>  支持集合<br>  指定初始化方法和销毁方法<br>  支持回调方法（有侵入方式，需谨慎使用）</li>
</ul>
<h3 id="1-IOC的实现方式"><a href="#1-IOC的实现方式" class="headerlink" title="1. IOC的实现方式"></a>1. IOC的实现方式</h3><p><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/ioc%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.png" alt="IOC的实现方式"></p>
<ul>
<li><p>依赖注入（Dependency Injection），是当前IOC的主流实现<br>  Setter方法注入<br>  接口注入<br>  注解注入<br>  构造器注入</p>
</li>
<li><p>依赖查找（Dependency Lookup）<br>  DL相对于DI而言是一种更为主动的方法，他会在需要的时候通过调用框架来获取对象，获取时需要提供配置文件相关的路径、key等信息来确定获取对象的状态。DL需要用户自己去使用API进行查找资源和组装对象，对业务有侵入性，已经被抛弃。</p>
</li>
</ul>
<h3 id="2-依赖倒置原则："><a href="#2-依赖倒置原则：" class="headerlink" title="2. 依赖倒置原则："></a>2. 依赖倒置原则：</h3><ul>
<li>是一种思想，高层模块不应该依赖于底层模块，两者都应该依赖于其抽象        </li>
<li>由于依赖倒置原则思想，才有了IOC的思路，而DI是实现IOC的方法</li>
</ul>
<p><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/IOC.png" alt="IOC的实现方式"></p>
<h3 id="3-容器（控制反转容器）"><a href="#3-容器（控制反转容器）" class="headerlink" title="3.容器（控制反转容器）"></a>3.容器（控制反转容器）</h3><p><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/bean%E6%B3%A8%E5%86%8C.png" alt="IOC的实现方式"></p>
<p>Spring框架基于IOC提出了容器的概念。容器管理着bean的生命周期，控制着bean的依赖注入。</p>
<p>Spring启动时去读取应用程序提供的bean配置信息，并在Spring容器中生成一份响应的bean配置注册表，然后根据这张注册表去实例化bean，装配好bean之间的依赖关系，为上层提供准备就绪的运行环境。Spring提供一个配置文件描述bean还有bean之间的依赖关系，利用java语言的反射功能实例化bean并建立bean之间的依赖关系。</p>
<p><strong>在Spring容器中，默认的情况下bean都是以单例的形式存在的</strong></p>
<h4 id="3-1-SpringIOC容器的核心接口"><a href="#3-1-SpringIOC容器的核心接口" class="headerlink" title="3.1 SpringIOC容器的核心接口"></a>3.1 SpringIOC容器的核心接口</h4><p><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/beanFactory.png" alt="beanFactory"></p>
<ul>
<li><p>BeanFactory<br>  最核心的接口<br>  提供了IOC的配置机制<br>  包含了bean的各种定义，便于实例化Bean<br>  在对象实例化之时建立bean之间的依赖关系<br>  包含了bean生命周期的控制</p>
</li>
<li><p>ApplicationContext<br>  BeanFactory的子接口之一，能够管理、装配bean<br>  继承了ResourcePatternResolver接口，能够加载资源文件<br>  继承了MessageSource接口，能够实现国际化能功能<br>  继承了ApplicationEventPublisher接口，能够注册监听器，实现监听机制</p>
</li>
<li><p>两者比较<br>  BeanFactory是Spring框架的基础设施，面向Spring<br>  ApplicationContext面向使用Spring框架的开发者</p>
</li>
</ul>
<h4 id="3-2-几个重要的类和方法"><a href="#3-2-几个重要的类和方法" class="headerlink" title="3.2 几个重要的类和方法"></a>3.2 几个重要的类和方法</h4><ul>
<li><p>BeanDefinition<br>  主要用来描述bean的定义，Spring容器在启动的时候会将xml或者注解中的bean的定义解析成Spring内部的BeanDefinition</p>
</li>
<li><p>BeanDefinitionRegistry<br>  提供了向IOC容器注册BeanDefinition对象的方法。<br>  Spring将bean的定义解析成BeanDefinition之后会通过BeanDefinitionRegistry以beanName为key，BeanDefinition为value存储到BeanDefinitionMap(ConcurrentHashmap)中，同时还将beanName存储到beanDefinitionNames的ArrayList中去，以便后续bean的实例化。</p>
</li>
<li><p>refresh方法<br>  主要为IOC容器以及Bean的生命周期管理提供条件<br>  用于刷新Spring整个上下文信息，定义Spring上下文加载流程</p>
</li>
<li><p>getBean方法<br>  getBean用来加载bean，主要用于查找或实例化bean<br>  实现主要是通过AbstractBeanFactory方法去实现的，所有的getBean方法最终都会去调用doGetBean方法<br>  大致逻辑：</p>
<blockquote>
<p>首先会通过调用transformedBeanName转换beanName<br>  之后会尝试从缓存中加载实例，或者从工厂中返回实例<br>  实例化bean<br>  检测parentBeanFactory<br>  初始化依赖的bean<br>  创建bean<br>  在检查bean的类型符合要求之后进行返回</p>
</blockquote>
</li>
</ul>
<h3 id="3-3-Spring-Bean的作用域（5个）"><a href="#3-3-Spring-Bean的作用域（5个）" class="headerlink" title="3.3 Spring Bean的作用域（5个）"></a>3.3 Spring Bean的作用域（5个）</h3><ul>
<li>singleton：Spring的默认作用域，容器里拥有唯一的bean实例</li>
<li>prototype：针对每个getBean请求，容器都会创建一个bean实例</li>
<li>request：会为每个http请求创建一个单独的bean实例</li>
<li>session：会为每个session创建一个bean实例</li>
<li>globalSession：会为每个全局的HttpSession创建一个bean实例，该作用域仅对Portlet有效</li>
</ul>
<h3 id="3-4-Springbean的生命周期"><a href="#3-4-Springbean的生命周期" class="headerlink" title="3.4 Springbean的生命周期"></a>3.4 Springbean的生命周期</h3><ul>
<li>创建过程<br><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="Springbean生命周期-创建"></li>
<li>销毁过程<br><img src="/2020/11/22/Spring%E5%88%9D%E6%8E%A2/%E9%94%80%E6%AF%81%E7%9A%84%E7%94%9F%E5%91%BD.png" alt="Springbean生命周期-销毁"></li>
</ul>
<h2 id="三、-AOP面向切面编程"><a href="#三、-AOP面向切面编程" class="headerlink" title="三、 AOP面向切面编程"></a>三、 AOP面向切面编程</h2><h3 id="1-产生的背景"><a href="#1-产生的背景" class="headerlink" title="1.产生的背景"></a>1.产生的背景</h3><p>软件工程有一个基本编码原则：关注点分离（不同的问题交给不同的部分去解决，每部分专注于解决自己的问题）。AOP正是此种技术的实现，我们的代码主要就是实现某种特定的功能实现逻辑，但是我们往往不能专注于业务逻辑。比如我们写业务逻辑代码的同时还要写事务管理、缓存、日志等通用化的功能，而且这些通用化的功能还要与业务功能混写在一起，就很痛苦。为了将业务功能的专注点和通用功能的专注点分离开来，就出现了AOP的技术，这些通用化功能的代码实现，对应的就是所谓的切面（Aspect）。业务功能代码合切面代码分开之后，架构将变得高内聚低耦合。为了确保功能的完整性，切面最终需要被合并到业务中（织入Weave）。而对于业务代码，我需要在那些地方加入这些通用功能的代码，就是切点。</p>
<h3 id="2-织入的三种方式"><a href="#2-织入的三种方式" class="headerlink" title="2.织入的三种方式"></a>2.织入的三种方式</h3><ul>
<li>编译时织入：在代码编译时，把切面代码融合进来，生成完整功能的Java字节码，需要特殊的Java编辑器，如AspectJ</li>
<li>类加载时织入：在字节码加载的时候，把切面的代码融合进来，需要特殊的Java编辑器，如AspectJ和AspectWorkz</li>
<li>运行时织入：Spring采用的方式，通过动态代理的方式，调用切面代码增强业务功能，实现简单</li>
</ul>
<h3 id="3-主要名词概念"><a href="#3-主要名词概念" class="headerlink" title="3.主要名词概念"></a>3.主要名词概念</h3><ul>
<li><strong>Aspect：</strong> 通用功能的代码实现</li>
<li><strong>Target：</strong> 被织入Aspect的对象</li>
<li><strong>JoinPoint：</strong> 可以作为切入点的机会，所有方法都都可以作为切入点</li>
<li><strong>Pointcut：</strong> Aspect实际被应用在的Join Point，支持正则</li>
<li><strong>Advice(通知)：</strong> 类里的方法以及这个方法如何织入到目标方法的方式</li>
<li><strong>Weaving(织入):</strong> AOP的实现过程。即将切面应用到实际对象，从而创建一个新的代理对象的过程。对于Spring来说，就是初始化context中的对象时，完成织入操作。</li>
</ul>
<h3 id="4-Advice的类型（通知的5种类型）"><a href="#4-Advice的类型（通知的5种类型）" class="headerlink" title="4.Advice的类型（通知的5种类型）"></a>4.Advice的类型（通知的5种类型）</h3><ul>
<li>前置通知（Before）</li>
<li>后置通知（AfterReturning）</li>
<li>异常通知（AfterThrowing）</li>
<li>最终通知（After）</li>
<li>环绕通知（Around）</li>
</ul>
<h3 id="5-Spring提供了两种方式来生成代理对象"><a href="#5-Spring提供了两种方式来生成代理对象" class="headerlink" title="5.Spring提供了两种方式来生成代理对象"></a>5.Spring提供了两种方式来生成代理对象</h3><ul>
<li>JdkProxy<br>  核心：通过Java的内部反射机制来接收被代理的类，并且要求被代理的类必需实现InvocationHandler接口<br>  核心就是和InvocationHandler接口和Proxy类<br>  反射机制在生成类的过程中比较高效</li>
<li>cglib<br>  以继承的方式动态地生成目标类的代理，它是通过修改字节码来实现代理的。（如果某个类是final修饰的，则不能用此种方式）<br>  借助ASM实现（ASM是一种可以操作字节码的框架）<br>  ASM在生成类之后的执行过程中比较高效</li>
</ul>
<p>具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定</p>
<p>默认的策略：<em>如果目标类是接口，则用JdkProxy来实现，否则用后者</em></p>
<h2 id="四、代理模式：接口-真实实现类-代理类"><a href="#四、代理模式：接口-真实实现类-代理类" class="headerlink" title="四、代理模式：接口+真实实现类+代理类"></a>四、代理模式：接口+真实实现类+代理类</h2><ul>
<li>其中，真实实现类和代理类都是需要实现接口的，实例化的时候要使用代理类。</li>
<li>SpringAOP需要做的是生成一个代理类来替换掉真实实现类以对外提供服务</li>
<li>Spring里的代理模式的实现<br>  对Spring来讲，真实实现类的逻辑包含在了getBean方法里面<br>  getBean方法返回的实际上是Proxy的实例<br>  Proxy实例是Spring采用Jdk proxy或CGLIB动态生成的</li>
</ul>
<h2 id="五、Spring事务的相关考点"><a href="#五、Spring事务的相关考点" class="headerlink" title="五、Spring事务的相关考点"></a>五、Spring事务的相关考点</h2><p>ACID<br>隔离级别<br>事务传播</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>gitFlow工作流</title>
    <url>/2020/07/01/gitFlow%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p><img src="https://upload-images.jianshu.io/upload_images/15200008-742c050e94084a3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git工作流"><br>Gitflow工作流通过为功能开发、发布准备和维护（bug修复）分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。<br><img src="https://upload-images.jianshu.io/upload_images/15200008-5dcea875b5e3537f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git工作流"><br>虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p>
<a id="more"></a>
<ul>
<li>如何开始一个Feature的开发，而不影响别的Feature？</li>
<li>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？<br>哪些分支已经合并回了主干？</li>
<li>如何进行Release的管理？开始一个Release的时候如何冻结Feature, 如何在Prepare Release的时候，开发人员可以继续开发新的功能？</li>
<li>线上代码出Bug了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个Release?</li>
<li>大部分开发人员现在使用Git就只是用三个甚至两个分支，一个是Master, 一个是Develop, 还有一个是基于Develop打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个Release, 但是人员一多，而且项目周期一长就会出现各种问题。</li>
</ul>
<h1 id="一、Git-Flow常用的分支"><a href="#一、Git-Flow常用的分支" class="headerlink" title="一、Git Flow常用的分支"></a>一、Git Flow常用的分支</h1><p><strong>Master 分支</strong><br>这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改<br><strong>Dev 分支</strong><br>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支<br><strong>Feature 分支</strong><br>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release<br><strong>Release分支</strong><br>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支<br><strong>Hotfix分支</strong><br>当我们在Master发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Dev分支，所以Hotfix的改动会进入下一个Release</p>
<h1 id="二、Git-Flow如何工作"><a href="#二、Git-Flow如何工作" class="headerlink" title="二、Git Flow如何工作"></a>二、Git Flow如何工作</h1><h2 id="1-Master分支"><a href="#1-Master分支" class="headerlink" title="1. Master分支"></a>1. Master分支</h2><p>所有在Master分支上的Commit应该Tag<br><img src="https://upload-images.jianshu.io/upload_images/15200008-58d45fc3dd13f764.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="master分支"></p>
<h2 id="2-Feature-分支"><a href="#2-Feature-分支" class="headerlink" title="2. Feature 分支"></a>2. Feature 分支</h2><p>Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-80e1a93d016f969a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Feature分支"></p>
<p>每个新功能位于一个自己的分支，这样可以push到中央仓库以备份和协作。 但功能分支不是从master分支上拉出新分支，而是使用develop分支作为父分支。当新功能完成时，合并回develop分支。 新功能提交应该从不直接与master分支交互。</p>
<h2 id="3-Release分支"><a href="#3-Release分支" class="headerlink" title="3. Release分支"></a>3. Release分支</h2><p>Release分支基于Develop分支创建，打完Release分之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支)</p>
<p>发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。</p>
<p>一旦develop分支上有了做一次发布（或者说快到了既定的发布日）的足够功能，就从develop分支上checkout一个发布分支。 新建的分支用于开始发布循环，所以从这个时间点开始之后新的功能不能再加到这个分支上—— 这个分支只应该做Bug修复、文档生成和其它面向发布任务。 一旦对外发布的工作都完成了，发布分支合并到master分支并分配一个版本号打好Tag。 另外，这些从新建发布分支以来的做的修改要合并回develop分支。</p>
<p>使用一个用于发布准备的专门分支，使得一个团队可以在完善当前的发布版本的同时，另一个团队可以继续开发下个版本的功能。 这也打造定义良好的开发阶段（比如，可以很轻松地说，『这周我们要做准备发布版本4.0』，并且在仓库的目录结构中可以实际看到）。<br><img src="https://upload-images.jianshu.io/upload_images/15200008-15c5b67abe8ead6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="release分支"></p>
<h2 id="4-Hotfix分支"><a href="#4-Hotfix分支" class="headerlink" title="4. Hotfix分支"></a>4. Hotfix分支</h2><p>hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag<br><img src="https://upload-images.jianshu.io/upload_images/15200008-c4a6e09f61baf2dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hotfix分支"><br>该分支用于生成快速给产品发布版本（production releases）打补丁，这是唯一可以直接从master分支fork出来的分支。 修复完成，修改应该马上合并回master分支和develop分支（当前的发布分支），master分支应该用新的版本号打好Tag。</p>
<p>为Bug修复使用专门分支，让团队可以处理掉问题而不用打断其它工作或是等待下一个发布循环。 你可以把维护分支想成是一个直接在master分支上处理的临时发布。</p>
<h1 id="三、如何进行测试"><a href="#三、如何进行测试" class="headerlink" title="三、如何进行测试"></a>三、如何进行测试</h1><p><strong>Testing On Feature Branch</strong><br>开发人员在功能分支开发完成后，提测给对应测试人员，标明其对应的功能分支，测试人员发现bug，开发人员仍在该分支修改bug，修改完交给测试人员测试，当测试通过后，开发人员发起一个pull request合并会develop分支，然后从develop检出release，测试人员在预发环境部署并快速回归测试，发现bug，开发人员直接在release分支进行修正，测试通过后，将release合回develop并合并到master准备上线。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2020/07/13/git%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
基本操作就不说了，这里详细介绍其他中高级操作
##### 1、查看日志
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
这个命令对于提交少的项目比较友好，但是对于提交很多的项目，会输出一大长串，很不方便，于是有一个比较简便的命令：
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span></span><br></pre></td></tr></table></figure>
输出：
![git log](https://upload-images.jianshu.io/upload_images/15200008-45ddb710fbaa4feb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<h5 id="2、撤销修改"><a href="#2、撤销修改" class="headerlink" title="2、撤销修改"></a>2、撤销修改</h5><p><strong>背景</strong><br>在一个文件中添加了一点代码，现在我<code>git add .</code>了但是没提交，现在我想撤销我修改的东西</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-ef3f18e06870f830.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="想要撤销修改"><br><strong>解决方案</strong><br>两个命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git reset HEAD  src<span class="regexp">/main/</span>java<span class="regexp">/com/</span>tinner<span class="regexp">/demo03/</span>constant/RedisContant.java</span><br><span class="line">git checkout --  src<span class="regexp">/main/</span>java<span class="regexp">/com/</span>tinner<span class="regexp">/demo03/</span>constant/RedisContant.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>效果</strong><br><img src="https://upload-images.jianshu.io/upload_images/15200008-4f6a48f749025f40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"></p>
<h5 id="3、创建分支"><a href="#3、创建分支" class="headerlink" title="3、创建分支"></a>3、创建分支</h5><p>两个命令：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">git checkout -b dev</span><br><span class="line">git <span class="keyword">switch</span> -<span class="keyword">c</span> dev</span><br></pre></td></tr></table></figure>
<h5 id="4、删除分支"><a href="#4、删除分支" class="headerlink" title="4、删除分支"></a>4、删除分支</h5><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;<span class="built_in">name</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h5 id="5、合并代码"><a href="#5、合并代码" class="headerlink" title="5、合并代码"></a>5、合并代码</h5><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> merge --<span class="literal">no</span>-ff -m <span class="string">&quot;注释。。。。&quot;</span> &lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<h5 id="6、stash"><a href="#6、stash" class="headerlink" title="6、stash"></a>6、stash</h5><p><strong>背景</strong><br>在一个新的需求开发过程中，我在dev分支开发了一些东西，但是并没有提交我也不想提交，这个时候来了一个bug，我必须将bug改完才能进行dev的开发，那么这个时候就需要用到<code>git stash</code>命令<br><strong>步骤</strong></p>
<ul>
<li>首先，我看看git仓库中的状态<br><img src="https://upload-images.jianshu.io/upload_images/15200008-a972ff6bedf30c71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git状态"><br>可以看到，在dev分支，我创建了一个文件，修改了一个文件。</li>
<li>然后，使用<code>git stash</code>命令，之后再来查看状态：<br><img src="https://upload-images.jianshu.io/upload_images/15200008-8e9e83fcd28a6c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="储藏代码"><br>此时工作区是干净的。然后我切换到master分支，创建一个issue分支，解决bug，合并到master，发版，之后再切换到dev分支，可以看到我的工作区还是干净的，那么之前的代码跑哪去了？</li>
<li>使用<code>git stash list</code>可以查看储藏的代码列表<br><img src="https://upload-images.jianshu.io/upload_images/15200008-3b3f6b8f63f04ea9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git stash list"></li>
<li>现在我们需要恢复之前的代码，有两个命令可以参考：<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git stash <span class="built_in">apply</span></span><br><span class="line">git stash <span class="built_in">pop</span></span><br></pre></td></tr></table></figure>
<code>git stash apply</code>命令恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；<br><img src="https://upload-images.jianshu.io/upload_images/15200008-b8880068ad06e4c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git stash apply"></li>
</ul>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-41d742ccc7ace756.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git stash pop"></p>
<ul>
<li>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令:<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">git stash apply <span class="symbol">stash@</span>&#123;<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>扩展</strong><br>我们知道，master的bug修复之后，在现在的dev代码相关的bug并没有修复，所以，这个bug其实在当前dev分支上也存在。<br><em>如何快速修复？</em><br>同样的bug，要在dev上修复，我们只需要把<code>修复issuebug</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>修复issuebug</code>这个提交所做的修改，并不是把整个master分支<code>merge</code>过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">git cherry-pick <span class="tag">&lt;<span class="name">版本号</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-30ceb22e3d0b5e90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修复bug"><br><img src="https://upload-images.jianshu.io/upload_images/15200008-81c651ad31eed27d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<h3 id="几个命令的区别"><a href="#几个命令的区别" class="headerlink" title="几个命令的区别"></a>几个命令的区别</h3><h5 id="merge和rebase的区别"><a href="#merge和rebase的区别" class="headerlink" title="merge和rebase的区别"></a>merge和rebase的区别</h5><p>merge和rebase都是用来合并分支的。</p>
<ul>
<li>采用merge和rebase后，git log的区别，<strong>merge命令不会保留merge的分支的commit</strong>：</li>
</ul>
<p><img src="//upload-images.jianshu.io/upload_images/6081878-f7c90a58674a5584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/895" alt="merge和rebase"></p>
<ul>
<li>处理冲突的方式：<br><code>（一股脑）</code>使用merge命令合并分支，解决完冲突，执行git add .和git commit -m ‘fix conflict’。这个时候会产生一个commit。<br><code>（交互式）</code>使用rebase命令合并分支，解决完冲突，执行git add .和git rebase –continue，不会产生额外的commit。这样的好处是”干净”，分支上不会有无意义的解决分支的commit；坏处：如果合并的分支中存在多个commit，需要重复处理多次冲突。<h5 id="git-pull和git-pull-–rebase"><a href="#git-pull和git-pull-–rebase" class="headerlink" title="git pull和git pull –rebase"></a>git pull和git pull –rebase</h5><code>git pull</code>做了两个操作分别是<code>获取</code>和<code>合并</code>。所以加了<code>rebase</code>就是以<code>rebase</code>的方式进行合并分支，默认为<code>merge</code>。<h5 id="git-merge-和-git-merge-–no-ff的区别"><a href="#git-merge-和-git-merge-–no-ff的区别" class="headerlink" title="git merge 和 git merge –no-ff的区别"></a>git merge 和 git merge –no-ff的区别</h5><code>git merge –no-ff</code> 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。<br><code>git merge</code> 则不会显示 feature，只保留单条分支记录。<br><img src="https://upload-images.jianshu.io/upload_images/15200008-f7ea47cfb59ac349.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="git merge 和 git merge --no-ff的区别"></li>
</ul>
<h3 id="tag相关"><a href="#tag相关" class="headerlink" title="tag相关"></a>tag相关</h3><p>在当前分支的最新commit上打tag</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在f52c633版本的提交上打tag</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> tag v<span class="number">0</span>.<span class="number">9</span> f<span class="number">52</span>c<span class="number">633</span></span><br></pre></td></tr></table></figure>
<p>查看所有的tag</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span></span><br></pre></td></tr></table></figure>
<p><em>注意，标签不是按时间顺序列出，而是按字母排序的</em></p>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> tag -a v<span class="number">0</span>.<span class="number">1</span> -m <span class="string">&quot;文字说明&quot;</span> <span class="number">1094</span>adb</span><br></pre></td></tr></table></figure>
<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字<br>提交v1.0标签</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> push origin v<span class="number">1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>提交所有的标签</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --tags</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-57c8edc0e40ec346.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标签"><br><img src="https://upload-images.jianshu.io/upload_images/15200008-5e47e69158aed78a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tag"><br>从本地删除tag：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">tag</span> <span class="title">-d</span> v0.<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>删除远程tag：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">git push origin <span class="symbol">:refs/tags/v0</span>.<span class="number">9</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/15200008-45ac44d2f7a193ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tag删除"></p>
<h3 id="Git-HEAD-与HEAD-的关系"><a href="#Git-HEAD-与HEAD-的关系" class="headerlink" title="Git HEAD^与HEAD~的关系"></a>Git HEAD^与HEAD~的关系</h3><p>一张图：<br><img src="https://upload-images.jianshu.io/upload_images/15200008-57f1b8f25ab5d35a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git HEAD^与HEAD~的关系"></p>
<h3 id="Git-reset后面跟的参数"><a href="#Git-reset后面跟的参数" class="headerlink" title="Git reset后面跟的参数"></a>Git reset后面跟的参数</h3><p>比如我在我的本地目录下面新建了一个文件c.txt，add到了我的暂存区（缓冲区），同时也commit提交到了本地仓库<br>默认：<code>git reset</code> = <code>git reset --mixed</code>，这个命令会跳转到指定版本、<strong>缓存区的文件还原、但是工作区（本地目录）下的文件不会还原</strong><br><code>git reset --hard</code>这个命令会跳转到指定版本、<strong>缓存区的文件还原、工作区（本地目录）下的文件也会被还原</strong><br><code>git reset --soft</code>这个命令会跳转到指定版本、<strong>缓存区的文件不会被还原、而且工作区（本地目录）下的文件也不会还原</strong></p>
<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p><code>git revert</code>会产生一个commit，撤销某次操作，此次操作之前和之后的commit和history都会被保留，并且会把这次撤销作为一次最新的提交。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>mongo分片集</title>
    <url>/2020/12/18/mongo%E5%88%86%E7%89%87%E9%9B%86/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<h2 id="分片集的架构说明"><a href="#分片集的架构说明" class="headerlink" title="分片集的架构说明"></a>分片集的架构说明</h2><p><img src="/2020/12/18/mongo%E5%88%86%E7%89%87%E9%9B%86/sharding.png" alt="分片集"></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">解释</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shard</td>
<td align="center">分片集存储实例</td>
<td align="left">用于存储实际的数据块，实际生产环境中一个<code>shard server</code>角色可由几台机器组个一个<code>replica set</code>承担，防止单机节点故障</td>
</tr>
<tr>
<td align="center">config server</td>
<td align="center">分片集配置器</td>
<td align="left">存储了整个ClusterMetadata，其中包括 chunk信息</td>
</tr>
<tr>
<td align="center">mongos</td>
<td align="center">分片集路由器</td>
<td align="left">客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用</td>
</tr>
</tbody></table>
<h2 id="为什么要使用分片集？"><a href="#为什么要使用分片集？" class="headerlink" title="为什么要使用分片集？"></a>为什么要使用分片集？</h2><p>一般有如下几个原因：</p>
<ul>
<li>数据容量日益增大，副本集维护吃力</li>
<li>增加集群的吞吐量</li>
<li>单库数据超过10TB</li>
<li>地理容灾</li>
</ul>
<h2 id="使用分片集的优劣势"><a href="#使用分片集的优劣势" class="headerlink" title="使用分片集的优劣势"></a>使用分片集的优劣势</h2><table>
<thead>
<tr>
<th align="left">优势</th>
<th align="left">劣势</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.海量数据存储有方案 <br>2.增加数据库的访问并发和集群的iops <br>3.跨机房灾备<br> 4.单库数据量有限<br></td>
<td align="left">1.成本高昂，一个高可用的分片集至少需要3台configServer，2个shardServer，每个shardServer都是为副本集，至少2个mongos组成。<br>2.分片集本身结构复杂，运维复杂。</td>
</tr>
</tbody></table>
<h2 id="1-如何进行分片？"><a href="#1-如何进行分片？" class="headerlink" title="1.如何进行分片？"></a>1.如何进行分片？</h2><h3 id="1-1-分片的基本标准"><a href="#1-1-分片的基本标准" class="headerlink" title="1.1 分片的基本标准"></a>1.1 分片的基本标准</h3><ul>
<li>1.数据角度:数据量不超过3TB，尽可能保持在2TB一个分片</li>
<li>2.索引角度:常用的索引必须能容纳进系统内存之中</li>
</ul>
<h3 id="1-2-分片的预估标准"><a href="#1-2-分片的预估标准" class="headerlink" title="1.2 分片的预估标准"></a>1.2 分片的预估标准</h3><p>A=(所需存储量/单服务可挂载容量)<br>B=(工作集大小/服务器内存<em>MongoDB可用内存率)<br>C=(并发量总数/单服务器</em>损耗系数)<br><strong>分片的数量=max(A,B,C)</strong><br>举个例子：<br>A=30TB/2TB=15<br>B=1TB/(64G<em>0.6)=27<br>C=200000/(8000</em>0.7)=36<br>分片数量=36</p>
<h3 id="1-3-分片的基本概念"><a href="#1-3-分片的基本概念" class="headerlink" title="1.3 分片的基本概念"></a>1.3 分片的基本概念</h3><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">分片键 shardkey</td>
<td align="left">文档中的一个字段</td>
</tr>
<tr>
<td align="left">文档doc</td>
<td align="left">包含分片键的一行数据</td>
</tr>
<tr>
<td align="left">块chunk</td>
<td align="left">包含N个文档</td>
</tr>
<tr>
<td align="left">分片shard</td>
<td align="left">包含N个chunk</td>
</tr>
<tr>
<td align="left">分片集群Cluster</td>
<td align="left">包含N个分片shard</td>
</tr>
</tbody></table>
<h3 id="1-4-选择合适的分片键"><a href="#1-4-选择合适的分片键" class="headerlink" title="1.4 选择合适的分片键"></a>1.4 选择合适的分片键</h3><h4 id="基于范围的分片"><a href="#基于范围的分片" class="headerlink" title="基于范围的分片"></a>基于范围的分片</h4><p>MongoDB按照片键的值的范围将数据拆分为不同的块（chunk），每个块包含了一段范围内的数据。</p>
<ul>
<li>优点： mongos可以快速定位请求需要的数据，并将请求转发到相应的Shard节点中。</li>
<li>缺点： 可能导致数据在Shard节点上分布不均衡，容易造成读写热点，且不具备写分散性。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>片键的值不是单调递增或单调递减、片键的值基数大且重复的频率低、需要范围查询等业务场景。</li>
</ul>
<h4 id="基于hash值的分片"><a href="#基于hash值的分片" class="headerlink" title="基于hash值的分片"></a>基于hash值的分片</h4><p>MongoDB计算单个字段的哈希值作为索引值，并以哈希值的范围将数据拆分为不同的块。</p>
<ul>
<li>优点：可以将数据更加均衡地分布在各Shard节点中，具备写分散性。</li>
<li>缺点：不适合进行范围查询，进行范围查询时，需要将读请求分发到所有的Shard节点。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>片键的值存在单调递增或递减、片键的值基数大且重复的频率低、需要写入的数据随机分发、数据读取随机性较大等业务场景。</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>在4.0之前片键一经设置，不可修改，不可删除。在4.2之后可以对分片完的Collection进行修改分片键</li>
<li>执行了数据分片操作后，均衡器会对满足条件的数据进行拆分，这将占用实例的资源，请在业务低峰期操作。</li>
</ul>
<h3 id="1-5-分片操作"><a href="#1-5-分片操作" class="headerlink" title="1.5 分片操作"></a>1.5 分片操作</h3><p>1&gt;确认使用的实例为分片集群（执行<code>sh.status()</code>）<br>2&gt;切换数据库（执行 <code>use 数据库名</code>&gt;<br>3&gt;允许此库进行分片(执行 sh.enableSharding(“数据库名”))<br>4&gt;创建或使用已有的collection<br>5&gt;对collection中已创建索引的字段进行分片</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sh</span>.shardCollection(<span class="string">&quot;数据库名.表名&quot;</span>,&#123;<span class="string">&quot;_id&quot;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>6.经过一段时间查看一下数据在每个节点的分布</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.stats</span>()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>mongo服务</title>
    <url>/2020/12/18/mongo%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文以MongoDB 4.0版本为准，介绍服务器端、客户端的关键技术，以及使用中的注意事项。</p>
<h2 id="服务器（Server）"><a href="#服务器（Server）" class="headerlink" title="服务器（Server）"></a>服务器（Server）</h2><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><h4 id="1-单机部署方式"><a href="#1-单机部署方式" class="headerlink" title="1.单机部署方式"></a>1.单机部署方式</h4><p>适用场景:开发、测试</p>
<a id="more"></a>

<h4 id="2-副本集部署方式"><a href="#2-副本集部署方式" class="headerlink" title="2.副本集部署方式"></a>2.副本集部署方式</h4><p>适用场景：数据的高可用性， 保证数据的安全性，可恢复性</p>
<p>特性：</p>
<ul>
<li>N个节点的集群</li>
<li>任何节点都可以作为主节点</li>
<li>所有写入操作都在主节点上</li>
<li>自动故障转移</li>
<li>自动恢复</li>
</ul>
<p><img src="/2020/12/18/mongo%E6%9C%8D%E5%8A%A1/replication.png" alt="副本集"></p>
<p><strong>原理：</strong></p>
<p>主节点记录在其上的所有操作<code>oplog</code>，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<h4 id="3-分片集部署方式"><a href="#3-分片集部署方式" class="headerlink" title="3.分片集部署方式"></a>3.分片集部署方式</h4><p>适用场景：高增长的大量数据</p>
<p>特性：</p>
<ul>
<li>包含副本集的特点</li>
<li>支持数据分片存储</li>
<li>一般来说每个shard都有自己的副本集</li>
</ul>
<p><img src="/2020/12/18/mongo%E6%9C%8D%E5%8A%A1/sharding.png" alt="分片集"></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">解释</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shard</td>
<td align="center">分片集存储实例</td>
<td align="left">用于存储实际的数据块，实际生产环境中一个<code>shard server</code>角色可由几台机器组个一个<code>replica set</code>承担，防止单机节点故障</td>
</tr>
<tr>
<td align="center">config server</td>
<td align="center">分片集配置器</td>
<td align="left">存储了整个ClusterMetadata，其中包括 chunk信息</td>
</tr>
<tr>
<td align="center">mongos</td>
<td align="center">分片集路由器</td>
<td align="left">客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用</td>
</tr>
</tbody></table>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><h4 id="MMAP-3-0后有一个改进版本MMAPv1"><a href="#MMAP-3-0后有一个改进版本MMAPv1" class="headerlink" title="MMAP(3.0后有一个改进版本MMAPv1)"></a>MMAP(3.0后有一个改进版本MMAPv1)</h4><p>早期的mongoDB存储引擎，存在一些问题:</p>
<ul>
<li>锁粒度为库级别锁</li>
<li>耗费过多的磁盘空间</li>
<li>内存无限制，有多少用多少</li>
<li>集合和索引都混合存储在数据库文件中，即使删掉了某个集合或者索引，占用的磁盘空间也很难及时自动回收</li>
<li>文档按照写入顺序排列存储。如果文档更新后长度变长且原有存储位置后面没有足够的空间放下增长部分的数据，那么文档就要移动到文件中的其他位置。这种因更新导致的文档位置移动会严重降低写性能，因为一旦文档发生移动，集合中的所有索引都要同步修改文档新的存储位置</li>
</ul>
<h4 id="WiredTiger"><a href="#WiredTiger" class="headerlink" title="WiredTiger"></a>WiredTiger</h4><p>目前默认的存储引擎，有以下的特点：</p>
<ul>
<li>通过MVCC实现文档级别的并发控制，即文档级别锁。这在提升数据库读写性能的同时，大大提高了系统的并发处理能力。</li>
<li>支持对所有集合和索引进行Block压缩和前缀压缩（如果数据库启用了journal，journal文件一样会压缩）。</li>
<li>集合和索引分开文件存储</li>
<li>支持内存使用容量配置</li>
</ul>
<h4 id="RocksDB"><a href="#RocksDB" class="headerlink" title="RocksDB"></a>RocksDB</h4><p>插件式引擎引入的第三方引擎:</p>
<ul>
<li>K/V式的存储引擎</li>
<li>用自己的方式实现了大部分引擎的功能</li>
<li>集合的数据删除后，存储空间并不是立即回收，RocksDB 要通过后台压缩来逐步回收空间</li>
<li>mongorcks 对 oplog 空间的删除机制是在用户请求路径里进行的，这样可能导致写入的延迟上升，应像 wiredtiger 这样当 oplog 空间超出时，后台线程来回收。</li>
<li>RocksDB 缺乏批量日志提交的机制，无法将多次并发的写log进行合并，来提升效率。</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>支持普通索引、唯一索引、全文索引。</p>
<h2 id="客户端（client）"><a href="#客户端（client）" class="headerlink" title="客户端（client）"></a>客户端（client）</h2><h3 id="写策略（WriteConcern选项）"><a href="#写策略（WriteConcern选项）" class="headerlink" title="写策略（WriteConcern选项）"></a>写策略（WriteConcern选项）</h3><p>MongoDB支持的WriteConcern选项如下：</p>
<ul>
<li>w: 数据写入到number个节点才向用客户端确认</li>
<li>{w: 0} 对客户端的写入不需要发送任何确认，适用于性能要求高，但不关注正确性的场景</li>
<li>{w: 1} 默认的writeConcern，数据写入到Primary就向客户端发送确认</li>
<li>{w: “majority”} 数据写入到副本集大多数成员后向客户端发送确认，适用于对数据安全性要求比较高的场景，该选项会降低写入性能</li>
<li>{w:-1} 忽略网络错误</li>
<li>{w:2} 要求以写入到副本集的主服务器和一个备用服务器</li>
<li>j: 写入操作的journal持久化后才向客户端确认</li>
<li>默认为：{j: false}，如果要求Primary写入持久化了才向客户端确认，则指定该选项为true</li>
</ul>
<p><code>wtimeout</code>: 写入超时时间，仅w的值大于1时有效。</p>
<ul>
<li>当指定{w: }时，数据需要成功写入number个节点才算成功，如果写入过程中有节点故障，可能导致这个条件一直不能满足，从而一直不能向客户端发送确认结果，针对这种情况，客户端可设置<code>wtimeout</code>选项来指定超时时间，当写入过程持续超过该时间仍未结束，则认为写入失败。</li>
</ul>
<p><strong>{w: “majority”}解析</strong><br>{w: 1}、{j: true}等writeConcern选项很好理解，Primary等待条件满足发送确认；但{w: “majority”}则相对复杂些，需要确认数据成功写入到大多数节点才算成功，而MongoDB的复制是通过Secondary不断拉取oplog并重放来实现的，并不是Primary主动将写入同步给Secondary。</p>
<p><strong>那么Primary是如何确认数据已成功写入到大多数节点的？</strong></p>
<ul>
<li>Client向Primary发起请求，指定writeConcern为{w: “majority”}，Primary收到请求，本地写入并记录写请求到oplog，然后等待大多数节点都同步了这条/批oplog（Secondary应用完oplog会向主报告最新进度)。</li>
<li>Secondary拉取到Primary上新写入的oplog，本地重放并记录oplog。为了让Secondary能在第一时间内拉取到主上的oplog，find命令支持一个awaitData的选项，当find没有任何符合条件的文档时，并不立即返回，而是等待最多maxTimeMS(默认为2s)时间看是否有新的符合条件的数据，如果有就返回；所以当新写入oplog时，备立马能获取到新的oplog。</li>
<li>Secondary上有单独的线程，当oplog的最新时间戳发生更新时，就会向Primary发送replSetUpdatePosition命令更新自己的oplog时间戳。</li>
<li>当Primary发现有足够多的节点oplog时间戳已经满足条件了，向客户端发送确认。</li>
</ul>
<h4 id="writeConcern总结"><a href="#writeConcern总结" class="headerlink" title="writeConcern总结"></a>writeConcern总结</h4><p>1、write concern用于控制写入安全的级别，可以分为应答式写入以及非应答式写入<br>2、write concern是一个性能和数据强一致性的权衡，应根据业务场景进行设定<br>3、对于强一致性场景，建议w&gt;1或者等于majority，以及journal为true，否则w=0<br>4、在副本集的情形下，建议通过配置文件来修改w以及设置wtimeout，以避免由于某个节点挂起导致无法应答</p>
<h4 id="writeConcern-和getLastError-的关系"><a href="#writeConcern-和getLastError-的关系" class="headerlink" title="writeConcern 和getLastError 的关系"></a>writeConcern 和getLastError 的关系</h4><p>mongodb有一个<code>write concern</code>的设置，作用是保障<code>write operation</code>的可靠性。一般是在client driver里设置的，和db.getLastError()方法关系很大<br>一般来说，所有的mongo driver，在执行一个写操作（insert、update、delete）之后，都会立刻调用db.getLastError()方法。这样才有机会知道刚才的写操作是否成功，如果捕获到错误，就可以进行相应的处理。处理逻辑也是完全由client决定的，比如写入日志、抛出错误、等待一段时间再次尝试写入等。作为<code>mongodb server</code>并不关心，server只负责通知client发生了错误</p>
<p>这里有3点需要注意：    </p>
<ul>
<li>db.getLastError()方法是由driver负责调用的，所以业务代码不需要去显式调用。这点后面还会专门提到。</li>
<li>driver一定会调用db.getLastError()函数，但是并不一定能捕获到错误。这主要取决于write concern的设置级别。</li>
<li>写安全机制 实际上就是在 安全性跟性能之间做权衡。</li>
</ul>
<h3 id="读策略-ReadConcern和ReadPreference"><a href="#读策略-ReadConcern和ReadPreference" class="headerlink" title="读策略(ReadConcern和ReadPreference)"></a>读策略(ReadConcern和ReadPreference)</h3><h4 id="ReadConcern级别以及作用"><a href="#ReadConcern级别以及作用" class="headerlink" title="ReadConcern级别以及作用"></a>ReadConcern级别以及作用</h4><p><img src="/2020/12/18/mongo%E6%9C%8D%E5%8A%A1/2019110711451161.png" alt="ReadConcern"></p>
<h4 id="ReadPreference设置参数"><a href="#ReadPreference设置参数" class="headerlink" title="ReadPreference设置参数"></a>ReadPreference设置参数</h4><p><img src="/2020/12/18/mongo%E6%9C%8D%E5%8A%A1/20191107115036767.png" alt="ReadConcern"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(1)--dist</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-dist/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
当我们提到Redis的“数据结构”的时候，可能是在两个不同的层面来讨论它

<p>第一个层面，是从使用者的角度，分为了5个数据结构</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hash</li>
<li>Set</li>
<li>Sorted set</li>
</ul>
<p>第一个层面也是Redis暴露给外部提供的接口</p>
<a id="more"></a>
<hr>
<p>第二个层面，是从内部实现的角度，属于更底层的实现。比如：</p>
<ul>
<li>dict</li>
<li>sds</li>
<li>ziplist</li>
<li>quicklist</li>
<li>skiplist</li>
</ul>
<p>本文的重点在于讨论第二个层面，Redis数据结构的内部实现，以及这两个层面的数据结构之间的关系：Redis如何通过组合第二个层面的各种基础数据结构来实现第一个层面的更高层的数据结构。</p>
<p>在讨论任何一个系统的内部实现的时候，我们都要先明确它的设计原则，这样我们才能更深刻地理解它为什么会进行如此设计的真正意图。在本文接下来的讨论中，我们主要关注以下几点：</p>
<ul>
<li>存储效率（memory efficiency）。Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。这意味着Redis一定是非常精细地考虑了压缩数据、减少内存碎片等问题。</li>
<li>快速响应时间（fast response time）。与快速响应时间相对的，是高吞吐量（high throughput）。Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，快速响应时间是比高吞吐量更重要的目标。有时候，这两个目标是矛盾的。</li>
<li>单线程（single-threaded）。Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。</li>
</ul>
<h3 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h3><p>dict是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。Redis的一个database中所有key到value的映射，就是使用一个dict来维护的。不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。比如，<code>一个Redis hash结构，当它的field较多时，便会采用dict来存储</code>。再比如，<code>Redis配合使用dict和skiplist来共同维护一个sorted set</code>。这些细节我们后面再讨论，在本文中，我们集中精力讨论dict本身的实现。</p>
<p>dict本质上是为了解决算法中的查找问题（Searching），一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。我们平常使用的各种Map或dictionary，大都是基于哈希表实现的。在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，基于哈希表的查找性能能做到非常高效，接近O(1)，而且实现简单。</p>
<p>在Redis中，dict也是一个基于哈希表的算法。和传统的哈希算法类似，它采用某个哈希函数从key计算得到在哈希表中的位置，采用拉链法解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发重哈希（rehashing）。Redis的dict实现最显著的一个特点，就在于它的重哈希。它采用了一种称为增量式重哈希（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。这种方法能做到每次只对一小部分key进行重哈希，而每次重哈希之间不影响dict的操作。dict之所以这样设计，是为了避免重哈希期间单个请求的响应时间剧烈增加，这与前面提到的“快速响应时间”的设计原则是相符的。</p>
<h3 id="dict的数据结构定义"><a href="#dict的数据结构定义" class="headerlink" title="dict的数据结构定义"></a>dict的数据结构定义</h3><p>为了实现增量式重哈希（incremental rehashing），dict的数据结构里包含两个哈希表。在重哈希期间，数据从第一个哈希表向第二个哈希表迁移。</p>
<p>dict的C代码定义如下（出自Redis源码dict.h）：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>为了能更清楚地展示dict的数据结构定义，我们用一张结构图来表示它。如下:<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1-dist/redis_dict_structure.png" alt="redis_dict_structure"></p>
<p>一个dict由如下若干项组成：</p>
<ul>
<li>一个指向dictType结构的指针（type）。它通过自定义的方式使得dict的key和value能够存储任何类型的数据。</li>
<li>一个私有数据指针（privdata）。由调用者在创建dict的时候传进来。</li>
<li>两个哈希表（ht[2]）。只有在重哈希的过程中，ht[0]和ht[1]才都有效。而在平常情况下，只有ht[0]有效，ht[1]里面没有任何数据。上图表示的就是重哈希进行到中间某一步时的情况。</li>
<li>当前重哈希索引（rehashidx）。如果rehashidx = -1，表示当前没有在重哈希过程中；否则，表示当前正在进行重哈希，且它的值记录了当前重哈希进行到哪一步了。</li>
<li>当前正在进行遍历的iterator的个数。这不是我们现在讨论的重点，暂时忽略。</li>
</ul>
<p>dictType结构包含若干函数指针，用于dict的调用者对涉及key和value的各种操作进行自定义。这些操作包含：</p>
<ul>
<li>hashFunction，对key进行哈希值计算的哈希算法。</li>
<li>keyDup和valDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递对象指针。</li>
<li>keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。</li>
<li>keyDestructor和valDestructor，分别定义对key和value的析构函数。</li>
<li>私有数据指针（privdata）就是在dictType的某些操作被调用时会传回给调用者。</li>
</ul>
<p>需要详细察看的是dictht结构。它定义一个哈希表的结构，由如下若干项组成：</p>
<ul>
<li>一个dictEntry指针数组（table）。key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li>
<li>size：标识dictEntry指针数组的长度。它总是2的指数。</li>
<li>sizemask：用于将哈希值映射到table的位置索引。它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; - - sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。</li>
<li>used：记录dict中现有的数据个数。它与size的比值就是装载因子（load factor）。这个比值越大，哈希值冲突概率越高。</li>
</ul>
<p>dictEntry结构中包含k, v和指向链表下一项的next指针。k是void指针，这意味着它可以指向任何类型。v是个union，当它的值是uint64_t、int64_t或double类型时，就不再需要额外的存储，这有利于减少内存碎片。当然，v也可以是void指针，以便能存储任何类型的数据。</p>
<h3 id="dict的创建（dictCreate）"><a href="#dict的创建（dictCreate）" class="headerlink" title="dict的创建（dictCreate）"></a>dict的创建（dictCreate）</h3><figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">dict *dictCreate(dictType *type,</span><br><span class="line">        void *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    dict *d = zmalloc(sizeof(*d));</span><br><span class="line"></span><br><span class="line">    _dictInit(d,type,privDataPtr);</span><br><span class="line">    return d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int _dictInit(dict *d, dictType *type,</span><br><span class="line">        void *privDataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">0</span>]);</span><br><span class="line">    _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">1</span>]);</span><br><span class="line">    <span class="function"><span class="title">d</span>-&gt;</span>type = type;</span><br><span class="line">    <span class="function"><span class="title">d</span>-&gt;</span>privdata = privDataPtr;</span><br><span class="line">    <span class="function"><span class="title">d</span>-&gt;</span>rehashidx = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">d</span>-&gt;</span>iterators = <span class="number">0</span>;</span><br><span class="line">    return DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void _dictReset(dictht *ht)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">ht</span>-&gt;</span>table = NULL;</span><br><span class="line">    <span class="function"><span class="title">ht</span>-&gt;</span>size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">ht</span>-&gt;</span>sizemask = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">ht</span>-&gt;</span>used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dictCreate为dict的数据结构分配空间并为各个变量赋初值。其中两个哈希表ht[0]和ht[1]起始都没有分配空间，table指针都赋为NULL。这意味着要等第一个数据插入时才会真正分配空间。</p>
<h3 id="dict的查找（dictFind）"><a href="#dict的查找（dictFind）" class="headerlink" title="dict的查找（dictFind）"></a>dict的查找（dictFind）</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#define dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span> ((d)-&gt;rehashidx != -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dictEntry *dict<span class="constructor">Find(<span class="params">dict</span> <span class="operator">*</span><span class="params">d</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    unsigned <span class="built_in">int</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht<span class="literal">[<span class="number">0</span>]</span>.used + d-&gt;ht<span class="literal">[<span class="number">1</span>]</span>.used<span class="operator"> == </span><span class="number">0</span>) return NULL; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span>) <span class="constructor">_dictRehashStep(<span class="params">d</span>)</span>;</span><br><span class="line">    h = dict<span class="constructor">HashKey(<span class="params">d</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht<span class="literal">[<span class="identifier">table</span>]</span>.sizemask;</span><br><span class="line">        he = d-&gt;ht<span class="literal">[<span class="identifier">table</span>]</span>.table<span class="literal">[<span class="identifier">idx</span>]</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key<span class="operator"> || </span>dict<span class="constructor">CompareKeys(<span class="params">d</span>, <span class="params">key</span>, <span class="params">he</span>-&gt;<span class="params">key</span>)</span>)</span><br><span class="line">                return he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span>) return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述dictFind的源码，根据dict当前是否正在重哈希，依次做了这么几件事：</p>
<ul>
<li>如果当前正在进行重哈希，那么将重哈希过程向前推进一步（即调用<code>_dictRehashStep</code>）。实际上，除了查找，插入和删除也都会触发这一动作。这就将重哈希过程分散到各个查找、插入和删除操作中去了，而不是集中在某一个操作中一次性做完。</li>
<li>计算key的哈希值（调用dictHashKey，里面的实现会调用前面提到的hashFunction）。</li>
<li>先在第一个哈希表ht[0]上进行查找。在table数组上定位到哈希值对应的位置（如前所述，通过哈希值与sizemask进行按位与），然后在对应的dictEntry链表上进行查找。查找的时候需要对key进行比较，这时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项。否则，进行下一步。</li>
<li>判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回NULL）。否则，在ht[1]上进行查找（过程与上一步相同）。</li>
</ul>
<p>下面我们有必要看一下增量式重哈希的_dictRehashStep的实现。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">static void _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (d-&gt;</span>iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dictRehash(dict *d, int n) &#123;</span><br><span class="line">    int empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) return <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span>(n-- &amp;&amp; d-&gt;</span>ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can&#x27;t overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        <span class="function"><span class="title">assert</span>(d-&gt;</span><span class="function"><span class="title">ht</span>[0].size &gt; (unsigned long)d-&gt;</span>rehashidx);</span><br><span class="line">        <span class="function"><span class="title">while</span>(d-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx] == NULL) &#123;</span><br><span class="line">            <span class="function"><span class="title">d</span>-&gt;</span>rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) return <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">de</span> = d-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            unsigned int h;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="title">nextde</span> = de-&gt;</span>next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            <span class="function"><span class="title">h</span> = dictHashKey(d, de-&gt;</span><span class="function"><span class="title">key</span>) &amp; d-&gt;</span>ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            <span class="function"><span class="title">de</span>-&gt;</span><span class="function"><span class="title">next</span> = d-&gt;</span>ht[<span class="number">1</span>].table[h];</span><br><span class="line">            <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">0</span>].used--;</span><br><span class="line">            <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx] = NULL;</span><br><span class="line">        <span class="function"><span class="title">d</span>-&gt;</span>rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (d-&gt;</span>ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">zfree</span>(d-&gt;</span>ht[<span class="number">0</span>].table);</span><br><span class="line">        <span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">ht</span>[0] = d-&gt;</span>ht[<span class="number">1</span>];</span><br><span class="line">        _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">1</span>]);</span><br><span class="line">        <span class="function"><span class="title">d</span>-&gt;</span>rehashidx = -<span class="number">1</span>;</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    return <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dictRehash每次将重哈希至少向前推进n步（除非不到n步整个重哈希就结束了），每一步都将ht[0]上某一个bucket（即一个dictEntry链表）上的每一个dictEntry移动到ht[1]上，它在ht[1]上的新位置根据ht[1]的sizemask进行重新计算。rehashidx记录了当前尚未迁移（有待迁移）的ht[0]的bucket位置。</p>
<p>如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么它就没有可迁移的数据。这时它尝试在ht[0].table数组中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，则最多走n*10步，本次重哈希暂告结束。</p>
<p>最后，如果ht[0]上的数据都迁移到ht[1]上了（即d-&gt;ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。</p>
<p>根据以上对于重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上去了。</p>
<h3 id="dict的插入（dictAdd和dictReplace）"><a href="#dict的插入（dictAdd和dictReplace）" class="headerlink" title="dict的插入（dictAdd和dictReplace）"></a>dict的插入（dictAdd和dictReplace）</h3><p>dictAdd插入新的一对key和value，如果key已经存在，则插入失败。</p>
<p>dictReplace也是插入一对key和value，不过在key存在的时候，它会更新value。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> dict<span class="constructor">Add(<span class="params">dict</span> <span class="operator">*</span><span class="params">d</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *entry = dict<span class="constructor">AddRaw(<span class="params">d</span>,<span class="params">key</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!entry) return DICT_ERR;</span><br><span class="line">    dict<span class="constructor">SetVal(<span class="params">d</span>, <span class="params">entry</span>, <span class="params">val</span>)</span>;</span><br><span class="line">    return DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dictEntry *dict<span class="constructor">AddRaw(<span class="params">dict</span> <span class="operator">*</span><span class="params">d</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span>) <span class="constructor">_dictRehashStep(<span class="params">d</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = <span class="constructor">_dictKeyIndex(<span class="params">d</span>, <span class="params">key</span>)</span>)<span class="operator"> == </span>-<span class="number">1</span>)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the memory and store the new entry.</span></span><br><span class="line"><span class="comment">     * Insert the element in top, with the assumption that in a database</span></span><br><span class="line"><span class="comment">     * system it is more likely that recently added entries are accessed</span></span><br><span class="line"><span class="comment">     * more frequently. */</span></span><br><span class="line">    ht = dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span> ? &amp;d-&gt;ht<span class="literal">[<span class="number">1</span>]</span> : &amp;d-&gt;ht<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">    entry = zmalloc(sizeof(*entry));</span><br><span class="line">    entry-&gt;next = ht-&gt;table<span class="literal">[<span class="identifier">index</span>]</span>;</span><br><span class="line">    ht-&gt;table<span class="literal">[<span class="identifier">index</span>]</span> = entry;</span><br><span class="line">    ht-&gt;used++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the hash entry fields. */</span></span><br><span class="line">    dict<span class="constructor">SetKey(<span class="params">d</span>, <span class="params">entry</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    return entry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">int</span> <span class="constructor">_dictKeyIndex(<span class="params">dict</span> <span class="operator">*</span><span class="params">d</span>, <span class="params">const</span> <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unsigned <span class="built_in">int</span> h, idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="constructor">_dictExpandIfNeeded(<span class="params">d</span>)</span><span class="operator"> == </span>DICT_ERR)</span><br><span class="line">        return -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Compute the key hash value */</span></span><br><span class="line">    h = dict<span class="constructor">HashKey(<span class="params">d</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = h &amp; d-&gt;ht<span class="literal">[<span class="identifier">table</span>]</span>.sizemask;</span><br><span class="line">        <span class="comment">/* Search if this slot does not already contain the given key */</span></span><br><span class="line">        he = d-&gt;ht<span class="literal">[<span class="identifier">table</span>]</span>.table<span class="literal">[<span class="identifier">idx</span>]</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key<span class="operator"> || </span>dict<span class="constructor">CompareKeys(<span class="params">d</span>, <span class="params">key</span>, <span class="params">he</span>-&gt;<span class="params">key</span>)</span>)</span><br><span class="line">                return -<span class="number">1</span>;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dict<span class="constructor">IsRehashing(<span class="params">d</span>)</span>) break;</span><br><span class="line">    &#125;</span><br><span class="line">    return idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是dictAdd的关键实现代码。我们主要需要注意以下几点：</p>
<ul>
<li>它也会触发推进一步重哈希（_dictRehashStep）。</li>
<li>如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]。</li>
<li>在对应的bucket中插入数据的时候，总是插入到dictEntry的头部。因为新数据接下来被访问的概率可能比较高，这样再次查找它时就比较次数较少。</li>
<li>_dictKeyIndex在dict中寻找插入位置。如果不在重哈希过程中，它只查找ht[0]；否则查找ht[0]和ht[1]。</li>
<li>_dictKeyIndex可能触发dict内存扩展（_dictExpandIfNeeded，它将哈希表长度扩展为原来两倍，具体请参考dict.c中源码）。<br>dictReplace在dictAdd基础上实现，如下：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> dict<span class="constructor">Replace(<span class="params">dict</span> <span class="operator">*</span><span class="params">d</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dictEntry *entry, auxentry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to add the element. If the key</span></span><br><span class="line"><span class="comment">     * does not exists dictAdd will suceed. */</span></span><br><span class="line">    <span class="keyword">if</span> (dict<span class="constructor">Add(<span class="params">d</span>, <span class="params">key</span>, <span class="params">val</span>)</span><span class="operator"> == </span>DICT_OK)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* It already exists, get the entry */</span></span><br><span class="line">    entry = dict<span class="constructor">Find(<span class="params">d</span>, <span class="params">key</span>)</span>;</span><br><span class="line">    <span class="comment">/* Set the new value and free the old one. Note that it is important</span></span><br><span class="line"><span class="comment">     * to do that in this order, as the value may just be exactly the same</span></span><br><span class="line"><span class="comment">     * as the previous one. In this context, think to reference counting,</span></span><br><span class="line"><span class="comment">     * you want to increment (set), and then decrement (free), and not the</span></span><br><span class="line"><span class="comment">     * reverse. */</span></span><br><span class="line">    auxentry = *entry;</span><br><span class="line">    dict<span class="constructor">SetVal(<span class="params">d</span>, <span class="params">entry</span>, <span class="params">val</span>)</span>;</span><br><span class="line">    dict<span class="constructor">FreeVal(<span class="params">d</span>, &amp;<span class="params">auxentry</span>)</span>;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind，这其实相当于两次查找过程。这里Redis的代码不够优化。</li>
</ul>
<h3 id="dict的删除（dictDelete）"><a href="#dict的删除（dictDelete）" class="headerlink" title="dict的删除（dictDelete）"></a>dict的删除（dictDelete）</h3><p>dictDelete的源码这里忽略，具体请参考<code>dict.c</code>。需要稍加注意的是：</p>
<ul>
<li>dictDelete也会触发推进一步重哈希（_dictRehashStep）</li>
<li>如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key；否则ht[0]和ht[1]它都要查找。</li>
<li>删除成功后会调用key和value的析构函数（keyDestructor和valDestructor）。</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(2)--sds</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-sds/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
不管在哪门编程语言当中，字符串都几乎是使用最多的数据结构。sds正是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。与其它语言环境中出现的字符串相比，它具有如下显著的特点：

<ul>
<li>可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。</li>
<li>二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。</li>
<li>与传统的C语言字符串类型兼容</li>
</ul>
<a id="more"></a>
<p>看到这里，很多对Redis有所了解的同学可能已经产生了一个疑问：Redis已经对外暴露了一个字符串结构，叫做string，那这里所说的sds到底和string是什么关系呢？可能有人会猜：string是基于sds实现的。这个猜想已经非常接近事实，但在描述上还不太准确。有关string和sds之间关系的详细分析，我们放在后面再讲。现在为了方便讨论，让我们先暂时简单地认为，string的底层实现就是sds。</p>
<p>在讨论sds的具体实现之前，我们先站在Redis使用者的角度，来观察一下string所支持的一些主要操作。下面是一个操作示例：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-sds/demo.png" alt="demo"><br>以上这些操作都比较简单，我们简单解释一下：</p>
<ul>
<li>初始的字符串的值设为”tinner”。</li>
<li>第3步通过append命令对字符串进行了追加，变成了”tinner jin”。</li>
<li>然后通过setbit命令将第53个bit设置成了1。bit的偏移量从左边开始算，从0开始。其中第48～55bit是中间的空格那个字符，它的ASCII码是0x20。将第53个bit设置成1之后，它的ASCII码变成了0x24，打印出来就是’$’。因此，- 现在字符串的值变成了”tinneri$jin”。</li>
<li>最后通过getrange取从倒数第3个字节到倒数第1个字节的内容，得到”jin”。</li>
</ul>
<p>这些命令的实现，有一部分是和sds的实现有关的。下面我们开始详细讨论。</p>
<h3 id="sds的数据结构定义"><a href="#sds的数据结构定义" class="headerlink" title="sds的数据结构定义"></a>sds的数据结构定义</h3><p>我们知道，在C语言中，字符串是以’\0’字符结尾（NULL结束符）的字符数组来存储的，通常表达为字符指针的形式（char *）。它不允许字节0出现在字符串中间，因此，它不能用来存储任意的二进制数据。</p>
<p>我们可以在sds.h中找到sds的类型定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure>
<p>肯定有人感到困惑了，竟然sds就等同于char *？我们前面提到过，sds和传统的C语言字符串保持类型兼容，因此它们的类型定义是一样的，都是char *。在有些情况下，需要传入一个C语言字符串的地方，也确实可以传入一个sds。但是，sds和char *并不等同。sds是Binary Safe的，它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。但这个长度字段在哪里呢？实际上sds还包含一个header结构：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sds一共有5种类型的header。之所以有5种，是为了能让不同长度的字符串可以使用不同大小的header。这样，短字符串就能使用较小的header，从而节省内存。</p>
<p>一个sds字符串的完整结构，由在内存地址上前后相邻的两部分组成：</p>
<ul>
<li>一个header。通常包含字符串的长度(len)、最大容量(alloc)和flags。sdshdr5有所不同。</li>
<li>一个字符数组。这个字符数组的长度等于最大容量+1。真正有效的字符串数据，其长度通常小于最大容量。在真正的字符串数据之后，是空余未用的字节（一般以字节0填充），允许在不重新分配内存的前提下让字符串数据向后做有限的扩展。在真正的字符串数据之后，还有一个NULL结束符，即ASCII码为0的’\0’字符。这是为了和传统C字符串兼容。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符。</li>
</ul>
<p>除了sdshdr5之外，其它4个header的结构都包含3个字段：</p>
<ul>
<li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li>
<li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li>
<li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。header的类型共有5种，在sds.h中有常量定义。</li>
</ul>
<blockquote>
<p>#define SDS_TYPE_5  0<br>#define SDS_TYPE_8  1<br>#define SDS_TYPE_16 2<br>#define SDS_TYPE_32 3<br>#define SDS_TYPE_64 4</p>
</blockquote>
<p>sds的数据结构，我们有必要非常仔细地去解析它。<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2-sds/redis_sds_structure.png" alt="demo"><br>上图是sds的一个内部结构的例子。图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdshdr16类型的header。但它们都表达了同样的一个长度为6的字符串的值：”tielei”。下面我们结合代码，来解释每一部分的组成。</p>
<p>sds的字符指针（s1和s2）就是指向真正的数据（字符数组）开始的位置，而header位于内存地址较低的方向。在sds.h中有一些跟解析header有关的宏定义：</p>
<blockquote>
<p>#define SDS_TYPE_MASK 7<br>#define SDS_TYPE_BITS 3<br>#define SDS_HDR_VAR(T,s) struct sdshdr##T <em>sh = (void</em>)((s)-(sizeof(struct sdshdr##T)));<br>#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))<br>#define SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</p>
</blockquote>
<p>其中SDS_HDR用来从sds字符串获得header起始位置的指针，比如SDS_HDR(8, s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。</p>
<p>当然，使用SDS_HDR之前我们必须先知道到底是哪一种header，这样我们才知道SDS_HDR第1个参数应该传什么。由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段。比如，s1[-1]和s2[-1]分别获得了s1和s2的flags的值。然后取flags的最低3个bit得到header的类型。</p>
<ul>
<li>由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。</li>
<li>由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。</li>
</ul>
<p>有了header指针，就能很快定位到它的len和alloc字段：</p>
<ul>
<li>s1的header中，len的值为0x06，表示字符串数据长度为6；alloc的值为0x80，表示字符数组最大容量为128。</li>
<li>s2的header中，len的值为0x0006，表示字符串数据长度为6；alloc的值为0x03E8，表示字符数组最大容量为1000。（注意：图中是按小端地址构成）</li>
</ul>
<p>在各个header的类型定义中，还有几个需要我们注意的地方：</p>
<ul>
<li>在各个header的定义中使用了<strong>attribute</strong> ((packed))，是为了让编译器以紧凑模式来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>
<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（flexible array member），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>
<li>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。</li>
</ul>
<p>至此，我们非常清楚地看到了：sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处：</p>
<ul>
<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>
<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。<br>弄清了sds的数据结构，它的具体操作函数就比较好理解了。</li>
</ul>
<h3 id="sds的一些基础函数"><a href="#sds的一些基础函数" class="headerlink" title="sds的一些基础函数"></a>sds的一些基础函数</h3><ul>
<li>sdslen(const sds s): 获取sds字符串长度。</li>
<li>sdssetlen(sds s, size_t newlen): 设置sds字符串长度。</li>
<li>sdsinclen(sds s, size_t inc): 增加sds字符串长度。</li>
<li>sdsalloc(const sds s): 获取sds字符串容量。</li>
<li>sdssetalloc(sds s, size_t newlen): 设置sds字符串容量。</li>
<li>sdsavail(const sds s): 获取sds字符串空余空间（即alloc - len）。</li>
<li>sdsHdrSize(char type): 根据header类型得到header大小。</li>
<li>sdsReqType(size_t string_size): 根据字符串数据长度计算所需要的header类型。</li>
</ul>
<p>这里我们挑选sdslen和sdsReqType的代码，察看一下。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">static inline size_t sdslen(<span class="keyword">const</span> sds s) &#123;</span><br><span class="line">    unsigned char flags = s[<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline char sdsReqType(size_t <span class="built_in">string</span>_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span>_size &lt; <span class="number">1</span>ll&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟前面的分析类似，sdslen先用s[-1]向低地址方向偏移1个字节，得到flags；然后与SDS_TYPE_MASK进行按位与，得到header类型；然后根据不同的header类型，调用SDS_HDR得到header起始指针，进而获得len字段。</p>
<p>通过sdsReqType的代码，很容易看到：</p>
<ul>
<li>长度在0和2^5-1之间，选用SDS_TYPE_5类型的header。</li>
<li>长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header。</li>
<li>长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header。</li>
<li>长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header。</li>
<li>长度大于2^32的，选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1。</li>
</ul>
<p>注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到最近<code>3.2 branch</code>上的<code>commit 6032340</code>才修复。</p>
<h3 id="sds的创建和销毁"><a href="#sds的创建和销毁" class="headerlink" title="sds的创建和销毁"></a>sds的创建和销毁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sdsnewlen创建一个长度为initlen的sds字符串，并使用init指向的字符数组（任意二进制数据）来初始化数据。如果init为NULL，那么使用全0来初始化数据。它的实现中，我们需要注意的是：</p>
<ul>
<li>如果要创建一个长度为0的空字符串，那么不使用SDS_TYPE_5类型的header，而是转而使用SDS_TYPE_8类型的header。这是因为创建的空字符串一般接下来的操作很可能是追加数据，但SDS_TYPE_5类型的sds字符串不适合追加数据（会引发内存重新分配）。</li>
<li>需要的内存空间一次性进行分配，其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）。</li>
<li>初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\0’）。</li>
</ul>
<p>关于sdsfree，需要注意的是：内存要整体释放，所以要先计算出header起始指针，把它传给s_free函数。这个指针也正是在sdsnewlen中调用s_malloc返回的那个地址。</p>
<h3 id="sds的连接（追加）操作"><a href="#sds的连接（追加）操作" class="headerlink" title="sds的连接（追加）操作"></a>sds的连接（追加）操作</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">sds sdscatlen(sds s, const void *t, size_t len) &#123;</span><br><span class="line">    size_t curlen = sdslen(s);</span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">    memcpy(s+curlen, t, len);</span><br><span class="line">    sdssetlen(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds sdscat(sds s, const char *t) &#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, strlen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds sdscatsds(sds s, const sds t) &#123;</span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sds sdsMakeRoomFor(sds s, size_t addlen) &#123;</span><br><span class="line">    void *sh, *<span class="keyword">new</span><span class="type">sh</span>;</span><br><span class="line">    size_t avail = sdsavail(s);</span><br><span class="line">    size_t len, <span class="keyword">new</span><span class="type">len</span>;</span><br><span class="line">    char type, oldtype = s[<span class="number">-1</span>] &amp; SDS_TYPE_MASK;</span><br><span class="line">    int hdrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return ASAP if there is enough space left. */</span></span><br><span class="line">    <span class="keyword">if</span> (avail &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    sh = (char*)s-sdsHdrSize(oldtype);</span><br><span class="line">    <span class="keyword">new</span><span class="type">len</span> = (len+addlen);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">len</span> &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        <span class="keyword">new</span><span class="type">len</span> *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">len</span> += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    type = sdsReqType(<span class="keyword">new</span><span class="type">len</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t use type 5: the user is appending to the string and type 5 is</span></span><br><span class="line"><span class="comment">     * not able to remember empty space, so sdsMakeRoomFor() must be called</span></span><br><span class="line"><span class="comment">     * at every appending operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5) type = SDS_TYPE_8;</span><br><span class="line"></span><br><span class="line">    hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">if</span> (oldtype==type) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">sh</span> = s_realloc(sh, hdrlen+<span class="keyword">new</span><span class="type">len</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">sh</span> == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        s = (char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Since the header size changes, need to move the string forward,</span></span><br><span class="line"><span class="comment">         * and can&#x27;t use realloc */</span></span><br><span class="line">        <span class="keyword">new</span><span class="type">sh</span> = s_malloc(hdrlen+<span class="keyword">new</span><span class="type">len</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">sh</span> == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">        memcpy((char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen, s, len+<span class="number">1</span>);</span><br><span class="line">        s_free(sh);</span><br><span class="line">        s = (char*)<span class="keyword">new</span><span class="type">sh</span>+hdrlen;</span><br><span class="line">        s[<span class="number">-1</span>] = type;</span><br><span class="line">        sdssetlen(s, len);</span><br><span class="line">    &#125;</span><br><span class="line">    sdssetalloc(s, <span class="keyword">new</span><span class="type">len</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sdscatlen将t指向的长度为len的任意二进制数据追加到sds字符串s的后面。本文开头演示的string的append命令，内部就是调用sdscatlen来实现的。</p>
<p>在sdscatlen的实现中，先调用sdsMakeRoomFor来保证字符串s有足够的空间来追加长度为len的数据。sdsMakeRoomFor可能会分配新的内存，也可能不会。</p>
<p>sdsMakeRoomFor是sds实现中很重要的一个函数。关于它的实现代码，我们需要注意的是：</p>
<ul>
<li>如果原来字符串中的空余空间够用（avail &gt;= addlen），那么它什么也不做，直接返回。</li>
<li>如果需要分配空间，它会比实际请求的要多分配一些，以防备接下来继续追加。它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。</li>
<li>按分配后的空间大小，可能需要更换header类型（原来header的alloc字段太短，表达不了增加后的容量）。</li>
<li>如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置。</li>
<li>如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间。s_realloc的具体实现得看Redis编译的时候选用了哪个allocator（在Linux上默认使用jemalloc）。但不管是哪个realloc的实现，它所表达的含义基本是相同的：它尽量在原来分配好的地址位置重新分配，如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁。参见(<a href="http://man.cx/realloc)[http://man.cx/realloc]%E3%80%82">http://man.cx/realloc)[http://man.cx/realloc]。</a></li>
</ul>
<p>从sdscatlen的函数接口，我们可以看到一种使用模式：调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。</p>
<h3 id="浅谈sds与string的关系"><a href="#浅谈sds与string的关系" class="headerlink" title="浅谈sds与string的关系"></a>浅谈sds与string的关系</h3><p>现在我们回过头来看看本文开头给出的string操作的例子。</p>
<ul>
<li>append操作使用sds的sdscatlen来实现。前面已经提到。</li>
<li>setbit和getrange都是先根据key取到整个sds字符串，然后再从字符串选取或修改指定的部分。由于sds就是一个字符数组，所以对它的某一部分进行操作似乎都比较简单。</li>
</ul>
<p>但是，string除了支持这些操作之外，当它存储的值是个数字的时候，它还支持incr、decr等操作。那么，当string存储数字值的时候，它的内部存储还是sds吗？实际上，不是了。而且，这种情况下，setbit和getrange的实现也会有所不同。这些细节，我们放在下一篇介绍robj的时候再进行系统地讨论。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(3)--robj</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3-robj/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash等。我们可以看到，key的类型固定是string，而value可能的类型是多个。

<p>而从Redis内部实现的角度来看，在前面第一篇文章中，我们已经提到过，一个database内的这个映射关系是用一个dict来维护的。dict的key固定用一种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是robj（全名是redisObject）。举个例子：如果value是一个list，那么它的内部存储结构是一个quicklist；如果value是一个string，那么它的内部存储结构一般情况下是一个sds。当然实际情况更复杂一点，比如一个string类型的value，如果它的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。而一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p>
<a id="more"></a>
<h3 id="robj的数据结构定义"><a href="#robj的数据结构定义" class="headerlink" title="robj的数据结构定义"></a>robj的数据结构定义</h3><p>在server.h中我们找到跟robj定义相关的代码，如下（注意，本系列文章中的代码片段全部来源于Redis源码的3.2分支）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects encoding. Some kind of objects like Strings and Hashes can be</span></span><br><span class="line"><span class="comment"> * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object</span></span><br><span class="line"><span class="comment"> * is set to one of this fields for this object. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* Encoded as regular linked list */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>一个robj包含如下5个字段：</p>
<ul>
<li>type: 对象的数据类型。占4个bit。可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构（即我们在第一篇文章中提到的第一个层面的5种数据结构）。</li>
<li>encoding: 对象的内部表示方式（也可以称为编码）。占4个bit。可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</li>
<li>lru: 做LRU替换算法用，占24个bit。这个不是我们这里讨论的重点，暂时忽略。</li>
<li>refcount: 引用计数。它允许robj对象在某些情况下被共享。</li>
<li>ptr: 数据指针。指向真正的数据。比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist。</li>
</ul>
<p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。<br>比如，当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p>
<ul>
<li>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</li>
<li>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</li>
<li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。</li>
</ul>
<p>再举一个例子：当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p>
<ul>
<li>OBJ_ENCODING_HT: hash采用一个dict来表示。</li>
<li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示（ziplist的具体实现我们放在后面的文章讨论）。</li>
</ul>
<p>本文剩余主要部分将针对表示string的robj对象，围绕它的3种不同的encoding来深入讨论。前面代码段中出现的所有10种encoding，在这里我们先简单解释一下，在这个系列后面的文章中，我们应该还有机会碰到它们。</p>
<ul>
<li>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</li>
<li>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</li>
<li>OBJ_ENCODING_HT: 表示成dict。</li>
<li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li>
<li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li>
<li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li>
<li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li>
<li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li>
<li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li>
<li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li>
</ul>
<p><strong>robj的作用：</strong></p>
<ul>
<li>为多种数据类型提供一种统一的表示方式。</li>
<li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li>
<li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li>
</ul>
<h3 id="string-robj的编码过程"><a href="#string-robj的编码过程" class="headerlink" title="string robj的编码过程"></a>string robj的编码过程</h3><p>当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。这一过程的核心代码，是object.c中的tryObjectEncoding函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">robj *<span class="keyword">try</span><span class="constructor">ObjectEncoding(<span class="params">robj</span> <span class="operator">*</span><span class="params">o</span>)</span> &#123;</span><br><span class="line">    long value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    size_t len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure this is a string object, the only type we encode</span></span><br><span class="line"><span class="comment">     * in this function. Other types use encoded memory efficient</span></span><br><span class="line"><span class="comment">     * representations but are handled by the commands implementing</span></span><br><span class="line"><span class="comment">     * the type. */</span></span><br><span class="line">    server<span class="constructor">AssertWithInfo(NULL,<span class="params">o</span>,<span class="params">o</span>-&gt;<span class="params">type</span> <span class="operator">==</span> OBJ_STRING)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try some specialized encoding only for objects that are</span></span><br><span class="line"><span class="comment">     * RAW or EMBSTR encoded, in other words objects that are still</span></span><br><span class="line"><span class="comment">     * in represented by an actually array of chars. */</span></span><br><span class="line">    <span class="keyword">if</span> (!sds<span class="constructor">EncodedObject(<span class="params">o</span>)</span>) return o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It&#x27;s not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the &quot;object space&quot; of Redis and may end in places where</span></span><br><span class="line"><span class="comment">     * they are not handled. We handle them only as values in the keyspace. */</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) return o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 21 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">21</span><span class="operator"> &amp;&amp; </span>string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory<span class="operator"> == </span><span class="number">0</span> <span class="pattern-match"><span class="operator">||</span></span></span><br><span class="line"><span class="pattern-match">             (server.maxmemory<span class="constructor">_policy</span> != <span class="constructor">MAXMEMORY_VOLATILE_LRU</span> <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">              server.maxmemory<span class="constructor">_policy</span> != <span class="constructor">MAXMEMORY_ALLKEYS_LRU</span>)) <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">            value &gt;= 0 <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">            value &lt; <span class="constructor">OBJ_SHARED_INTEGERS</span>)</span></span><br><span class="line"><span class="pattern-match">        &#123;</span></span><br><span class="line"><span class="pattern-match">            decr<span class="constructor">RefCount(<span class="params">o</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">            incr<span class="constructor">RefCount(<span class="params">shared</span>.<span class="params">integers</span>[<span class="params">value</span>])</span>;</span></span><br><span class="line"><span class="pattern-match">            return shared.integers[value];</span></span><br><span class="line"><span class="pattern-match">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">            <span class="keyword">if</span> (o-&gt;encoding <span class="operator">==</span> <span class="constructor">OBJ_ENCODING_RAW</span>) sdsfree(o-&gt;ptr);</span></span><br><span class="line"><span class="pattern-match">            o-&gt;encoding = <span class="constructor">OBJ_ENCODING_INT</span>;</span></span><br><span class="line"><span class="pattern-match">            o-&gt;ptr = (void<span class="operator">*</span>) value;</span></span><br><span class="line"><span class="pattern-match">            return o;</span></span><br><span class="line"><span class="pattern-match">        &#125;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> <span class="constructor">If</span> the <span class="built_in">string</span> is small <span class="keyword">and</span> is still <span class="constructor">RAW</span> encoded,</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="keyword">try</span> the <span class="constructor">EMBSTR</span> encoding which is more efficient.</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">In</span> this representation the <span class="keyword">object</span> <span class="keyword">and</span> the <span class="constructor">SDS</span> <span class="built_in">string</span> are allocated</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="keyword">in</span> the same chunk <span class="keyword">of</span> memory <span class="keyword">to</span> save space <span class="keyword">and</span> cache misses. <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (len &lt;= <span class="constructor">OBJ_ENCODING_EMBSTR_SIZE_LIMIT</span>) &#123;</span></span><br><span class="line"><span class="pattern-match">        robj <span class="operator">*</span>emb;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">        <span class="keyword">if</span> (o-&gt;encoding <span class="operator">==</span> <span class="constructor">OBJ_ENCODING_EMBSTR</span>) return o;</span></span><br><span class="line"><span class="pattern-match">        emb = create<span class="constructor">EmbeddedStringObject(<span class="params">s</span>,<span class="params">sdslen</span>(<span class="params">s</span>)</span>);</span></span><br><span class="line"><span class="pattern-match">        decr<span class="constructor">RefCount(<span class="params">o</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">        return emb;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> <span class="constructor">We</span> can&#x27;t encode the <span class="keyword">object</span><span class="operator">...</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">Do</span> the last <span class="keyword">try</span>, <span class="keyword">and</span> at least optimize the <span class="constructor">SDS</span> <span class="built_in">string</span> inside</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> the <span class="built_in">string</span> <span class="keyword">object</span> <span class="keyword">to</span> require little space, <span class="keyword">in</span> case there</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> is more than 10% <span class="keyword">of</span> free space at the <span class="keyword">end</span> <span class="keyword">of</span> the <span class="constructor">SDS</span> <span class="built_in">string</span>.</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span></span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">We</span> <span class="keyword">do</span> that only <span class="keyword">for</span> relatively large strings <span class="keyword">as</span> this branch</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> is only entered <span class="keyword">if</span> the length <span class="keyword">of</span> the <span class="built_in">string</span> is greater than</span></span><br><span class="line"><span class="pattern-match">     <span class="operator">*</span> <span class="constructor">OBJ_ENCODING_EMBSTR_SIZE_LIMIT</span>. <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    <span class="keyword">if</span> (o-&gt;encoding <span class="operator">==</span> <span class="constructor">OBJ_ENCODING_RAW</span> <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">        sdsavail(s) &gt; len<span class="operator">/</span>10)</span></span><br><span class="line"><span class="pattern-match">    &#123;</span></span><br><span class="line"><span class="pattern-match">        o-&gt;ptr = sds<span class="constructor">RemoveFreeSpace(<span class="params">o</span>-&gt;<span class="params">ptr</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">    &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">    <span class="operator">/</span><span class="operator">*</span> <span class="constructor">Return</span> the original <span class="keyword">object</span>. <span class="operator">*</span><span class="operator">/</span></span></span><br><span class="line"><span class="pattern-match">    return o;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这段代码执行的操作比较复杂，我们有必要仔细看一下每一步的操作：</p>
<ul>
<li>第1步检查，检查type。确保只对string类型的对象进行操作。</li>
<li>第2步检查，检查encoding。sdsEncodedObject是定义在server.h中的一个宏，确保只对OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR编码的string对象进行操作。这两种编码的string都采用sds来存储，可以尝试进一步编码处理。</li>
<li>第3步检查，检查refcount。引用计数大于1的共享对象，在多处被引用。由于编码过程结束后robj的对象指针可能会变化（我们在前一篇介绍sdscatlen函数的时候提到过类似这种接口使用模式），这样对于引用计数大于1的对象，就需要更新所有地方的引用，这不容易做到。因此，对于计数大于1的对象不做编码处理。</li>
<li>试图将字符串转成64位的long。64位的long所能表达的数据范围是-2^63到2^63-1，用十进制表达出来最长是20位数（包括负号）。这里判断小于等于21，似乎是写多了，实际判断小于等于20就够了（如果我算错了请一定告诉我哦）。string2l如果将字符串转成long转成功了，那么会返回1并且将转好的long存到value变量里。</li>
<li>在转成long成功时，又分为两种情况。<br>  第一种情况：如果Redis的配置不要求运行LRU替换算法，且转成的long型数字的值又比较小（小于OBJ_SHARED_INTEGERS，在目前的实现中这个值是10000），那么会使用共享数字对象来表示。之所以这里的判断跟LRU有关，是因为LRU算法要求每个robj有不同的lru字段值，所以用了LRU就不能共享robj。shared.integers是一个长度为10000的数组，里面预存了10000个小的数字对象。这些小数字对象都是encoding = OBJ_ENCODING_INT的string robj对象。<br>  第二种情况：如果前一步不能使用共享小对象来表示，那么将原来的robj编码成encoding = OBJ_ENCODING_INT，这时ptr字段直接存成这个long型的值。注意ptr字段本来是一个void *指针（即存储的是内存地址），因此在64位机器上有64位宽度，正好能存储一个64位的long型值。这样，除了robj本身之外，它就不再需要额外的内存空间来存储字符串值。</li>
<li>接下来是对于那些不能转成64位long的字符串进行处理。最后再做两步处理：<br>  如果字符串长度足够小（小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT，定义为44），那么调用createEmbeddedStringObject编码成encoding = OBJ_ENCODING_EMBSTR；<br>  如果前面所有的编码尝试都没有成功（仍然是OBJ_ENCODING_RAW），且sds里空余字节过多，那么做最后一次努力，调用sds的sdsRemoveFreeSpace接口来释放空余字节。</li>
</ul>
<p>其中调用的createEmbeddedStringObject，我们有必要看一下它的代码：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">robj *createEmbeddedStringObject(const char *ptr, size_t len) &#123;</span><br><span class="line">    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    struct sdshdr8 *sh = (void*)(o+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">o</span>-&gt;</span>type = OBJ_STRING;</span><br><span class="line">    <span class="function"><span class="title">o</span>-&gt;</span>encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    <span class="function"><span class="title">o</span>-&gt;</span>ptr = sh+<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">o</span>-&gt;</span>refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">o</span>-&gt;</span>lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">sh</span>-&gt;</span>len = len;</span><br><span class="line">    <span class="function"><span class="title">sh</span>-&gt;</span>alloc = len;</span><br><span class="line">    <span class="function"><span class="title">sh</span>-&gt;</span>flags = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="function"><span class="title">memcpy</span>(sh-&gt;</span>buf,ptr,len);</span><br><span class="line">        <span class="function"><span class="title">sh</span>-&gt;</span>buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">memset</span>(sh-&gt;</span>buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createEmbeddedStringObject对sds重新分配内存，将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片。这个连续的内存块包含如下几部分：</p>
<ul>
<li>16个字节的robj结构。</li>
<li>3个字节的sdshdr8头。</li>
<li>最多44个字节的sds字符数组。</li>
<li>1个NULL结束符。</li>
</ul>
<p>加起来一共不超过64字节（16+3+44+1），因此这样的一个短字符串可以完全分配在一个64字节长度的内存块中。</p>
<h3 id="string-robj的解码过程"><a href="#string-robj的解码过程" class="headerlink" title="string robj的解码过程"></a>string robj的解码过程</h3><p>当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。</p>
<p>这一解码过程的核心代码，是object.c中的getDecodedObject函数。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">robj *getDecodedObject(<span class="name">robj</span> *o) &#123;</span><br><span class="line">    robj *dec<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (<span class="name">sdsEncodedObject</span>(<span class="name">o</span>)) &#123;</span><br><span class="line">        incrRefCount(<span class="name">o</span>)<span class="comment">;</span></span><br><span class="line">        return o<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">o-&gt;type</span> == OBJ_STRING <span class="symbol">&amp;&amp;</span> o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        char buf[<span class="number">32</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        ll2string(<span class="name">buf</span>,<span class="number">32</span>,(<span class="name">long</span>)o-&gt;ptr)<span class="comment">;</span></span><br><span class="line">        dec = createStringObject(<span class="name">buf</span>,strlen(<span class="name">buf</span>))<span class="comment">;</span></span><br><span class="line">        return dec<span class="comment">;</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown encoding type&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个过程比较简单，需要我们注意的点有：</p>
<ul>
<li>编码为OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR的字符串robj对象，不做变化，原封不动返回。站在使用者的角度，这两种编码没有什么区别，内部都是封装的sds。</li>
<li>编码为数字的字符串robj对象，将long重新转为十进制字符串的形式，然后调用createStringObject转为sds的表示。注意：这里由long转成的sds字符串长度肯定不超过20，而根据createStringObject的实现，它们肯定会被编码成OBJ_ENCODING_EMBSTR的对象。createStringObject的代码如下：<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">robj *create<span class="constructor">StringObject(<span class="params">const</span> <span class="params">char</span> <span class="operator">*</span><span class="params">ptr</span>, <span class="params">size_t</span> <span class="params">len</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        return create<span class="constructor">EmbeddedStringObject(<span class="params">ptr</span>,<span class="params">len</span>)</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return create<span class="constructor">RawStringObject(<span class="params">ptr</span>,<span class="params">len</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="再谈sds与string的关系"><a href="#再谈sds与string的关系" class="headerlink" title="再谈sds与string的关系"></a>再谈sds与string的关系</h3><p>在上一篇文章中，我们简单地提到了sds与string的关系；在本文介绍了robj的概念之后，我们重新总结一下sds与string的关系。</p>
<ul>
<li>确切地说，string在Redis中是用一个robj来表示的。</li>
<li>用来表示string的robj可能编码成3种内部表示：OBJ_ENCODING_RAW, OBJ_ENCODING_EMBSTR, OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把string存成了long型。</li>
<li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li>
<li>对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。而如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执行setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。由于篇幅原因，这三个命令的实现代码这里就不详细介绍了，有兴趣的读者可以参考Redis源码：<br>  t_string.c中的appendCommand函数；<br>  biops.c中的setbitCommand函数；<br>  t_string.c中的getrangeCommand函数。</li>
</ul>
<p>值得一提的是，append和setbit命令的实现中，都会最终调用到db.c中的dbUnshareStringValue函数，将string对象的内部编码转成OBJ_ENCODING_RAW的（只有这种编码的robj对象，其内部的sds 才能在后面自由追加新的内容），并解除可能存在的对象共享状态。这里面调用了前面提到的getDecodedObject。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">robj *db<span class="constructor">UnshareStringValue(<span class="params">redisDb</span> <span class="operator">*</span><span class="params">db</span>, <span class="params">robj</span> <span class="operator">*</span><span class="params">key</span>, <span class="params">robj</span> <span class="operator">*</span><span class="params">o</span>)</span> &#123;</span><br><span class="line">    server<span class="constructor">Assert(<span class="params">o</span>-&gt;<span class="params">type</span> <span class="operator">==</span> OBJ_STRING)</span>;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span><span class="operator"> || </span>o-&gt;encoding != OBJ_ENCODING_RAW) &#123;</span><br><span class="line">        robj *decoded = get<span class="constructor">DecodedObject(<span class="params">o</span>)</span>;</span><br><span class="line">        o = create<span class="constructor">RawStringObject(<span class="params">decoded</span>-&gt;<span class="params">ptr</span>, <span class="params">sdslen</span>(<span class="params">decoded</span>-&gt;<span class="params">ptr</span>)</span>);</span><br><span class="line">        decr<span class="constructor">RefCount(<span class="params">decoded</span>)</span>;</span><br><span class="line">        db<span class="constructor">Overwrite(<span class="params">db</span>,<span class="params">key</span>,<span class="params">o</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="robj的引用计数操作"><a href="#robj的引用计数操作" class="headerlink" title="robj的引用计数操作"></a>robj的引用计数操作</h3><p>将robj的引用计数加1和减1的操作，定义在object.c中：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> incrRefCount(robj *o) &#123;</span><br><span class="line">    o-&gt;refcount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> decrRefCount(robj *o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">&quot;decrRefCount against refcount &lt;= 0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">&quot;Unknown object type&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们特别关注一下将引用计数减1的操作decrRefCount。如果只剩下最后一个引用了（refcount已经是1了），那么在decrRefCount被调用后，整个robj将被释放。</p>
<p>注意：Redis的del命令就依赖<code>decrRefCount</code>操作将value释放掉。</p>
<hr>
<p>经过了本文的讨论，我们很容易看出，robj所表示的就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪个（或哪些）第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist, 等），则通过不同的encoding来区分。可以说，robj是联结两个层面的数据结构的桥梁。</p>
<p>本文详细介绍了OBJ_STRING类型的字符串对象的底层实现，其编码和解码过程在Redis里非常重要，应用广泛，我们在后面的讨论中可能还会遇到。现在有了robj的概念基础，我们下一篇会讨论ziplist，以及它与hash的关系。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(4)-ziplist</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4-ziplist/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>在本文中，我们首先介绍一个新的Redis内部数据结构——ziplist，然后在文章后半部分我们会讨论一下在robj, dict和ziplist的基础上，Redis对外暴露的hash结构是怎样构建起来的。</p>
<p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">hash-<span class="built_in">max</span>-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-<span class="built_in">max</span>-ziplist-<span class="built_in">value</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="什么是ziplist"><a href="#什么是ziplist" class="headerlink" title="什么是ziplist"></a>什么是ziplist</h3><p>Redis官方对于ziplist的定义是（出自ziplist.c的文件头部注释）：</p>
<blockquote>
<p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time.</p>
</blockquote>
<p>翻译一下就是说：<code>ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</code></p>
<p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
<p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。</p>
<h3 id="ziplist的数据结构定义"><a href="#ziplist的数据结构定义" class="headerlink" title="ziplist的数据结构定义"></a>ziplist的数据结构定义</h3><p>从宏观上看，ziplist的内存结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">zlbytes</span>&gt;</span><span class="tag">&lt;<span class="name">zltail</span>&gt;</span><span class="tag">&lt;<span class="name">zllen</span>&gt;</span><span class="tag">&lt;<span class="name">entry</span>&gt;</span>...<span class="tag">&lt;<span class="name">entry</span>&gt;</span><span class="tag">&lt;<span class="name">zlend</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p>
<ul>
<li><code>&lt;zlbytes&gt;</code>: 32bit，表示ziplist占用的字节总数（也包括<code>&lt;zlbytes&gt;</code>本身占用的4个字节）。</li>
<li><code>&lt;zltail&gt;</code>: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。<code>&lt;zltail&gt;</code>的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</li>
<li><code>&lt;zllen&gt;</code>: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2^16-1。这里需要特别注意的是，如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果<code>&lt;zllen&gt;</code>小于等于2^16-2（也就是不等于2^16-1），那么<code>&lt;zllen&gt;</code>就表示ziplist中数据项的个数；否则，也就是<code>&lt;zllen&gt;</code>等于16bit全为1的情况，那么<code>&lt;zllen&gt;</code>就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</li>
<li><code>&lt;entry&gt;</code>: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</li>
<li><code>&lt;zlend&gt;</code>: ziplist最后1个字节，是一个结束标记，值固定等于255。<br>上面的定义中还值得注意的一点是：<code>&lt;zlbytes&gt;</code>, <code>&lt;zltail&gt;</code>, <code>&lt;zllen&gt;</code>既然占据多个字节，那么在存储的时候就有大端（big endian）和小端（little endian）的区别。ziplist采取的是小端模式来存储，这在下面我们介绍具体例子的时候还会再详细解释。</li>
</ul>
<p>我们再来看一下每一个数据项<code>&lt;entry&gt;</code>的构成：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;prevrawlen&gt;</span><span class="section">&lt;len&gt;</span><span class="section">&lt;data&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看到在真正的数据（<code>&lt;data&gt;</code>）前面，还有两个字段：</p>
<ul>
<li><code>&lt;prevrawlen&gt;</code>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。</li>
<li><code>&lt;len&gt;</code>: 表示当前数据项的数据长度（即<code>&lt;data&gt;</code>部分的长度）。也采用变长编码。</li>
</ul>
<h3 id="那么-lt-prevrawlen-gt-和-lt-len-gt-是怎么进行变长编码的呢？"><a href="#那么-lt-prevrawlen-gt-和-lt-len-gt-是怎么进行变长编码的呢？" class="headerlink" title="那么&lt;prevrawlen&gt;和&lt;len&gt;是怎么进行变长编码的呢？"></a>那么<code>&lt;prevrawlen&gt;</code>和<code>&lt;len&gt;</code>是怎么进行变长编码的呢？</h3><p>先说<code>&lt;prevrawlen&gt;</code>。它有两种可能，或者是1个字节，或者是5个字节：</p>
<ul>
<li>如果前一个数据项占用字节数小于254，那么<code>&lt;prevrawlen&gt;</code>就只用一个字节来表示，这个字节的值就是前一个数据项的占用字节数。</li>
<li>如果前一个数据项占用字节数大于等于254，那么<code>&lt;prevrawlen&gt;</code>就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数。</li>
</ul>
<p><strong>为什么没有255的情况呢？</strong><br>这是因为：255已经定义为ziplist结束标记<code>&lt;zlend&gt;</code>的值了。在ziplist的很多操作的实现中，都会根据数据项的第1个字节是不是255来判断当前是不是到达ziplist的结尾了，因此一个正常的数据的第1个字节（也就是<code>&lt;prevrawlen&gt;</code>的第1个字节）是不能够取255这个值的，否则就冲突了。</p>
<p>而<len>字段就更加复杂了，它根据第1个字节的不同，总共分为9种情况（下面的表示法是按二进制表示）：</len></p>
<ol>
<li>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<len>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。</len></li>
<li>|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<len>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。</len></li>
<li>|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，<data>都是按字符串来存储的；从下面第4种情况开始，<data>开始变为按整数来存储了。</data></data></li>
<li>|11000000| - 1 byte。<len>字段占用1个字节，值为0xC0，后面的数据<data>存储为2个字节的int16_t类型。</data></len></li>
<li>|11010000| - 1 byte。<len>字段占用1个字节，值为0xD0，后面的数据<data>存储为4个字节的int32_t类型。</data></len></li>
<li>|11100000| - 1 byte。<len>字段占用1个字节，值为0xE0，后面的数据<data>存储为8个字节的int64_t类型。</data></len></li>
<li>|11110000| - 1 byte。<len>字段占用1个字节，值为0xF0，后面的数据<data>存储为3个字节长的整数。</data></len></li>
<li>|11111110| - 1 byte。<len>字段占用1个字节，值为0xFE，后面的数据<data>存储为1个字节的整数。</data></len></li>
<li>|1111xxxx| - - (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<data>字段来表示真正的数据了，而是<len>和<data>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。</data></len></data></li>
</ol>
<p>好了，ziplist的数据结构定义，我们介绍完了，现在我们看一个具体的例子。<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4-ziplist/redis_ziplist_sample.png" alt="sample"></p>
<p>上图是一份真实的ziplist数据。我们逐项解读一下：</p>
<ul>
<li>这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</li>
<li>头4个字节（0x21000000）是按小端（little endian）模式存储的<code>&lt;zlbytes&gt;</code>字段。什么是小端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条Endianness）。因此，这里<code>&lt;zlbytes&gt;</code>的值应该解析成0x00000021，用十进制表示正好就是33。</li>
<li>接下来4个字节（byte[4..7]）是<code>&lt;zltail&gt;</code>，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</li>
<li>再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</li>
<li>接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为”name”。</li>
<li>接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串”tielei”。</li>
<li>接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串”age”。</li>
<li>接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</li>
<li>最后1个字节（byte[32]）表示<code>&lt;zlend&gt;</code>，是固定的值255（0xFF）。</li>
</ul>
<p>总结一下，这个ziplist里存了4个数据项，分别为：</p>
<ul>
<li>字符串: “name”</li>
<li>字符串: “tielei”</li>
<li>字符串: “age”</li>
<li>整数: 20</li>
</ul>
<p>实际上，这个ziplist是通过两个hset命令创建出来的。这个我们后半部分会再提到。</p>
<h3 id="ziplist的接口"><a href="#ziplist的接口" class="headerlink" title="ziplist的接口"></a>ziplist的接口</h3><p>几个重要的接口：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">New(<span class="params">void</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Merge(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">**</span><span class="params">first</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">**</span><span class="params">second</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Push(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">s</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">slen</span>, <span class="params">int</span> <span class="params">where</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Index(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">int</span> <span class="params">index</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Next(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">p</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Prev(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">p</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Insert(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">p</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">s</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">slen</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Delete(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">**</span><span class="params">p</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">char</span> *ziplist<span class="constructor">Find(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">p</span>, <span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">vstr</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">vlen</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">skip</span>)</span>;</span><br><span class="line">unsigned <span class="built_in">int</span> ziplist<span class="constructor">Len(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">zl</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>我们从这些接口的名字就可以粗略猜出它们的功能，下面简单解释一下：</p>
<ul>
<li>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</li>
<li>ziplistNew: 创建一个空的ziplist（只包含<code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code>）。</li>
<li>ziplistMerge: 将两个ziplist合并成一个新的ziplist。</li>
<li>ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。</li>
<li>ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。</li>
<li>ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。</li>
<li>ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。</li>
<li>ziplistDelete: 删除指定的数据项。</li>
<li>ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。</li>
<li>ziplistLen: 计算ziplist的长度（即包含数据项的个数）。</li>
</ul>
<h3 id="hash与ziplist"><a href="#hash与ziplist" class="headerlink" title="hash与ziplist"></a>hash与ziplist</h3><p>hash是Redis中可以用来存储一个对象结构的比较理想的数据类型。一个对象的各个属性，正好对应一个hash结构的各个field。</p>
<p>我们在网上很容易找到这样一些技术文章，它们会说存储一个对象，使用hash比string要节省内存。实际上这么说是有前提的，具体取决于对象怎么来存储。如果你把对象的多个属性存储到多个key上（各个属性值存成string），当然占的内存要多。但如果你采用一些序列化方法，比如Protocol Buffers，或者Apache Thrift，先把对象序列化为字节数组，然后再存入到Redis的string中，那么跟hash相比，哪一种更省内存，就不一定了。</p>
<p>当然，hash比序列化后再存入string的方式，在支持的操作命令上，还是有优势的：它既支持多个field同时存取（<code>hmset</code>/<code>hmget</code>），也支持按照某个特定的field单独存取（<code>hset</code>/<code>hget</code>）。</p>
<p>实际上，hash随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。<strong>在field比较少，各个value值也比较小的时候，hash采用ziplist来实现；而随着field增多和value值增大，hash可能会变成dict来实现</strong>。当hash底层变成dict来实现的时候，它的存储效率就没法跟那些序列化方式相比了。</p>
<p>当我们为某个key第一次执行 <code>hset key field value</code> 命令的时候，Redis会创建一个hash结构，<strong>这个新创建的hash底层就是一个ziplist</strong>。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">robj *create<span class="constructor">HashObject(<span class="params">void</span>)</span> &#123;</span><br><span class="line">    unsigned <span class="built_in">char</span> *zl = ziplist<span class="constructor">New()</span>;</span><br><span class="line">    robj *o = create<span class="constructor">Object(OBJ_HASH, <span class="params">zl</span>)</span>;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>createHashObject</code>函数，出自object.c，它负责的任务就是创建一个新的hash结构。可以看出，它创建了一个<code>type = OBJ_HASH</code>但<code>encoding = OBJ_ENCODING_ZIPLIST</code>的robj对象。</p>
<p>实际上，本文前面给出的那个ziplist实例，就是由如下两个命令构建出来的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">hset user:<span class="number">100</span> name tielei</span><br><span class="line">hset user:<span class="number">100</span> age <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>每执行一次hset命令，插入的field和value分别作为一个新的数据项插入到ziplist中（即每次hset产生两个数据项）。</p>
<p>当随着数据的插入，hash底层的这个ziplist就可能会转成dict。那么到底插入多少才会转呢？</p>
<p>还记得本文开头提到的两个Redis配置吗？</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">hash-<span class="built_in">max</span>-ziplist-entries <span class="number">512</span></span><br><span class="line">hash-<span class="built_in">max</span>-ziplist-<span class="built_in">value</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成dict：</p>
<ul>
<li>当hash中的数据项（即field-value对）的数目超过512的时候，也就是ziplist数据项超过1024的时候（请参考t_hash.c中的<code>hashTypeSet</code>函数）。</li>
<li>当hash中插入的任意一个value的长度超过了64的时候（请参考t_hash.c中的<code>hashTypeTryConversion</code>函数）。</li>
<li>Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</li>
<li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能。</li>
<li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li>
<li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>总之，ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构并不擅长做修改操作。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(5)-quicklist</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-quicklist/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
Redis对外暴露的list数据类型，它底层实现所依赖的内部数据结构就是`quicklist`。

<p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-max-ziplist-size</span> -2</span><br><span class="line"><span class="built_in">list-compress-depth</span> 0</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>注：本文讨论的quicklist实现基于Redis源码的3.2分支。</p>
<h3 id="quicklist概述"><a href="#quicklist概述" class="headerlink" title="quicklist概述"></a>quicklist概述</h3><p>Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：</p>
<ul>
<li>lpush: 在左侧（即列表头部）插入数据。</li>
<li>rpop: 在右侧（即列表尾部）删除数据。</li>
<li>rpush: 在右侧（即列表尾部）插入数据。</li>
<li>lpop: 在左侧（即列表头部）删除数据。</li>
</ul>
<p>这些操作都是O(1)时间复杂度的。</p>
<p>当然，list也支持在任意中间位置的存取操作，比如lindex和linsert，但它们都需要对list进行遍历，所以时间复杂度较高，为O(N)。</p>
<p>概况起来，list具有这样的一些特点：它是一个能维持数据项先后顺序的列表（各个数据项的先后顺序由插入位置决定），便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。这不正是一个双向链表所具有的特点吗？</p>
<p>list的内部实现quicklist正是一个双向链表。在quicklist.c的文件头部注释中，是这样描述quicklist的：</p>
<blockquote>
<p>A doubly linked list of ziplists</p>
</blockquote>
<p>它确实是一个双向链表，而且是一个ziplist的双向链表。<strong>quicklist的每个节点都是一个ziplist</strong>。</p>
<p><code>ziplist</code>本身也是一个能维持数据项先后顺序的列表（按插入位置），而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。</p>
<p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p>
<ul>
<li>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>
</ul>
<p>于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。</p>
<p>不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</p>
<p>这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：</p>
<ul>
<li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。</li>
<li>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</li>
</ul>
<p>可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数<code>list-max-ziplist-size</code>，就是为了让使用者可以来根据自己的情况进行调整。</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-max-ziplist-size</span> -2</span><br></pre></td></tr></table></figure>
<p>我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。</p>
<ul>
<li>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</li>
<li>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：<ul>
<li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li>
<li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li>
<li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</li>
<li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li>
<li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li>
</ul>
</li>
</ul>
<p>另外，list的设计目标是能够用来存储很长的数据列表的。比如，Redis官网给出的这个教程：Writing a simple Twitter clone with PHP and Redis，就是使用list来存储类似Twitter的timeline数据。</p>
<p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。Redis的配置参数<code>list-compress-depth</code>就是用来完成这个设置的。</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-compress-depth</span> 0</span><br></pre></td></tr></table></figure>
<p>这个参数表示一个quicklist两端不被压缩的节点个数。注：<em>这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</em></p>
<p>参数list-compress-depth的取值含义如下：</p>
<ul>
<li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li>
<li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li>
<li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li>
<li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li>
<li>依此类推…</li>
</ul>
<p>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。<br>Redis对于quicklist内部节点的压缩算法，采用的LZF——一种无损压缩算法。</p>
<h3 id="quicklist的数据结构定义"><a href="#quicklist的数据结构定义" class="headerlink" title="quicklist的数据结构定义"></a>quicklist的数据结构定义</h3><p>quicklist相关的数据结构定义可以在quicklist.h中找到：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> len;           <span class="comment">/* number of quicklistNodes */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">fill</span> : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<p>quicklistNode结构代表quicklist的一个节点，其中各个字段的含义如下：</p>
<ul>
<li>prev: 指向链表前一个节点的指针。</li>
<li>next: 指向链表后一个节点的指针。</li>
<li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li>
<li>sz: 表示zl指向的ziplist的总大小（包括<code>zlbytes</code>, <code>zltail</code>, <code>zllen</code>, <code>zlend</code>和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li>
<li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li>
<li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li>
<li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li>
<li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li>
<li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li>
<li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li>
</ul>
<p>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p>
<ul>
<li>sz: 表示压缩后的ziplist大小。</li>
<li>compressed: 是个柔性数组（flexible array member），存放压缩后的ziplist字节数组。</li>
</ul>
<p>真正表示quicklist的数据结构是同名的quicklist这个struct：</p>
<ul>
<li>head: 指向头节点（左侧第一个节点）的指针。</li>
<li>tail: 指向尾节点（右侧第一个节点）的指针。</li>
<li>count: 所有ziplist数据项的个数总和。</li>
<li>len: quicklist节点的个数。</li>
<li>fill: 16bit，ziplist大小设置，存放<code>list-max-ziplist-size</code>参数的值。</li>
<li>compress: 16bit，节点压缩深度设置，存放<code>list-compress-depth</code>参数的值。<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5-quicklist/redis_quicklist_structure.png" alt="redis_quicklist_structure"></li>
</ul>
<p>上图是一个quicklist的结构图举例。图中例子对应的ziplist大小配置和节点压缩深度配置，如下：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list-max-ziplist-size</span> 3</span><br><span class="line"><span class="built_in">list-compress-depth</span> 2</span><br></pre></td></tr></table></figure>
<p>这个例子中我们需要注意的几点是：</p>
<ul>
<li>两端各有2个橙黄色的节点，是没有被压缩的。它们的数据指针zl指向真正的ziplist。中间的其它节点是被压缩过的，它们的数据指针zl指向被压缩后的ziplist结构，即一个quicklistLZF结构。</li>
<li>左侧头节点上的ziplist里有2项数据，右侧尾节点上的ziplist里有1项数据，中间其它节点上的ziplist里都有3项数据（包括压缩的节点内部）。这表示在表的两端执行过多次push和pop操作后的一个状态。</li>
</ul>
<p>现在我们来大概计算一下quicklistNode结构中的count字段这16bit是否够用。<br>我们已经知道，ziplist大小受到<code>list-max-ziplist-size</code>参数的限制。按照正值和负值有两种情况：</p>
<ul>
<li>当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。</li>
<li>当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。</li>
</ul>
<p>实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。</p>
<h3 id="quicklist的创建"><a href="#quicklist的创建" class="headerlink" title="quicklist的创建"></a>quicklist的创建</h3><p>当我们使用<code>lpush</code>或<code>rpush</code>命令第一次向一个不存在的list里面插入数据的时候，Redis会首先调用<code>quicklistCreate</code>接口创建一个空的quicklist。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">quicklist *quicklistCreate(void) &#123;</span><br><span class="line">    struct quicklist *quicklist;</span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(sizeof(*quicklist));</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span><span class="function"><span class="title">head</span> = quicklist-&gt;</span>tail = NULL;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>len = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>compress = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>fill = -<span class="number">2</span>;</span><br><span class="line">    return quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在很多介绍数据结构的书上，实现双向链表的时候经常会多增加一个空余的头节点，主要是为了插入和删除操作的方便。从上面quicklistCreate的代码可以看出，<strong>quicklist是一个不包含空余头节点的双向链表（head和tail都初始化为NULL）</strong>。</p>
<h3 id="quicklist的push操作"><a href="#quicklist的push操作" class="headerlink" title="quicklist的push操作"></a>quicklist的push操作</h3><p>quicklist的push操作是调用<code>quicklistPush</code>来实现的。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">void quicklistPush(quicklist *quicklist, void *value, const size_t sz,</span><br><span class="line">                   int <span class="keyword">where</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">where</span> == QUICKLIST_HEAD) &#123;</span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">where</span> == QUICKLIST_TAIL) &#123;</span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add new entry to head node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing head.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new head created. */</span></span><br><span class="line">int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    <span class="function"><span class="title">quicklistNode</span> *orig_head = quicklist-&gt;</span>head;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _<span class="function"><span class="title">quicklistNodeAllowInsert</span>(quicklist-&gt;</span><span class="function"><span class="title">head</span>, quicklist-&gt;</span>fill, sz))) &#123;</span><br><span class="line">        <span class="function"><span class="title">quicklist</span>-&gt;</span><span class="function"><span class="title">head</span>-&gt;</span>zl =</span><br><span class="line">            <span class="function"><span class="title">ziplistPush</span>(quicklist-&gt;</span><span class="function"><span class="title">head</span>-&gt;</span>zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        <span class="function"><span class="title">quicklistNodeUpdateSz</span>(quicklist-&gt;</span>head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="function"><span class="title">node</span>-&gt;</span>zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _<span class="function"><span class="title">quicklistInsertNodeBefore</span>(quicklist, quicklist-&gt;</span>head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span><span class="function"><span class="title">head</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">return</span> (orig_head != quicklist-&gt;</span>head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Add new entry to tail node of quicklist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns 0 if used existing tail.</span></span><br><span class="line"><span class="comment"> * Returns 1 if new tail created. */</span></span><br><span class="line">int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    <span class="function"><span class="title">quicklistNode</span> *orig_tail = quicklist-&gt;</span>tail;</span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _<span class="function"><span class="title">quicklistNodeAllowInsert</span>(quicklist-&gt;</span><span class="function"><span class="title">tail</span>, quicklist-&gt;</span>fill, sz))) &#123;</span><br><span class="line">        <span class="function"><span class="title">quicklist</span>-&gt;</span><span class="function"><span class="title">tail</span>-&gt;</span>zl =</span><br><span class="line">            <span class="function"><span class="title">ziplistPush</span>(quicklist-&gt;</span><span class="function"><span class="title">tail</span>-&gt;</span>zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        <span class="function"><span class="title">quicklistNodeUpdateSz</span>(quicklist-&gt;</span>tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        <span class="function"><span class="title">node</span>-&gt;</span>zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _<span class="function"><span class="title">quicklistInsertNodeAfter</span>(quicklist, quicklist-&gt;</span>tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">quicklist</span>-&gt;</span><span class="function"><span class="title">tail</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">return</span> (orig_tail != quicklist-&gt;</span>tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是在头部还是尾部插入数据，都包含两种情况：</p>
<ul>
<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即<code>_quicklistNodeAllowInsert</code>返回1），那么新数据被直接插入到ziplist中（调用<code>ziplistPush</code>）。</li>
<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用<code>_quicklistInsertNodeAfter</code>）。</li>
</ul>
<p>在<code>_quicklistInsertNodeAfter</code>的实现中，还会根据<code>list-compress-depth</code>的配置将里面的节点进行压缩。它的实现比较繁琐，我们这里就不展开讨论了。</p>
<h3 id="quicklist的其它操作"><a href="#quicklist的其它操作" class="headerlink" title="quicklist的其它操作"></a>quicklist的其它操作</h3><p>quicklist的操作较多，且实现细节都比较繁杂，这里就不一一分析源码了，我们简单介绍一些比较重要的操作。</p>
<p>quicklist的pop操作是调用<code>quicklistPopCustom</code>来实现的。quicklistPopCustom的实现过程基本上跟<code>quicklistPush</code>相反，先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。删除后还可能涉及到里面节点的解压缩问题。</p>
<p>quicklist不仅实现了从头部或尾部插入，也实现了从任意指定的位置插入<code>。quicklistInsertAfter</code>和<code>quicklistInsertBefore</code>就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，情况比较复杂，有众多的逻辑分支。</p>
<ul>
<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>
<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>
</ul>
<p><code>quicklistSetOptions</code>用于设置ziplist大小配置参数（<code>list-max-ziplist-size</code>）和节点压缩深度配置参数（<code>list-compress-depth</code>）。代码比较简单，就是将相应的值分别设置给quicklist结构的fill字段和compress字段。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(6)-skiplist</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">
Redis里面使用skiplist是为了实现`sorted set`这种对外的数据结构。sorted set提供的操作非常丰富，可以满足非常多的应用场景。

<p>我们将大体分成三个部分进行介绍：</p>
<ul>
<li>介绍经典的skiplist数据结构，并进行简单的算法分析。这一部分的介绍，与Redis没有直接关系。我会尝试尽量使用通俗易懂的语言进行描述。</li>
<li>讨论Redis里的skiplist的具体实现。为了支持sorted set本身的一些要求，在经典的skiplist基础上，Redis里的相应实现做了若干改动。</li>
<li>讨论sorted set是如何在skiplist, dict和ziplist基础上构建起来的。</li>
</ul>
<p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">zset-<span class="built_in">max</span>-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-<span class="built_in">max</span>-ziplist-<span class="built_in">value</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p>
<a id="more"></a>
<h3 id="Skip-List数据结构简介"><a href="#Skip-List数据结构简介" class="headerlink" title="Skip List数据结构简介"></a>Skip List数据结构简介</h3><p>skiplist本质上也是一种查找结构，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p>
<p>一般查找问题的解法分为两个大类：一个是基于各种平衡树，一个是基于哈希表。但skiplist却比较特殊，它没法归属到这两大类里面。</p>
<p><strong>skiplist</strong>，顾名思义，首先它是一个list。实际上，它是在有序链表的基础上发展起来的。</p>
<p>我们先来看一个有序链表，如下图（最左侧的灰色节点表示一个空的头结点）：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/sorted_linked_list.png" alt="sorted_linked_list"></p>
<p>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。</p>
<p>假如我们每相邻两个节点增加一个指针，让指针指向<code>下下个节点</code>，如下图：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/skip2node_linked_list.png" alt="skip2node_linked_list"></p>
<p>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：</p>
<p><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/search_path_on_skip2node_list.png" alt="search_path_on_skip2node_list"></p>
<ul>
<li>23首先和7比较，再和19比较，比它们都大，继续向后比较。</li>
<li>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。</li>
<li>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。</li>
</ul>
<p>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p>
<p>利用同样的方式，我们可以在上层新产生的链表上，继续为每相邻的两个节点增加一个指针，从而产生第三层链表。如下图：</p>
<p><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/skip2node_level3_linked_list.png" alt="skip2node_level3_linked_list"></p>
<p>在这个新的三层链表结构上，如果我们还是查找23，那么沿着最上层链表首先要比较的是19，发现23比19大，接下来我们就知道只需要到19的后面去继续查找，从而一下子跳过了19前面的所有节点。可以想象，当链表足够长的时候，这种多层链表的查找方式能让我们跳过很多下层节点，大大加快查找的速度。</p>
<p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：</p>
<p><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/skiplist_insertions.png" alt="skiplist_insertions"></p>
<p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p>
<p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
<p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p>
<p><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/search_path_on_skiplist.png" alt="search_path_on_skiplist"></p>
<p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p>
<p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p>
<p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p>
<p>但是，如果你是第一次接触skiplist，那么一定会产生一个疑问：节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？为了回答这个疑问，我们需要分析skiplist的统计性能。</p>
<p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ul>
<li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li>
<li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li>
<li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li>
</ul>
<p>这个计算随机层数的伪码如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    <span class="keyword">level</span> := <span class="number">1</span></span><br><span class="line">    // random()返回一个[<span class="number">0.</span>.<span class="number">.1</span>)的随机数</span><br><span class="line">    <span class="keyword">while</span> random() &lt; p <span class="keyword">and</span> <span class="keyword">level</span> &lt; MaxLevel <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">level</span> := <span class="keyword">level</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">level</span></span><br></pre></td></tr></table></figure>
<p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">p</span> = <span class="number">1</span>/<span class="number">4</span></span><br><span class="line"><span class="attr">MaxLevel</span> = <span class="number">32</span></span><br></pre></td></tr></table></figure>

<h3 id="skiplist的算法性能分析"><a href="#skiplist的算法性能分析" class="headerlink" title="skiplist的算法性能分析"></a>skiplist的算法性能分析</h3><p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p>
<p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p>
<ul>
<li>节点层数至少为1。而大于1的节点层数，满足一个概率分布。</li>
<li>节点层数恰好等于1的概率为1-p。</li>
<li>节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</li>
<li>节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</li>
<li>节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</li>
<li>……<br>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/skiplist_avg_level.png" alt="skiplist_avg_level"></li>
</ul>
<p>现在很容易计算出：</p>
<ul>
<li>当p=1/2时，每个节点所包含的平均指针数目为2；</li>
<li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li>
</ul>
<p>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p>
<p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p>
<p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p>
<p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p>
<ul>
<li>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。</li>
<li>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。<br>这两种情形如下图所示：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/skiplist_backwards.png" alt="skiplist_backwards"></li>
</ul>
<p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望），那么：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">C</span><span class="params">(<span class="number">0</span>)</span></span>=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">C</span><span class="params">(k)</span></span>=(<span class="number">1</span>-p)×(上图中情况b的查找长度) + p×(上图中情况c的查找长度)</span><br></pre></td></tr></table></figure>
<p>代入，得到一个差分方程并化简：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">C(<span class="name">k</span>)=(<span class="number">1</span>-p)(<span class="name">C</span>(<span class="name">k</span>)<span class="number">+1</span>) + p(<span class="name">C</span>(<span class="name">k-1</span>)<span class="number">+1</span>)</span><br><span class="line">C(<span class="name">k</span>)=1/p+C(<span class="name">k-1</span>)</span><br><span class="line">C(<span class="name">k</span>)=k/p</span><br></pre></td></tr></table></figure>
<p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p>
<p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p>
<ul>
<li>第1层链表固定有n个节点；</li>
<li>第2层链表平均有n*p个节点；</li>
<li>第3层链表平均有n*p2个节点；</li>
<li>…</li>
</ul>
<p>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p>
<p>综上，粗略来计算的话，平均查找长度约等于：</p>
<ul>
<li>C(log1/pn-1)=(log1/pn-1)/p<br>即，平均时间复杂度为**O(log n)**。</li>
</ul>
<p>当然，这里的时间复杂度分析还是比较粗略的。比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；还可能先到达最高层的节点，然后沿着最高层链表一路向左。但这些细节不影响平均时间复杂度的最后结果。另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的</p>
<h3 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h3><ul>
<li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li>
<li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ul>
<h3 id="Redis中的skiplist实现"><a href="#Redis中的skiplist实现" class="headerlink" title="Redis中的skiplist实现"></a>Redis中的skiplist实现</h3><p>在Redis中，skiplist被用于实现暴露给外部的一个数据结构：sorted set。准确地说，<strong>sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict</strong>。这几个数据结构的关系，我们下一章再讨论。现在，我们先花点时间把sorted set的关键命令看一下。这些命令对于Redis里skiplist的实现，有重要的影响。</p>
<p>sorted set是一个有序的数据集合，对于像类似排行榜这样的应用场景特别适合。</p>
<p>现在我们来看一个例子，用sorted set来存储代数课（algebra）的成绩表。原始数据如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Alice</span> <span class="number">87</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">Bob</span> <span class="number">89</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">Charles</span> <span class="number">65</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">David</span> <span class="number">78</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">Emily</span> <span class="number">93</span>.<span class="number">5</span></span><br><span class="line"><span class="attribute">Fred</span> <span class="number">87</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>这份数据给出了每位同学的名字和分数。下面我们将这份数据存储到sorted set里面去：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/sorted_set_cmd_examples.png" alt="sorted_set_cmd_examples"></p>
<p>对于上面的这些命令，我们需要的注意的地方包括：</p>
<ul>
<li>前面的6个zadd命令，将6位同学的名字和分数(score)都输入到一个key值为algebra的sorted set里面了。注意Alice和Fred的分数相同，都是87.5分。</li>
<li>zrevrank命令查询Alice的排名（命令中的rev表示按照倒序排列，也就是从大到小），返回3。排在Alice前面的分别是Emily、Bob、Fred，而排名(rank)从0开始计数，所以Alice的排名是3。注意，其实Alice和Fred的分数相同，这种情况下sorted set会把分数相同的元素，按照字典顺序来排列。按照倒序，Fred排在了Alice的前面。</li>
<li>zscore命令查询了Charles对应的分数。</li>
<li>zrevrange命令查询了从大到小排名为0~3的4位同学。</li>
<li>zrevrangebyscore命令查询了分数在80.0和90.0之间的所有同学，并按分数从大到小排列。</li>
</ul>
<p>总结一下，sorted set中的每个元素主要表现出3个属性：</p>
<ul>
<li>数据本身（在前面的例子中我们把名字存成了数据）。</li>
<li>每个数据对应一个分数(score)。</li>
<li>根据分数大小和数据本身的字典排序，每个数据会产生一个排名(rank)。可以按正序或倒序。</li>
</ul>
<h3 id="Redis中skiplist实现的特殊性"><a href="#Redis中skiplist实现的特殊性" class="headerlink" title="Redis中skiplist实现的特殊性"></a>Redis中skiplist实现的特殊性</h3><p>我们简单分析一下前面出现的几个查询命令：</p>
<ul>
<li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li>
<li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li>
<li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li>
<li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</li>
</ul>
<p>实际上，Redis中sorted set的实现是这样的：</p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。</li>
<li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。简单来讲，<strong>dict用来查询数据到分数的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）</strong>。</li>
</ul>
<p>这里sorted set的构成我们在下一章还会再详细地讨论。现在我们集中精力来看一下sorted set与skiplist的关系，：</p>
<ul>
<li>zscore的查询，不是由skiplist来提供的，而是由那个dict来提供的。</li>
<li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。而且，根据排名的查找，时间复杂度也为O(log n)。</li>
<li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li>
<li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li>
</ul>
<p>前述的查询过程，也暗示了各个操作的时间复杂度：</p>
<ul>
<li>zscore只用查询一个dict，所以时间复杂度为O(1)</li>
<li>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以zrevrank的时间复杂度为O(log n)，而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。</li>
</ul>
<p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p>
<ul>
<li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li>
<li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li>
<li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li>
<li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li>
</ul>
<h3 id="skiplist的数据结构定义"><a href="#skiplist的数据结构定义" class="headerlink" title="skiplist的数据结构定义"></a>skiplist的数据结构定义</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>
<p>这段代码出自server.h，我们来简要分析一下：</p>
<ul>
<li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。</li>
<li>zskiplistNode定义了skiplist的节点结构。<ul>
<li>obj字段存放的是节点数据，它的类型是一个string robj。本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。这样做的目的应该是为了方便在查找的时候对数据进行字典序的比较，而且，skiplist里的数据部分是数字的可能性也比较小。</li>
<li>score字段是数据对应的分数。</li>
<li>backward字段是指向链表前一个节点的指针（前向指针）。节点只有1个前向指针，所以只有第1层链表是一个双向链表。</li>
<li><code>level[]</code>存放指向各层链表后一个节点的指针（后向指针）。每层对应1个后向指针，用forward字段表示。另外，每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点。span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。需要注意的是，<code>level[]</code>是一个柔性数组（flexible array member），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。</li>
</ul>
</li>
<li>zskiplist定义了真正的skiplist结构，它包含：<ul>
<li>头指针header和尾指针tail。</li>
<li>链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中。</li>
<li>level表示skiplist的总层数，即所有节点层数的最大值。</li>
</ul>
</li>
</ul>
<p>下图以前面插入的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-skiplist/redis_skiplist_example.png" alt="redis_skiplist_example"></p>
<p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p>
<p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p>
<p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p>
<h3 id="Redis中的sorted-set"><a href="#Redis中的sorted-set" class="headerlink" title="Redis中的sorted set"></a>Redis中的sorted set</h3><p>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。</li>
<li>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li>
</ul>
<p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。ziplist就是由很多数据项组成的一大块连续内存。由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p>
<p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p>
<p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p>
<p>还记得本文开头提到的两个Redis配置吗？</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">zset-<span class="built_in">max</span>-ziplist-entries <span class="number">128</span></span><br><span class="line">zset-<span class="built_in">max</span>-ziplist-<span class="built_in">value</span> <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p>
<ul>
<li>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。</li>
<li>当sorted set中插入的任意一个数据的长度超过了64的时候。</li>
</ul>
<p>最后，zset结构的代码定义如下：</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> </span>&#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<h3 id="Redis为什么用skiplist而不用平衡树？"><a href="#Redis为什么用skiplist而不用平衡树？" class="headerlink" title="Redis为什么用skiplist而不用平衡树？"></a>Redis为什么用skiplist而不用平衡树？</h3><p>在前面我们对于skiplist和平衡树、哈希表的比较中，其实已经不难看出Redis里使用skiplist而不用平衡树的原因了。现在我们看看，对于这个问题，Redis的作者 @antirez 是怎么说的：</p>
<blockquote>
<p>There are a few reasons:</p>
<ol>
<li>They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then less memory intensive than btrees.</li>
<li>A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</li>
<li>They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内部数据结构(7)-intset</title>
    <url>/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-intset/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>Redis里面使用intset是为了实现集合(set)这种对外的数据结构。set结构类似于数学上的集合的概念，它包含的元素无序，且不能重复。Redis里的set结构还实现了基础的集合并、交、差的操作。与Redis对外暴露的其它数据结构类似，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。概括来讲，<strong>当set中添加的元素都是整型且元素数目较少时，set使用intset作为底层数据结构，否则，set使用dict作为底层数据结构。</strong></p>
<p>在本文中我们将大体分成三个部分进行介绍：</p>
<ul>
<li>集中介绍intset数据结构。</li>
<li>讨论set是如何在intset和dict基础上构建起来的。</li>
<li>集中讨论set的并、交、差的算法实现以及时间复杂度。注意，其中差集的计算在Redis中实现了两种算法。<a id="more"></a>

</li>
</ul>
<p>我们在讨论中还会涉及到一个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set-max-intset-entries</span> <span class="string">512</span></span><br></pre></td></tr></table></figure>

<p>注：本文讨论的代码实现基于Redis源码的3.2分支。</p>
<h3 id="intset数据结构简介"><a href="#intset数据结构简介" class="headerlink" title="intset数据结构简介"></a>intset数据结构简介</h3><p>intset顾名思义，是由整数组成的集合。实际上，intset是一个由整数组成的有序集合，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。</p>
<p>intset的数据结构定义如下（出自intset.h和intset.c）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>
<p>各个字段含义如下：</p>
<ul>
<li>encoding: 数据编码，表示intset中的每个数据元素用几个字节来存储。它有三种可能的取值：INTSET_ENC_INT16表示每个元素用2个字节存储，INTSET_ENC_INT32表示每个元素用4个字节存储，INTSET_ENC_INT64表示每个元素用8个字节存储。因此，intset中存储的整数最多只能占用64bit。</li>
<li>length: 表示intset中的元素个数。encoding和length两个字段构成了intset的头部（header）。</li>
<li>contents: 是一个柔性数组（flexible array member），表示intset的header后面紧跟着数据元素。这个数组的总长度（即总字节数）等于encoding * length。柔性数组在Redis的很多数据结构的定义中都出现过（例如sds, quicklist, skiplist），用于表达一个偏移量。contents需要单独为其分配空间，这部分内存不包含在intset结构当中。</li>
</ul>
<p>其中需要注意的是，intset可能会随着数据的添加而改变它的数据编码：</p>
<ul>
<li>最开始，新创建的intset使用占内存最小的INTSET_ENC_INT16（值为2）作为数据编码。</li>
<li>每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。</li>
</ul>
<p>下图给出了一个添加数据的具体例子。<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-intset/redis_intset_add_example.png" alt="redis_intset_add_example"></p>
<p>在上图中：</p>
<ul>
<li>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。</li>
<li>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。</li>
<li>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</li>
<li>在添加每个元素的过程中，intset始终保持从小到大有序。</li>
<li>与ziplist类似，intset也是按小端（little endian）模式存储的（参见维基百科词条Endianness）。比如，在上图中intset添加完所有数据之后，表示encoding字段的4个字节应该解释成0x00000004，而第5个数据应该解释成0x000186A0 = 100000。</li>
</ul>
<p>intset与ziplist相比：</p>
<ul>
<li>ziplist可以存储任意二进制串，而intset只能存储整数。</li>
<li>ziplist是无序的，而intset是从小到大有序的。因此，在ziplist上查找只能遍历，而在intset上可以进行二分查找，性能更高。</li>
<li>ziplist可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段len），而intset只能整体使用一个统一的编码（encoding）。</li>
</ul>
<h3 id="intset的查找和添加操作"><a href="#intset的查找和添加操作" class="headerlink" title="intset的查找和添加操作"></a>intset的查找和添加操作</h3><p>要理解intset的一些实现细节，只需要关注intset的两个关键操作基本就可以了：查找（<code>intsetFind</code>）和添加（<code>intsetAdd</code>）元素。</p>
<p>intsetFind的关键代码如下所示（出自intset.c）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uint</span>8_t <span class="built_in">int</span>setFind(<span class="built_in">int</span><span class="keyword">set</span> *<span class="keyword">is</span>, <span class="built_in">int</span>64_t value) &#123;</span><br><span class="line">    <span class="built_in">uint</span>8_t valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= <span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;encoding) &amp;&amp; <span class="built_in">int</span>setSearch(<span class="keyword">is</span>,value,NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="built_in">uint</span>8_t <span class="built_in">int</span>setSearch(<span class="built_in">int</span><span class="keyword">set</span> *<span class="keyword">is</span>, <span class="built_in">int</span>64_t value, <span class="built_in">uint</span>32_t *pos) &#123;</span><br><span class="line">    <span class="built_in">int</span> min = <span class="number">0</span>, max = <span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">int</span>64_t cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(<span class="keyword">is</span>,<span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length)<span class="number">-1</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(<span class="keyword">is</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((unsigned <span class="built_in">int</span>)min + (unsigned <span class="built_in">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(<span class="keyword">is</span>,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于以上代码，我们需要注意的地方包括：</p>
<ul>
<li>intsetFind在指定的intset中查找指定的元素value，找到返回1，没找到返回0。</li>
<li>_intsetValueEncoding函数会根据要查找的value落在哪个范围而计算出相应的数据编码（即它应该用几个字节来存储）。</li>
<li>如果value所需的数据编码比当前intset的编码要大，则它肯定在当前intset所能存储的数据范围之外（特别大或特别小），所以这时会直接返回0；否则调用intsetSearch执行一个二分查找算法。</li>
<li>intsetSearch在指定的intset中查找指定的元素value，如果找到，则返回1并且将参数pos指向找到的元素位置；如果没找到，则返回0并且将参数pos指向能插入该元素的位置。</li>
<li>intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：<ul>
<li>特殊处理intset为空的情况。</li>
<li>特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。</li>
<li>真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。</li>
</ul>
</li>
<li>代码中出现的intrev32ifbe是为了在需要的时候做大小端转换的。前面我们提到过，intset里的数据是按小端（little endian）模式存储的，因此在大端（big endian）机器上运行时，这里的intrev32ifbe会做相应的转换。</li>
<li>这个查找算法的总的时间复杂度为O(log n)。</li>
</ul>
<p>而intsetAdd的关键代码如下所示（出自intset.c）：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span><span class="keyword">set</span> *<span class="built_in">int</span>setAdd(<span class="built_in">int</span><span class="keyword">set</span> *<span class="keyword">is</span>, <span class="built_in">int</span>64_t value, <span class="built_in">uint</span>8_t *success) &#123;</span><br><span class="line">    <span class="built_in">uint</span>8_t valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="built_in">uint</span>32_t pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; <span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">/* This always succeeds, so we don&#x27;t need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>setUpgradeAndAdd(<span class="keyword">is</span>,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate &quot;pos&quot; with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">int</span>setSearch(<span class="keyword">is</span>,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">is</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">is</span> = <span class="built_in">int</span>setResize(<span class="keyword">is</span>,<span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; <span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length)) <span class="built_in">int</span>setMoveTail(<span class="keyword">is</span>,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(<span class="keyword">is</span>,pos,value);</span><br><span class="line">    <span class="keyword">is</span>-&gt;length = <span class="built_in">int</span>rev32ifbe(<span class="built_in">int</span>rev32ifbe(<span class="keyword">is</span>-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">is</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于以上代码，我们需要注意的地方包括：</p>
<ul>
<li>intsetAdd在intset中添加新元素value。如果value在添加前已经存在，则不会重复添加，这时参数success被置为0；如果value在原来intset中不存在，则将value插入到适当位置，这时参数success被置为0。</li>
<li>如果要添加的元素value所需的数据编码比当前intset的编码要大，那么则调用intsetUpgradeAndAdd将intset的编码进行升级后再插入value。</li>
<li>调用intsetSearch，如果能查到，则不会重复添加。</li>
<li>如果没查到，则调用intsetResize对intset进行内存扩充，使得它能够容纳新添加的元素。因为intset是一块连续空间，因此这个操作会引发内存的realloc（参见<a href="http://man.cx/realloc%EF%BC%89%E3%80%82%E8%BF%99%E6%9C%89%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E3%80%82%E5%90%8C%E6%97%B6%E8%B0%83%E7%94%A8intsetMoveTail%E5%B0%86%E5%BE%85%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%E5%90%8E%E9%9D%A2%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%9F%E4%B8%80%E5%90%91%E5%90%8E%E7%A7%BB%E5%8A%A81%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%8C%E8%BF%99%E4%B9%9F%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E3%80%82%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E6%98%AF%EF%BC%8C%E5%9C%A8intsetMoveTail%E4%B8%AD%E6%98%AF%E8%B0%83%E7%94%A8memmove%E5%AE%8C%E6%88%90%E8%BF%99%E6%AC%A1%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D%E7%9A%84%E3%80%82memmove%E4%BF%9D%E8%AF%81%E4%BA%86%E5%9C%A8%E6%8B%B7%E8%B4%9D%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%B8%8D%E4%BC%9A%E9%80%A0%E6%88%90%E6%95%B0%E6%8D%AE%E9%87%8D%E5%8F%A0%E6%88%96%E8%A6%86%E7%9B%96%EF%BC%8C%E5%85%B7%E4%BD%93%E5%8F%82%E8%A7%81http://man.cx/memmove%E3%80%82">http://man.cx/realloc）。这有可能带来一次数据拷贝。同时调用intsetMoveTail将待插入位置后面的元素统一向后移动1个位置，这也涉及到一次数据拷贝。值得注意的是，在intsetMoveTail中是调用memmove完成这次数据拷贝的。memmove保证了在拷贝过程中不会造成数据重叠或覆盖，具体参见http://man.cx/memmove。</a></li>
<li>intsetUpgradeAndAdd的实现中也会调用intsetResize来完成内存扩充。在进行编码升级时，intsetUpgradeAndAdd的实现会把原来intset中的每个元素取出来，再用新的编码重新写入新的位置。</li>
<li>注意一下intsetAdd的返回值，它返回一个新的intset指针。它可能与传入的intset指针is相同，也可能不同。调用方必须用这里返回的新的intset，替换之前传进来的旧的intset变量。类似这种接口使用模式，在Redis的实现代码中是很常见的，比如我们之前在介绍sds和ziplist的时候都碰到过类似的情况。</li>
<li>显然，这个intsetAdd算法总的时间复杂度为O(n)。</li>
</ul>
<h3 id="Redis的set"><a href="#Redis的set" class="headerlink" title="Redis的set"></a>Redis的set</h3><p>为了更好地理解Redis对外暴露的set数据结构，我们先看一下set的一些关键的命令。下面是一些命令举例：<br><img src="/2020/11/26/redis%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-intset/redis_set_cmd_example.png" alt="redis_set_cmd_example"></p>
<p>上面这些命令的含义：</p>
<ul>
<li>sadd用于分别向集合s1和s2中添加元素。添加的元素既有数字，也有非数字（”a”和”b”）。</li>
<li>sismember用于判断指定的元素是否在集合内存在。</li>
<li>sinter, sunion和sdiff分别用于计算集合的交集、并集和差集。</li>
</ul>
<p>set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。例如，具体到上述命令的执行过程中，集合s1的底层数据结构会发生如下变化：</p>
<ul>
<li>在开始执行完sadd s1 13 5之后，由于添加的都是比较小的整数，所以s1底层是一个intset，其数据编码encoding = 2。</li>
<li>在执行完sadd s1 32768 10 100000之后，s1底层仍然是一个intset，但其数据编码encoding从2升级到了4。</li>
<li>在执行完sadd s1 a b之后，由于添加的元素不再是数字，s1底层的实现会转成一个dict。</li>
</ul>
<p>dict是一个用于维护key和value映射关系的数据结构，那么当set底层用dict表示的时候，它的key和value分别是什么呢？实际上，key就是要添加的集合元素，而value是NULL。</p>
<p>除了前面提到的由于添加非数字元素造成集合底层由intset转成dict之外，还有两种情况可能造成这种转换：</p>
<ul>
<li>添加了一个数字，但它无法用64bit的有符号数来表达。intset能够表达的最大的整数范围为-264~264-1，因此，如果添加的数字超出了这个范围，这也会导致intset转成dict。</li>
<li>添加的集合元素个数超过了<code>set-max-intset-entries</code>配置的值的时候，也会导致intset转成dict（具体的触发条件参见t_set.c中的<code>setTypeAdd</code>相关代码）。</li>
</ul>
<p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p>
<p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p>
<h3 id="Redis-set的并、交、差算法"><a href="#Redis-set的并、交、差算法" class="headerlink" title="Redis set的并、交、差算法"></a>Redis set的并、交、差算法</h3><p>Redis set的并、交、差算法的实现代码，在t_set.c中。其中计算交集调用的是<code>sinterGenericCommand</code>，计算并集和差集调用的是<code>sunionDiffGenericCommand</code>。它们都能同时对多个（可以多于2个）集合进行运算。当对多个集合进行差集运算时，它表达的含义是：用第一个集合与第二个集合做差集，所得结果再与第三个集合做差集，依次向后类推。</p>
<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>计算交集的过程大概可以分为三部分：</p>
<ul>
<li>检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，则不用继续计算了，最终的交集就是空集。</li>
<li>对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。</li>
<li>对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。</li>
</ul>
<p>需要注意的是，上述第3步在集合中进行查找，对于intset和dict的存储来说时间复杂度分别是O(log n)和O(1)。但由于只有小集合才使用intset，所以可以粗略地认为intset的查找也是常数时间复杂度的。因此，如Redis官方文档上所说（<a href="http://redis.io/commands/sinter">http://redis.io/commands/sinter</a>），<code>sinter</code>命令的时间复杂度为：</p>
<blockquote>
<p>O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</p>
</blockquote>
<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。向集合中添加元素会自动去重。</p>
<p>由于要遍历所有集合的每个元素，所以Redis官方文档给出的sunion命令的时间复杂度为（<a href="http://redis.io/commands/sunion">http://redis.io/commands/sunion</a>）：</p>
<blockquote>
<p>O(N) where N is the total number of elements in all given sets.</p>
</blockquote>
<p>注意，这里同前面讨论交集计算一样，将元素插入到结果集合的过程，忽略intset的情况，认为时间复杂度为O(1)。</p>
<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>计算差集有两种可能的算法，它们的时间复杂度有所区别。</p>
<p>第一种算法：</p>
<ul>
<li>对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。</li>
</ul>
<p>这种算法的时间复杂度为*<em>O(N</em>M)**，其中N是第一个集合的元素个数，M是集合数目。</p>
<p>第二种算法：</p>
<ul>
<li>将第一个集合的所有元素都加入到一个中间集合中。</li>
<li>遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。</li>
<li>最后中间集合剩下的元素就构成了差集。</li>
</ul>
<p>这种算法的时间复杂度为**O(N)**，其中N是所有集合的元素个数总和。</p>
<p>在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。还有两点需要注意：</p>
<ul>
<li>在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。</li>
<li>如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。</li>
</ul>
<p>对于<code>sdiff</code>的时间复杂度，Redis官方文档（<a href="http://redis.io/commands/sdiff">http://redis.io/commands/sdiff</a>）只给出了第二种算法的结果，是不准确的。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis源码从哪里读起</title>
    <url>/2020/11/26/redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<p>Redis是用C语言实现的，首先，你当然应该从main函数开始读起。但我们在读的时候应该抓住一条主线，也就是当我们向Redis输入一条命令的时候，代码是如何一步步执行的。这样我们就可以先从外部观察，尝试执行一些命令，在了解了这些命令执行的外部表现之后，再钻进去看对应的源码是如何实现的。要想读懂这些代码，首先我们需要理解Redis的事件机制。而且，一旦理解了Redis的事件循环(Event Loop)的机制，我们还会搞明白一个有趣的问题：为什么Redis是单线程执行却能同时处理多个请求？（当然严格来说Redis运行起来并非只有一个线程，但除了主线程之外，Redis的其它线程只是起辅助作用，它们是一些在后台运行做异步耗时任务的线程）</p>
<p>从main函数开始，沿着代码执行路径，实际上我们可以一直追下去。</p>
<p>本文按照如下思路进行：</p>
<ul>
<li>先概括地介绍整个代码初始化流程（从main函数开始）和事件循环的结构；</li>
<li>再概括地介绍对于Redis命令请求的处理流程；</li>
<li>重点介绍事件机制；</li>
<li>对于前面介绍的各个代码处理流程，给出详细的代码调用关系，方便随时查阅；</li>
</ul>
<p>注：本文的分析基于Redis源码的5.0分支。</p>
<a id="more"></a>

<h3 id="初始化流程和事件循环概述"><a href="#初始化流程和事件循环概述" class="headerlink" title="初始化流程和事件循环概述"></a>初始化流程和事件循环概述</h3><p>Redis源码的main函数在源文件server.c中。main函数开始执行后的逻辑可以分为两个阶段：</p>
<ul>
<li>各种初始化（包括事件循环的初始化）；</li>
<li>执行事件循环。</li>
</ul>
<p>这两个执行阶段可以用下面的流程图来表达：<br><img src="/2020/11/26/redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/main_start_event_loop.png" alt="main_start_event_loop"></p>
<p>首先，我们看一下初始化阶段中的各个步骤：</p>
<ul>
<li><strong>配置加载和初始化</strong>。这一步表示Redis服务器基本数据结构和各种参数的初始化。在Redis源码中，Redis服务器是用一个叫做<code>redisServer</code>的struct来表达的，里面定义了Redis服务器赖以运行的各种参数，比如监听的端口号和文件描述符、当前连接的各个client端、Redis命令表(command table)配置、持久化相关的各种参数，等等，以及后面马上会讨论的事件循环结构。Redis服务器在运行时就是由一个<code>redisServer</code>类型的全局变量来表示的（变量名就叫<code>server</code>），这一步的初始化主要就是对于这个全局变量进行初始化。在整个初始化过程中，有一个需要特别关注的函数：<code>populateCommandTable</code>。它初始化了Redis命令表，通过它可以由任意一个Redis命令的名字查找该命令的配置信息（比如该命令接收的命令参数个数、执行函数入口等）。在本文的第二部分，我们将会一起来看一看如何从接收一个Redis命令的请求开始，一步步执行到来查阅这个命令表，从而找到该命令的执行入口。另外，这一步中还有一个值得一提的地方：在对全局的<code>redisServer</code>结构进行了初始化之后，还需要从配置文件（redis.conf）中加载配置。这个过程可能覆盖掉之前初始化过的<code>redisServer</code>结构中的某些参数。换句话说，就是先经过一轮初始化，保证Redis的各个内部数据结构以及参数都有缺省值，然后再从配置文件中加载自定义的配置。</li>
<li><strong>创建事件循环</strong>。在Redis中，事件循环是用一个叫<code>aeEventLoop</code>的struct来表示的。「创建事件循环」这一步主要就是创建一个<code>aeEventLoop</code>结构，并存储到<code>server</code>全局变量（即前面提到的<code>redisServer</code>类型的结构）中。另外，事件循环的执行依赖系统底层的I/O多路复用机制(I/O multiplexing)，比如Linux系统上的epoll机制[1]。因此，这一步也包含对于底层I/O多路复用机制的初始化（调用系统API）。</li>
<li><strong>开始socket监听</strong>。服务器程序需要监听才能收到请求。根据配置，这一步可能会打开两种监听：对于TCP连接的监听和对于Unix domain socket[2]的监听。「Unix domain socket」是一种高效的进程间通信(IPC[3])机制，在POSIX规范[4]中也有明确的定义[5]，用于在同一台主机上的两个不同进程之间进行通信，比使用TCP协议性能更高（因为省去了协议栈的开销）。当使用Redis客户端连接同一台机器上的Redis服务器时，可以选择使用「Unix domain socket」进行连接。但不管是哪一种监听，程序都会获得文件描述符，并存储到<code>server</code>全局变量中。对于TCP的监听来说，由于监听的IP地址和端口可以绑定多个，因此获得的用于监听TCP连接的文件描述符也可以包含多个。后面，程序就可以拿这一步获得的文件描述符去注册I/O事件回调了。</li>
<li><strong>注册timer事件回调</strong>。Redis作为一个单线程(single-threaded)的程序，它如果想调度一些异步执行的任务，比如周期性地执行过期key的回收动作，除了依赖事件循环机制，没有其它的办法。这一步就是向前面刚刚创建好的事件循环中注册一个timer事件，并配置成可以周期性地执行一个回调函数：<code>serverCron</code>。由于Redis只有一个主线程，因此这个函数周期性的执行也是在这个线程内，它由事件循环来驱动（即在合适的时机调用），但不影响同一个线程上其它逻辑的执行（相当于按时间分片了）。<code>serverCron</code>函数到底做了什么呢？实际上，它除了周期性地执行过期key的回收动作，还执行了很多其它任务，比如主从重连、Cluster节点间的重连、BGSAVE和AOF rewrite的触发执行，等等。这个不是本文的重点，这里就不展开描述了。</li>
<li><strong>注册I/O事件回调</strong>。Redis服务端最主要的工作就是监听I/O事件，从中分析出来自客户端的命令请求，执行命令，然后返回响应结果。对于I/O事件的监听，自然也是依赖事件循环。前面提到过，Redis可以打开两种监听：对于TCP连接的监听和对于Unix domain socket的监听。因此，这里就包含对于这两种I/O事件的回调的注册，两个回调函数分别是<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>。对于来自Redis客户端的请求的处理，就会走到这两个函数中去。我们在下一部分就会讨论到这个处理过程。另外，其实Redis在这里还会注册一个I/O事件，用于通过管道(pipe[6])机制与module进行双向通信。这个也不是本文的重点，我们暂时忽略它。</li>
<li><strong>初始化后台线程</strong>。Redis会创建一些额外的线程，在后台运行，专门用于处理一些耗时的并且可以被延迟执行的任务（一般是一些清理工作）。在Redis里面这些后台线程被称为bio(Background I/O service)。它们负责的任务包括：可以延迟执行的文件关闭操作(比如unlink命令的执行)，AOF的持久化写库操作(即fsync调用，但注意只有可以被延迟执行的fsync操作才在后台线程执行)，还有一些大key的清除操作(比如flushdb async命令的执行)。可见bio这个名字有点名不副实，它做的事情不一定跟I/O有关。对于这些后台线程，我们可能还会产生一个疑问：前面的初始化过程，已经注册了一个timer事件回调，即<code>serverCron</code>函数，按说后台线程执行的这些任务似乎也可以放在<code>serverCron</code>中去执行。因为<code>serverCron</code>函数也是可以用来执行后台任务的。实际上这样做是不行的。前面我们已经提到过，<code>serverCron</code>由事件循环来驱动，执行还是在Redis主线程上，相当于和主线程上执行的其它操作（主要是对于命令请求的执行）按时间进行分片了。这样的话，<code>serverCron</code>里面就不能执行过于耗时的操作，否则它就会影响Redis执行命令的响应时间。因此，对于耗时的、并且可以被延迟执行的任务，就只能放到单独的线程中去执行了。</li>
<li><strong>启动事件循环</strong>。前面创建好了事件循环的结构，但还没有真正进入循环的逻辑。过了这一步，事件循环就运行起来，驱动前面注册的timer事件回调和I/O事件回调不断执行。</li>
</ul>
<p>注意：Redis服务器的初始化其实还要完成很多很多事，比如加载数据到内存，Cluster集群的初始化，module的初始化，等等。但为了简化，上面讨论的初始化流程，只列出了我们当前关注的步骤。本文关注的是由事件驱动的整个运行机制以及跟命令执行直接相关的部分，因此我们暂时忽略掉其它不太相关的步骤。</p>
<p>现在，我们继续去讨论上面流程图中的第二个阶段：事件循环。</p>
<p>我们先想一下为什么这里需要一个循环。</p>
<p>一个程序启动后，如果没有循环，那么它从第一条指令一直执行到最后一条指令，然后就只能退出了。而Redis作为一个服务端程序，是要等着客户端不停地发来请求然后做相应的处理，不能自己执行完就退出了。因此，Redis启动后必定要进入一个无限循环。显然，程序在每一次的循环执行中，如果有事件（包括客户端请求的I/O事件）发生，就会去处理这些事件。但如果没有事件发生呢？程序显然也不应该空转，而是应该等待，把整个循环阻塞住。这里的等待，就是上面流程图里的「等待事件发生」这个步骤。那么，当整个循环被阻塞住之后，什么时候再恢复执行呢？自然是等待的事件发生的时候，程序被重新唤醒，循环继续下去。这里需要的等待和唤醒操作，怎么实现呢？它们都需要依赖系统的能力才能做到（我们在文章第三部分会详细介绍）。</p>
<p>实际上，这种事件循环机制，对于开发过手机客户端的同学来说，是非常常见且基础的机制。比如跑在iOS/Android上面的App，这些程序都有一个消息循环，负责等待各种UI事件（点击、滑动等）的发生，然后进行处理。同理，对应到服务端，这个循环的原理可以认为差不多，只是等待和处理的事件变成是I/O事件了。另外，除了I/O事件，整个系统在运行过程中肯定还需要根据时间来调度执行一些任务，比如延迟100毫秒再执行某个操作，或者周期性地每隔1秒执行某个任务，这就需要等待和处理另外一种事件——timer事件。</p>
<p>timer事件和I/O事件是两种截然不同的事件，如何由事件循环来统一调度呢？假设事件循环在空闲的时候去等待I/O事件的发生，那么有可能一个timer事件先发生了，这时事件循环就没有被及时唤醒（仍在等待I/O事件）；反之，如果事件循环在等待timer事件，而一个I/O事件先发生了，那么同样没能够被及时唤醒。因此，我们必须有一种机制能够同时等待这两种事件的发生。而恰好，一些系统的API可以做到这一点（比如我们前面提到的epoll机制）。</p>
<p>前面流程图的第二阶段已经比较清楚地表达出了事件循环的执行流程。在这里我们对于其中一些步骤需要关注的地方做一些补充说明：</p>
<ul>
<li><strong>查找最近的timer事件</strong>。如前所述，事件循环需要等待timer和I/O两种事件。对于I/O事件，只需要明确要等待的是哪些文件描述符就可以了；而对于timer事件，还需要经过一番比较，明确在当前这一轮循环中需要等待多长时间。由于系统运行过程中可能注册多个timer事件回调，比如先要求在100毫秒后执行一个回调，同时又要求在200毫秒后执行另一个回调，这就要求事件循环在它的每一轮执行之前，首先要找出最近需要执行的那次timer事件。这样事件循环在接下来的等待中就知道该等待多长时间（在这个例子中，我们需要等待100毫秒）。</li>
<li><strong>等待事件发生</strong>。这一步我们需要能够同时等待timer和I/O两种事件的发生。要做到这一点，我们依赖系统底层的I/O多路复用机制(I/O multiplexing)。这种机制一般是这样设计的：它允许我们针对多个文件描述符来等待对应的I/O事件发生，并同时可以指定一个最长的阻塞超时时间。如果在这段阻塞时间内，有I/O事件发生，那么程序会被唤醒继续执行；如果一直没有I/O事件发生，而是指定的时间先超时了，那么程序也会被唤醒。对于timer事件的等待，就是依靠这里的超时机制。当然，这里的超时时间也可以指定成无限长，这就相当于只等待I/O事件。我们再看一下上一步查找最近的timer事件，查找完之后可能有三种结果，因此这一步等待也可能出现三种对应的情况：<ul>
<li>第一种情况，查找到了一个最近的timer事件，它要求在未来某一个时刻触发。那么，这一步只需要把这个未来时刻转换成阻塞超时时间即可。</li>
<li>第二种情况，查找到了一个最近的timer事件，但它要求的时刻已经过去了。那么，这时候它应该立刻被触发，而不应该再有任何等待。当然，在实现的时候还是调用了事件等待的API，只是把超时事件设置成0就可以达到这个效果。</li>
<li>第三种情况，没有查找到任何注册的timer事件。那么，这时候应该把超时时间设置成无限长。接下来只有I/O事件发生才能唤醒。</li>
</ul>
</li>
<li><strong>判断有I/O事件发生还是超时</strong>。这里是程序从上一步（可能的）阻塞状态中恢复后执行的判断逻辑。如果是I/O事件发生了，那么先执行I/O事件回调，然后根据需要把到期的timer事件的回调也执行掉（如果有的话）；如果是超时先发生了，那么表示只有timer事件需要触发（没有I/O事件发生），那么就直接把到期的timer事件的回调执行掉。</li>
<li><strong>执行I/O事件回调</strong>。我们前面提到的对于TCP连接的监听和对于Unix domain socket的监听，这两种I/O事件的回调函数<code>acceptTcpHandler</code>和<code>acceptUnixHandler</code>，就是在这一步被调用的。</li>
<li><strong>执行timer事件回调</strong>。我们前面提到的周期性的回调函数<code>serverCron</code>，就是在这一步被调用的。一般情况下，一个timer事件被处理后，它就会被从队列中删除，不会再次执行了。但<code>serverCron</code>却是被周期性调用的，这是怎么回事呢？这是因为Redis对于timer事件回调的处理设计了一个小机制：timer事件的回调函数可以返回一个需要下次执行的毫秒数。如果返回值是正常的正值，那么Redis就不会把这个timer事件从事件循环的队列中删除，这样它后面还有机会再次执行。例如，按照默认的设置，<code>serverCron</code>返回值是100，因此它每隔100毫秒会执行一次（当然这个执行频率可以在redis.conf中通过hz变量来调整）。</li>
</ul>
<p>至此，Redis整个事件循环的轮廓我们就清楚了。Redis主要的处理流程，包括接收请求、执行命令，以及周期性地执行后台任务（<code>serverCron</code>），都是由这个事件循环驱动的。当请求到来时，I/O事件被触发，事件循环被唤醒，根据请求执行命令并返回响应结果；同时，后台异步任务（如回收过期的key）被拆分成若干小段，由timer事件所触发，夹杂在I/O事件处理的间隙来周期性地运行。这种执行方式允许仅仅使用一个线程来处理大量的请求，并能提供快速的响应时间。当然，这种实现方式之所以能够高效运转，除了事件循环的结构之外，还得益于系统提供的异步的I/O多路复用机制(I/O multiplexing)。事件循环使得CPU资源被分时复用了，不同代码块之间并没有「真正的」并发执行，但I/O多路复用机制使得CPU和I/O的执行是真正并发的。而且，使用单线程还有额外的好处：避免了代码的并发执行，在访问各种数据结构的时候都无需考虑线程安全问题，从而大大降低了实现的复杂度。</p>
<h3 id="Redis命令请求的处理流程概述"><a href="#Redis命令请求的处理流程概述" class="headerlink" title="Redis命令请求的处理流程概述"></a>Redis命令请求的处理流程概述</h3><p>Redis对于来自客户端的请求的处理，都会走到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>这两个回调函数中去。实际上，这样描述还过于粗略。</p>
<p>Redis客户端向服务器发送命令，其实可以细分为两个过程：</p>
<ul>
<li><strong>连接建立</strong>。客户端发起连接请求（通过TCP或Unix domain socket），服务器接受连接。</li>
<li><strong>命令发送、执行和响应</strong>。连接一旦建立好，客户端就可以在这个新建立的连接上发送命令数据，服务器收到后执行这个命令，并把执行结果返回给客户端。而且，在新建立的连接上，这整个的「命令发送、执行和响应」的过程就可以反复执行。</li>
</ul>
<p>上述第一个过程，「连接建立」，对应到服务端的代码，就是会走到<code>acceptTcpHandler</code>或<code>acceptUnixHandler</code>这两个回调函数中去。换句话说，Redis服务器每收到一个新的连接请求，就会由事件循环触发一个I/O事件，从而执行到acceptTcpHandler或acceptUnixHandler回调函数的代码。</p>
<p>接下来，从socket编程的角度，服务器应该调用<code>accept</code>系统API[7]来接受连接请求，并为新的连接创建出一个socket。这个新的socket也就对应着一个新的文件描述符。为了在新的连接上能接收到客户端发来的命令，接下来必须在事件循环中为这个新的文件描述符注册一个I/O事件回调。这个过程的流程图如下：</p>
<p><img src="/2020/11/26/redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/accept_handler_flow_chart.png" alt="accept_handler_flow_chart"></p>
<p>从上面流程图可以看出，新的连接注册了一个I/O事件回调，即<code>readQueryFromClient</code>。也就是说，对应前面讲的第二个过程，「命令发送、执行和响应」，当服务器收到命令数据的时候，也会由事件循环触发一个I/O事件，执行到<code>readQueryFromClient</code>回调。这个函数的实现就是在处理命令的「执行和响应」了。因此，下面我们看一下这个函数的执行流程图：</p>
<p><img src="/2020/11/26/redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/process_query_flow_chart.png" alt="process_query_flow_chart"></p>
<p>上述流程图有几个需要注意的点：</p>
<ul>
<li>从socket中读入数据，是按照流的方式。也就是说，站在应用层的角度，从底层网络层读入的数据，是由一个个字节组成的字节流。而我们需要从这些字节流中解析出完整的Redis命令，才能知道接下来如何处理。但由于网络传输的特点，我们并不能控制一次读入多少个字节。实际上，即使服务器只是收到一个Redis命令的部分数据（哪怕只有一个字节），也有可能触发一次I/O事件回调。这时我们是调用read系统API[8]来读入数据的。虽然调用<code>read</code>时我们可以指定期望读取的字节数，但它并不会保证一定能返回期望长度的数据。比如我们想读100个字节，但可能只能读到80个字节，剩下的20个字节可能还在网络传输中没有到达。这种情况给接收Redis命令的过程造成了很大的麻烦：首先，可能我们读到的数据还不够一个完整的命令，这时我们应该继续等待更多的数据到达。其次，我们可能一次性收到了大量的数据，里面包含不止一个命令，这时我们必须把里面包含的所有命令都解析出来，而且要正确解析到最后一个完整命令的边界。如果最后一个完整命令后面还有多余的数据，那么这些数据应该留在下次有更多数据到达时再处理。这个复杂的过程一般称为「粘包」。</li>
<li>「粘包」处理的第一个表现，就是当尝试解析出一个完整的命令时，如果解析失败了，那么上面的流程就直接退出了。接下来，如果有更多数据到达，事件循环会再次触发I/O事件回调，重新进入上面的流程继续处理。</li>
<li>「粘包」处理的第二个表现，是上面流程图中的大循环。只要暂存输入数据的query buffer中还有数据可以处理，那么就不停地去尝试解析完整命令，直到把里面所有的完整命令都处理完，才退出循环。</li>
<li>查命令表那一步，就是查找本文前面提到的由<code>populateCommandTable</code>初始化的命令表，这个命令表存储在server.c的全局变量<code>redisCommandTable</code>当中。命令表中存有各个Redis命令的执行入口。</li>
<li>对于命令的执行结果，在上面的流程图中只是最后存到了一个输出buffer中，并没有真正输出给客户端。输出给客户端的过程不在这个流程当中，而是由另外一个同样是由事件循环驱动的过程来完成。</li>
</ul>
<h3 id="事件机制介绍"><a href="#事件机制介绍" class="headerlink" title="事件机制介绍"></a>事件机制介绍</h3><p>在本文第一部分，我们提到过，我们必须有一种机制能够同时等待I/O和timer这两种事件的发生。这一机制就是系统底层的I/O多路复用机制(I/O multiplexing)。但是，在不同的系统上，存在多种不同的I/O多路复用机制。因此，为了方便上层程序实现，Redis实现了一个简单的事件驱动程序库，即ae.c的代码，它屏蔽了系统底层在事件处理上的差异，并实现了我们前面一直在讨论的事件循环。</p>
<p>在Redis的事件库的实现中，目前它底层支持4种I/O多路复用机制：</p>
<ul>
<li>select系统调用[9]。这应该是最早出现的一种I/O多路复用机制了，于1983年在4.2BSD Unix中被首次使用[10]。它是POSIX规范的一部分。另外，跟select类似的还有一个poll系统调用[11]，它是1986年在SVR3 Unix系统中首次使用的[10]，也遵循- POSIX规范。只要是遵循POSIX规范的操作系统，它就能支持select和poll机制，因此在目前我们常见的系统中这两种I/O事件机制一般都是支持的。</li>
<li>epoll机制[1]。epoll是比select更新的一种I/O多路复用机制，最早出现在Linux内核的2.5.44版本中[12]。它被设计出来是为了代替旧的select和poll，提供一种更高效的I/O机制。注意，epoll是Linux系统所特有的，它不属于POSIX规范。</li>
<li>kqueue机制[13]。kqueue最早是2000年在FreeBSD 4.1上被设计出来的，后来也支持NetBSD、OpenBSD、DragonflyBSD和macOS系统[14]。它和Linux系统上的epoll是类似的。</li>
<li>event ports。这是在illumos系统[15]上特有的一种I/O事件机制。</li>
</ul>
<p>既然在不同系统上有不同的事件机制，那么Redis在不同系统上编译时采用的是哪个机制呢？由于在上面四种机制中，后三种是更现代，也是比select和poll更高效的方案，因此Redis优先选择使用后三种机制。</p>
<p>通过上面对各种I/O机制所适用的操作系统的总结，我们很容易看出，如果你在macOS上编译Redis，那么它底层会选用kqueue；而如果在Linux上编译则会选择epoll，这也是Redis在实际运行中比较常见的情况。</p>
<p>需要注意的是，这里所依赖的I/O事件机制，与如何实现高并发的网络服务关系密切。很多技术同学应该都听说过C10K问题[16]。随着硬件和网络的发展，单机支撑10000个连接，甚至单机支撑百万个连接，都成为可能[17]。高性能网络编程与这些底层机制息息相关。</p>
<p>现在我们回过头来再看一下底层的这些I/O事件机制是如何支持了Redis的事件循环的（下面的描述是对本文前面第一部分中事件循环流程的细化）：</p>
<ul>
<li>首先，向事件循环中注册I/O事件回调的时候，需要指定哪个回调函数注册到哪个事件上（事件用文件描述符来表示）。事件和回调函数的对应关系，由Redis上层封装的事件驱动程序库来维护。具体参见函数aeCreateFileEvent的代码。</li>
<li>类似地，向事件循环中注册timer事件回调的时候，需要指定多长时间之后执行哪个回调函数。这里需要记录哪个回调函数预期在哪个时刻被调用，这也是由Redis上层封装的事件驱动程序库来维护的。具体参见函数aeCreateTimeEvent的代码。</li>
<li>底层的各种事件机制都会提供一个等待事件的操作，比如epoll提供的epoll_wait API。这个等待操作一般可以指定预期等待的事件列表（事件用文件描述符来表示），并同时可以指定一个超时时间（即最大等待多长时间）。在事件循环中需要等待事件发生的时候，就调用这个等待操作，传入之前注册过的所有I/O事件，并把最近的timer事件所对应的时刻转换成这里需要的超时时间。具体参见函数aeProcessEvents的代码。</li>
<li>从上一步的等待操作中唤醒，有两种情况：如果是I/O事件发生了，那么就根据触发的事件查到I/O回调函数，进行调用；如果是超时了，那么检查所有注册过的timer事件，对于预期调用时刻超过当前时间的回调函数都进行调用。</li>
</ul>
<p>最后，关于事件机制，还有一些信息值得关注：业界已经有一些比较成熟的开源的事件库了，典型的比如libevent[20]和libev[21]。一般来说，这些开源库屏蔽了非常复杂的底层系统细节，并对不同的系统版本实现做了兼容，是非常有价值的。</p>
<p>为什么还要自己实现一套呢？</p>
<p>原因大致总结起来就是：</p>
<ul>
<li>不想引入太大的外部依赖。比如libevent太大了，比Redis的代码库还大。</li>
<li>方便做一些定制化的开发。</li>
<li>第三方库有时候会出现一些意想不到的bug。</li>
</ul>
<h3 id="代码调用关系"><a href="#代码调用关系" class="headerlink" title="代码调用关系"></a>代码调用关系</h3><p>对于本文前面分析的各个代码处理流程，包括初始化、事件循环、接收命令请求、执行命令、返回响应结果等等，为了方便大家查阅，下面用一个树型图展示了部分关键函数的调用关系（图比较大，点击可以看大图）。再次提醒：下面的调用关系图基于Redis源码的5.0分支，未来很可能随着Redis代码库的迭代而有所变化。</p>
<p>这个树型结构的含义，首先介绍一下：</p>
<ul>
<li>树型每次向右的分支，表示函数调用深入了一层（调用栈压栈）。</li>
<li>向右走到末端分支，表示没有更多函数调用了（调用栈开始退栈，把控制权交还给事件循环）。</li>
<li>图中一共有6棵独立的树，除了最开始main函数入口之外，其它5棵树都是由事件循环触发的新的调用流程。左侧树根是流程入口。</li>
<li>这个树型图并没有把所有函数调用关系都表达出来，只是列出了跟本文相关的调用流程。</li>
</ul>
<p>关键路径代码调用关系图</p>
<p><img src="/2020/11/26/redis%E6%BA%90%E7%A0%81%E4%BB%8E%E5%93%AA%E9%87%8C%E8%AF%BB%E8%B5%B7/method_call_hierarchy.png" alt="method_call_hierarchy"></p>
<p>上图中添加了部分注释，应该可以很清楚地和本文前面介绍过的一些流程对应上。另外，图中一些可能需要注意的细节，如下列出：</p>
<ul>
<li>初始化过程增加了aeSetBeforeSleepProc和aeSetAfterSleepProc，注册了两个回调函数，这在本文前面没有提到过。一个用于在事件循环每轮开始时调用，另一个会在每轮事件循环的阻塞等待后（即aeApiPoll返回后）调用。图中下面第5个调用流程的入口beforeSleep，就是由这里的aeSetBeforeSleepProc来注册到事件循环中的。</li>
<li>前文提到的serverCron周期性地执行，就是指的在processTimeEvents这个调用分支中调用的timeProc这个函数。</li>
<li>在数据接收处理的流程readQueryFromClient中，通过lookupCommand来查询Redis命令表，这个命令表也就是前面初始化时由populateCommandTable初始化的redisCommandTable全局结构。查找命令入口后，调用server.c的call函数来执行命令。图中call函数的下一层，就是调用各个命令的入口函数（图中只列出了几个例子）。以get命令的入口函数getCommand为例，它执行完的执行结果，最终会调用addReply存入到输出buffer中，即client结构的buf或reply字段中（根据执行结果的大小不同）。需要注意的是，就像前面「Redis命令请求的处理流程」最后讨论的一样，这里只是把执行结果存到了一个输出buffer中，并没有真正输出给客户端。真正把响应结果发送给客户端的执行逻辑，在后面的beforeSleep和sendReplyToClient流程中。</li>
<li>最后将命令执行结果发送给客户端的过程，由beforeSleep来触发。它检查输出buffe中有没有需要发送给客户端的执行结果数据，如果有的话，会调用writeToClient尝试进行发送。如果一次性没有把数据发送完毕，那么还需要再向事件循环中注册一个写I/O事件回调sendReplyToClient，在恰当的时机再次调用writeToClient来尝试发送。如果还是有剩余数据没有发送完毕，那么后面会由beforeSleep回调来再次触发这个流程。</li>
</ul>
<hr>
<p>简单总结一下，本文系统地记录了如下几个执行流程：</p>
<ul>
<li>从main函数启动后的初始化过程；</li>
<li>事件循环的执行逻辑和原理；</li>
<li>一个Redis命令从请求接收，到命令的解析和执行，再到执行结果返回的完整过程。</li>
</ul>
<p>要顺利读懂Redis源码，需要掌握一些在Linux下进行C语言编程的经验，也需要掌握一些Linux系统层面的知识。对于很多人来说，这些可能会是一种障碍。</p>
<p>抛开本文的很多细节，也许你至少可以记住Redis的命令表这个全局变量：<code>redisCommandTable</code>，它就定义在server.c源文件的开头。这里面记录了每一种Redis命令的执行入口。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis面试题</title>
    <url>/2020/11/20/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<a id="more"></a>
<h2 id="一、redis和memcache的比较"><a href="#一、redis和memcache的比较" class="headerlink" title="一、redis和memcache的比较"></a>一、redis和memcache的比较</h2><h3 id="1-memcache"><a href="#1-memcache" class="headerlink" title="1. memcache"></a>1. memcache</h3><p>代码层面类似hash<br>支持简单数据类型<br>不支持数据持久化存储<br>不支持主从<br>不支持分片</p>
<h3 id="2-redis"><a href="#2-redis" class="headerlink" title="2 redis"></a>2 redis</h3><p>数据类型丰富<br>支持数据磁盘持久化存储<br>支持主从<br>在3.0之后支持数据分片</p>
<h2 id="二、redis相关"><a href="#二、redis相关" class="headerlink" title="二、redis相关"></a>二、redis相关</h2><h3 id="1-为什么redis能这么快？qps：10W-qps-每秒内查询的次数"><a href="#1-为什么redis能这么快？qps：10W-qps-每秒内查询的次数" class="headerlink" title="1. 为什么redis能这么快？qps：10W+(qps:每秒内查询的次数)"></a>1. 为什么redis能这么快？qps：10W+(qps:每秒内查询的次数)</h3><ul>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，执行效率高</li>
<li>数据结构简单，对数据操作也简单</li>
<li>主线程采用单线程，单线程也能处理高并发请求，想多核也可以启动多实例</li>
<li>使用多路I/O复用模型，非阻塞IO</li>
</ul>
<h3 id="2-redis采用的IO多路复用函数：epoll-kqueue-evport-select"><a href="#2-redis采用的IO多路复用函数：epoll-kqueue-evport-select" class="headerlink" title="2. redis采用的IO多路复用函数：epoll/kqueue/evport/select?"></a>2. redis采用的IO多路复用函数：epoll/kqueue/evport/select?</h3><ul>
<li>因地制宜</li>
<li>优先选择时间复杂度为O(1)的IO多路复用函数作为底层实现</li>
<li>以时间复杂度为O(n)的select作为保底</li>
<li>基于react设计模式监听IO事件</li>
<li>redis服务采用react设计模式来实现文件事件处理器的，文件事件处理器使用IO多路复用模块同时监听多个fd，当accept、read、write和close文件事件产生时，文件事件处理器就会回调fd绑定的文件事件处理器，虽然整个文件事件处理器是在单线程上运行的，但是通过IO多路复用模块的引用实现了同时对多个fd读写的监控，提高了网络通信模型的性能，同时也可以保证整个redis服务实现的简单。</li>
</ul>
<h3 id="3-基本使用类型"><a href="#3-基本使用类型" class="headerlink" title="3. 基本使用类型"></a>3. 基本使用类型</h3><ul>
<li>String：最基本的数据类型，二进制安全<br>  底层保存字符串对象的结构：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//buf中已占用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//buf中剩余可用空间的长度</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//数据空间，数据存储在这个buf[]中</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Hash：String元素组成的字典，适合用于存储对象</li>
<li>List：列表，按照String元素插入顺序排序</li>
<li>Set：String元素组成的无序集合，通过哈希表来实现，不允许重复</li>
<li>Sorted Set：通过分数来为集合中的成员进行从小到大排序</li>
<li>用于计数的HyperLogLog</li>
<li>用于支持存储地理位置信息的Geo</li>
</ul>
<h3 id="4-底层数据类型基础"><a href="#4-底层数据类型基础" class="headerlink" title="4. 底层数据类型基础"></a>4. 底层数据类型基础</h3><ul>
<li>简单动态字符串</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
<li>对象</li>
</ul>
<h2 id="三、相关面试题"><a href="#三、相关面试题" class="headerlink" title="三、相关面试题"></a>三、相关面试题</h2><h3 id="1-从海量key中查询出某一固定前缀的key"><a href="#1-从海量key中查询出某一固定前缀的key" class="headerlink" title="1. 从海量key中查询出某一固定前缀的key"></a>1. 从海量key中查询出某一固定前缀的key</h3><ul>
<li>keys指令对线上业务的影响：<br>  <code>KEYS pattern</code>：查找出所有符合给定模式pattern的key<br>  <code>KEYS</code>指令一次性返回所有匹配的key<br>  键的数量过大会使得服务卡顿</li>
<li>scan指令：<br>  无阻塞地提取。会返回两个值：游标和结果集<br>  <code>SCAN cursor [MATCH pattern][COUNT count]</code><br>  <code>scan</code>指令时一个基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程<br>  以0作为游标开始一次新的迭代，直到命令返回游标0完成一次遍历。从0到0的过程为一次完整的遍历<br>  不保证每次执行都返回某个给定数量的元素，支持模糊查询<br>  一次返回的数量不可控，只是大概率符合count参数</li>
</ul>
<h3 id="2-如何实现分布式锁？"><a href="#2-如何实现分布式锁？" class="headerlink" title="2. 如何实现分布式锁？"></a>2. 如何实现分布式锁？</h3><p>分布式锁是控制分布式系统或不用系统之间共同访问共享资源的一种锁的实现，不同系统之间需要互斥来保证共享数据的线程安全。</p>
<h4 id="2-1-分布式锁需要解决的问题："><a href="#2-1-分布式锁需要解决的问题：" class="headerlink" title="2.1 分布式锁需要解决的问题："></a>2.1 分布式锁需要解决的问题：</h4><ul>
<li>互斥性：任一时刻，只能允许有一个客户端获取锁</li>
<li>安全性：锁只能由持有锁的客户端删除，不能由其他没锁的客户端删除</li>
<li>死锁：获得锁的客户端由于某些原因宕机了而不能释放锁，其他客户端不能获取锁而产生死锁，此时需要有机制来避免该问题的发生</li>
<li>容错：当redis某些节点宕机的时候，客户端仍然能够获取锁或释放锁</li>
</ul>
<h4 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h4><p><code>SETNX key value</code>：如果key不存在，则创建并赋值<br>时间复杂度：O(1)<br>返回值：设置成功-1；设置失败-0</p>
<h4 id="2-3-如何解决SETNX长期有效的问题？"><a href="#2-3-如何解决SETNX长期有效的问题？" class="headerlink" title="2.3 如何解决SETNX长期有效的问题？"></a>2.3 如何解决SETNX长期有效的问题？</h4><ul>
<li><p><code>EXPIRE key seconds</code>，为key设定给定的过期时间<br>  这种方式的缺点：不能保证原子性</p>
</li>
<li><p>在2.6.12之后：<br>  <code>SET key value [EX seconds][PX miliseconds][NX|XX]</code></p>
<p>  EX seconds：设置键的过期时间为second秒<br>  PX miliseconds：设置键的过期时间为miliseconds毫秒<br>  NX：只有在键不存在时，才对键进行设置操作<br>  XX：只有在键已经存在时，才对键进行设置操作<br>  SET操作成功时，返回Ok，否则返回nil</p>
</li>
</ul>
<h4 id="2-4-大量的key同时过期的注意事项"><a href="#2-4-大量的key同时过期的注意事项" class="headerlink" title="2.4 大量的key同时过期的注意事项"></a>2.4 大量的key同时过期的注意事项</h4><p>集中过期，由于清除大量的key会很耗时，会出现短暂的卡顿现象<br>解决方案：<strong>在设置key的过期时间的时候，给每个时间加上随机值，使得过期时间分散一些</strong></p>
<h3 id="3-如何使用redis做异步队列？"><a href="#3-如何使用redis做异步队列？" class="headerlink" title="3. 如何使用redis做异步队列？"></a>3. 如何使用redis做异步队列？</h3><ul>
<li>使用list作为队列，Rpush生产消息，Lpop消费消息<br>  缺点：没有等待队列里有值就直接消费<br>  弥补：可以通过在应用层引入sleep机制去调用lpop重试</li>
</ul>
<p><code>BLPOP key timeout</code>:阻塞直到队列有消息或者超时<br>缺点：只能供一个消费者消费</p>
<p><strong>如何让生产者消费，多个消费者消费？</strong></p>
<ul>
<li><p>pub/sub：主题订阅者模式<br>  发送者（pub）发送消息，订阅者（sub）接收消息<br>  订阅者可以订阅任意数量的频道（topic）</p>
</li>
<li><p>多个客户端运行：<code>subscribe myTopic</code>命令</p>
</li>
<li><p>在一个客户端中：<code>public myTopic &quot;Hello&quot;</code>,那么在其他订阅该topic的消费者能够接收到这个消息<br>  缺点：消息的发布是无状态的，无法保证可达。某个客户端在获取的时候宕机，重启之后是接收不到这个消息的，如果要解决这个问题，需要借助消息队列，即kafka等。</p>
</li>
</ul>
<h3 id="4-redis如何做持久化？"><a href="#4-redis如何做持久化？" class="headerlink" title="4. redis如何做持久化？"></a>4. redis如何做持久化？</h3><h4 id="4-1-RDB（快照）持久化：保存某个时间点的全量数据快照"><a href="#4-1-RDB（快照）持久化：保存某个时间点的全量数据快照" class="headerlink" title="4.1 RDB（快照）持久化：保存某个时间点的全量数据快照"></a>4.1 RDB（快照）持久化：保存某个时间点的全量数据快照</h4><p>在redis.conf配置文件中，默认：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒之内如果有一条写入指令则执行一次备份</span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 300秒之内如果有十条写入指令则执行一次备份</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="comment"># 60秒之内如果有十万条写入指令则执行一次备份            </span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"><span class="comment"># 设置成yes的时候表示当备份进程出错的时候主进程就停止接收写入操作了，为了保护数据持久化的一致性问题</span></span><br><span class="line"><span class="string">stop-writes-on-basave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># rdb持久化的时候，对持久化备份文件进行压缩，建议设置为no，因为redis是数据cpu密集型服务，开启压缩会带来更多的cpu消耗</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 禁用rdb配置</span></span><br><span class="line"><span class="string">save</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>在src目录下，会生成rdb后缀的文件（dump.rdb），即备份文件,是二进制文件</p>
<p><strong>rdb文件可以通过两个命令来生成：</strong><br>    <code>SAVE</code>：阻塞redis的服务器进程，直到RDB文件被创建完毕（很少被使用）<br>    <code>BGSAVE</code>：fork出一个子进程来创建RDB文件，不会阻塞服务器进程。主进程会继续接收客户端的操作命令</p>
<p><strong>自动化触发RDB持久化方式</strong><br>    根据redis.conf配置中的save m n定时触发（用的是BGSAVE）<br>    主从复制时，主节点自动触发<br>    执行Debug Reload<br>    执行Shutdown且没有开启AOF持久化</p>
<p><strong>BGSAVE原理</strong><br>    系统调用fork():创建进程，实现了copy-on-write</p>
<p><strong>copy-on-write</strong><br>如果有多个调用者同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专属副本给该调用者，而其他调用者所见到的最初的资源仍然保持不变。</p>
<p><strong>RDB缺点</strong></p>
<ul>
<li>内存数据的全量同步，数据量大会由于IO而严重影响性能</li>
<li>可能会因为redis挂掉而丢失当前至最近一次快照期间的数据</li>
</ul>
<h4 id="4-2-AOF-append-only-file-持久化：保存写状态"><a href="#4-2-AOF-append-only-file-持久化：保存写状态" class="headerlink" title="4.2 AOF(append-only-file)持久化：保存写状态"></a>4.2 AOF(append-only-file)持久化：保存写状态</h4><p>记录下除了查询以外的所有变更数据库状态的指令,以append的形式追加保存到AOF文件中（增量）,默认是关闭的</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br><span class="line">appendfilename <span class="string">&quot;appendonly.conf&quot;</span></span><br><span class="line"><span class="meta"># always:一旦缓冲区的内容发生变化，则总是及时地将缓冲区的内容写入到aof当中</span></span><br><span class="line"><span class="meta"># everysec：将缓冲区的内容每隔一秒写入到aof中（推荐且默认，速度比较快，安全性也不错）</span></span><br><span class="line"><span class="meta"># no：写入aof的操作交给操作系统去决定，一般而言操作系统会等待缓冲区被填满才同步</span></span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>

<p>导致的问题：随着时间的推移，数据量越来越大，AOF文件也很大，怎么办？</p>
<p><strong>日志重写解决AOF文件大小不断增大的问题</strong></p>
<p>原理如下：</p>
<ul>
<li>调用fork()，创建一个子进程</li>
<li>子进程把新的AOF写到一个临时文件中，新的AOF的重写直接将当前内存的数据生成对应的命令，不依赖原来的AOF文件</li>
<li>主进程持续将新的变动同时写到内存和原来的AOF中</li>
<li>主进程获取子进程重写AOF的完成信号之后，往新的AOF同步增量变动</li>
<li>使用新的AOF文件替换掉旧的AOF文件</li>
</ul>
<p><strong>BGOVERWRITEAOF指令即可触发AOF的重写，也可以让redis自动触发</strong></p>
<h4 id="4-3-RDB和AOF的优缺点"><a href="#4-3-RDB和AOF的优缺点" class="headerlink" title="4.3 RDB和AOF的优缺点"></a>4.3 RDB和AOF的优缺点</h4><p>RDB优点：全量数据快照，文件小，恢复快<br>RDB缺点：无法保存最近一次快照之后的数据<br>AOF优点：可读性高，适合保存增量数据，数据不易丢失<br>AOF缺点：文件体积大，恢复时间长</p>
<h4 id="4-4-Redis4-0之后提出了结合两种的RDB-AOF混合持久化方式，并且作为默认的配置来使用"><a href="#4-4-Redis4-0之后提出了结合两种的RDB-AOF混合持久化方式，并且作为默认的配置来使用" class="headerlink" title="4.4 Redis4.0之后提出了结合两种的RDB-AOF混合持久化方式，并且作为默认的配置来使用"></a>4.4 Redis4.0之后提出了结合两种的RDB-AOF混合持久化方式，并且作为默认的配置来使用</h4><ul>
<li>子进程在做AOF重写时，会通过管道从父进程读取增量数据并缓存下来，在以RDB格式保存全量数据时，也会从管道读取数据，同时不会造成管道的阻塞，也就是说AOF文件的前半段是RDB格式的全量数据，而后半段是redis命令格式的增量数据</li>
<li>BGSAVE做镜像全量持久化，AOF做增量持久化</li>
</ul>
<h3 id="5-pipeline"><a href="#5-pipeline" class="headerlink" title="5. pipeline"></a>5. pipeline</h3><p>pipeline和linux的管道类似<br>redis基于请求/响应模型，单个请求处理需要一一应答<br>pipeline批量执行指令，节省多次IO往返的时间<br>有顺序依赖的指令建议分批发送</p>
<h2 id="四、集群相关"><a href="#四、集群相关" class="headerlink" title="四、集群相关"></a>四、集群相关</h2><h3 id="1-redis的同步机制（主从、哨兵）"><a href="#1-redis的同步机制（主从、哨兵）" class="headerlink" title="1. redis的同步机制（主从、哨兵）"></a>1. redis的同步机制（主从、哨兵）</h3><p>主从同步原理</p>
<ul>
<li>一个master进行写操作，多个salve进行读操作</li>
<li>定期的数据备份操作是单独选择一个salve去完成的，这样可以最大程度发挥出redis的性能，为的是让redis支持弱一致性，即最终一致性。我们不需要实时保证master和salve的数据是同步的，但是在过了一段时间之后他们的数据是趋于同步的。</li>
<li>redis可以使用主从同步、从从同步。</li>
<li>第一次同步时主节点进行一次BGSAVE并同时将后续的写操作记录到内存中的buffer中去，待完成后将rdb文件全量同步到从节点中，从节点接收到rdb文件之后将rdb文件加载到内存中，加载完成后再通知主节点将期间修改的操作记录（即增量数据）同步到从节点进行重放，这样子就完成了整个同步的过程。</li>
</ul>
<p><strong>全同步过程</strong><br>Slave发送sync命令到master<br>master启动一个后台进程，将redis中的数据快照保存到文件中（BGSAVE）<br>master将保存数据快照期间接收到的写命令缓存起来<br>master完成写文件操作后，将该文件发送给Slave<br>使用新的RDB文件替换掉旧的RDB文件<br>master将这期间收集的增量写命令发送给slave端。</p>
<p><strong>增量同步过程</strong></p>
<p>Master接收到用户的操作指令，判断是否需要传播到Slave（增删改）<br>将操作记录追加到AOF文件中<br>将操作传播到其他slave中：<br>    - 1.对齐主从库。确保从数据库是该操作所对应的数据库<br>    - 2.往响应缓存写入指令。将命令和参数按照redis的协议格式写入到相应的缓存中<br>将缓存中的数据发送给Slave</p>
<p><strong>主从模式的弊端</strong></p>
<p>不具备高可用性，当master宕机之后redis将不能对外提供写入操作</p>
<h3 id="2-哨兵模式：解决主从同步Master宕机后的主从切换问题"><a href="#2-哨兵模式：解决主从同步Master宕机后的主从切换问题" class="headerlink" title="2. 哨兵模式：解决主从同步Master宕机后的主从切换问题"></a>2. 哨兵模式：解决主从同步Master宕机后的主从切换问题</h3><p>监控：sentinel检查主从服务器是否运行正常<br>提醒：通过API向管理员或者其他应用程序发送故障通知<br>自动故障迁移：主从切换</p>
<p><strong>流言协议Gossip</strong></p>
<p>在杂乱无章中寻求一致<br>每个节点都随机地与对方通信，最终所有节点的状态达成一致<br>种子节点定期随机向其他节点发送节点列表以及需要传播的消息<br>不保证信息一定会传递给所有节点，但是最终会趋于一致</p>
<h3 id="3-如何从海量数据中快速找到所需要的数据？（集群）"><a href="#3-如何从海量数据中快速找到所需要的数据？（集群）" class="headerlink" title="3.如何从海量数据中快速找到所需要的数据？（集群）"></a>3.如何从海量数据中快速找到所需要的数据？（集群）</h3><p>分片：按照某种规则去划分数据，分散存储在多个节点上<br>通过数据分片，来降低单节点服务器的压力<br>redisCluster采用无中心结构，每个节点保存数据和整个redis集群的状态，每个节点和其他所有节点连接，每个节点通过Gossip协议传播信息以及发现新的节点。<br>常规的按照hash无法实现节点的动态增减，采用<code>一致性hash</code>算法来实现</p>
<h3 id="4-一致性hash算法"><a href="#4-一致性hash算法" class="headerlink" title="4.一致性hash算法"></a>4.一致性hash算法</h3><ul>
<li>一致性hash：对2^32取模，将hash值空间组织成虚拟的圆环</li>
<li>物理机的ip经过hash计算得出hash值，所有节点得到的hash值组织成一个虚拟的圆环</li>
<li>当数据需要被存储的时候，按照key的hash值，按照圆环的顺时针方向保存到离他最近的hash对应的节点上，经过这样的方式就可以实现数据的分片</li>
</ul>
<p><strong>好处：</strong><br>假设<code>一个节点C宕机</code>，此时ABD并不会收到影响，原先需要分配到C节点的数据会重新定位到D中去，在一致性hash算法中，如果一个机器不可用，则受影响的仅仅是此服务器到其环空间前一台之间的服务器，即沿着逆时针方向行走遇到第一台服务器中间的数据，做到最小化有损的服务。如果在系统中<code>新增了服务器</code>，则影响的数据是新服务器到其环空间中的前一台服务器之间的数据，其他的数据不会受到影响</p>
<p><strong>Hash环的数据倾斜问题</strong></p>
<p>如果节点数量很少的时候，容易在圆环上造成hash分布不均匀的情况，导致一个节点上的数据比其他节点上的数据多出很多的情况。造成数据倾斜，数据倾斜就是大部分的数据分布在同一个节点上。</p>
<p><strong>引入虚拟节点来解决数据倾斜问题</strong></p>
<ul>
<li>对每个服务器节点计算多个hash，每个计算结果位置都放置一个节点为该节点的虚拟节点（具体做法可以在主机名或者ip后增加编号来实现），这样来实现圆环的大致均匀。数据算法不变，只是多了一步虚拟节点到真实节点的映射。</li>
<li>通常将虚拟节点设置为32甚至更大。</li>
</ul>
<h2 id="五、Redis的五种淘汰策略"><a href="#五、Redis的五种淘汰策略" class="headerlink" title="五、Redis的五种淘汰策略"></a>五、Redis的五种淘汰策略</h2><ul>
<li><code>volatile-lru</code>:从设置了过期时间的数据集中，选择最近最久未使用的数据释放；</li>
<li><code>allkeys-lru</code>:从数据集中(包括设置过期时间以及未设置过期时间的数据集中)，选择最近最久未使用的数据释放；</li>
<li><code>volatile-random</code>:从设置了过期时间的数据集中，随机选择一个数据进行释放；</li>
<li><code>allkeys-random</code>:从数据集中(包括了设置过期时间以及未设置过期时间)随机选择一个数据进行入释放；</li>
<li><code>volatile-ttl</code>：从设置了过期时间的数据集中，选择马上就要过期的数据进行释放操作；</li>
<li><code>noeviction</code>：不删除任意数据(但redis还会根据引用计数器进行释放),这时如果内存不够时，会直接返回错误。</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel</title>
    <url>/2020/08/20/sentinel/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h3><h4 id="服务限流-熔断"><a href="#服务限流-熔断" class="headerlink" title="服务限流/熔断"></a>服务限流/熔断</h4><p>服务限流目的是为了更好的保护我们的服务，在高并发的情况下，如果客户端请求的数量达到一定极限（后台可以配置阈值），请求的数量超出了设置的阈值，开启自我的保护，直接调用我们的服务降级的方法，不会执行业务逻辑操作，直接走本地falback的方法，返回一个友好的提示</p>
<h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>在高并发的情况下， 防止用户一直等待，采用限流/熔断方法，使用服务降级的方式返回一个友好的提示给客户端，不会执行业务逻辑请求，直接走本地的falback的方法。<br><strong>eg:</strong> 提示语：当前排队人数过多，稍后重试~</p>
<a id="more"></a>

<h4 id="服务的雪崩效应"><a href="#服务的雪崩效应" class="headerlink" title="服务的雪崩效应"></a>服务的雪崩效应</h4><p>默认的情况下，Tomcat或者是Jetty服务器只有一个线程池去处理客户端的请求，<br>这样的话就是在高并发的情况下，如果客户端所有的请求都堆积到同一个服务接口上，<br>那么就会产生tomcat服务器所有的线程都在处理该接口，可能会导致其他的接口无法访问。</p>
<p><strong>eg:</strong> 假设我们的tomcat线程最大的线程数量是为20，这时候客户端如果同时发送100个请求会导致有80个请求暂时无法访问，就会转圈。</p>
<h4 id="服务雪崩的解决方案：服务的隔离的机制"><a href="#服务雪崩的解决方案：服务的隔离的机制" class="headerlink" title="服务雪崩的解决方案：服务的隔离的机制"></a>服务雪崩的解决方案：服务的隔离的机制</h4><p>服务的隔离机制分为信号量和线程池隔离模式</p>
<ul>
<li>服务的线程池隔离机制：每个服务接口都有自己独立的线程池，互不影响，缺点就是占用cpu资源非常大。</li>
<li>服务的信号量隔离机制：最多只有一定的阈值线程数处理我们的请求，超过该阈值会拒绝请求。</li>
</ul>
<h3 id="二、Sentinel与hytrix区别"><a href="#二、Sentinel与hytrix区别" class="headerlink" title="二、Sentinel与hytrix区别"></a>二、Sentinel与hytrix区别</h3><p>前哨以流量为切入点，从流量控制，熔断降级，系统负载保护等多个维度保护服务的稳定性。</p>
<p>前哨具有以下特征：</p>
<ul>
<li>1.丰富的应用场景：前哨兵承接了阿里巴巴近10年的双十一大促流的核心场景，例如秒杀（即突然流量控制在系统容量可以承受的范围），消息削峰填谷，传递流量控制，实时熔断下游不可用应用等。</li>
<li>2.完备的实时监控：Sentinel同时提供实时的监控功能。您可以在控制台中看到接收应用的单台机器秒级数据，甚至500台以下规模的整合的汇总运行情况。<br>广泛的开源生态：Sentinel提供开箱即用的与其他开源框架/库的集成模块，例如与Spring Cloud，Dubbo，gRPC的整合。您只需要另外的依赖并进行简单的配置即可快速地接入Sentinel。</li>
<li>3.完善的SPI扩展点：Sentinel提供简单易用，完善的SPI扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理，适应动态数据源等。</li>
</ul>
<p>Sentinel中文文档介绍：<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">sentinel中文文档</a></p>
<p><img src="/2020/08/20/sentinel/1.png" alt="Sentinel与hytrix区别"></p>
<h3 id="三、SpringBoot项目整合Sentinel"><a href="#三、SpringBoot项目整合Sentinel" class="headerlink" title="三、SpringBoot项目整合Sentinel"></a>三、SpringBoot项目整合Sentinel</h3><h4 id="1-Maven依赖的配置"><a href="#1-Maven依赖的配置" class="headerlink" title="1.Maven依赖的配置"></a>1.Maven依赖的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-项目启动自动配置限流规则"><a href="#2-项目启动自动配置限流规则" class="headerlink" title="2.项目启动自动配置限流规则"></a>2.项目启动自动配置限流规则</h4><p>常量类：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SentinelConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限流名称</span></span><br><span class="line">    <span class="keyword">String</span> GETORDER_KEY = <span class="string">&quot;getOrder&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SentinelInit：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> SentinelInit implements ApplicationRunner &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        List&lt;FlowRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;FlowRule&gt;<span class="literal">()</span>;</span><br><span class="line">        FlowRule rule1 = <span class="keyword">new</span> <span class="constructor">FlowRule()</span>;</span><br><span class="line">        rule1.set<span class="constructor">Resource(SentinelConstant.GETORDER_KEY)</span>;</span><br><span class="line">        <span class="comment">// QPS控制在2以内</span></span><br><span class="line">        rule1.set<span class="constructor">Count(1)</span>;</span><br><span class="line">        <span class="comment">// QPS限流</span></span><br><span class="line">        rule1.set<span class="constructor">Grade(RuleConstant.FLOW_GRADE_QPS)</span>;</span><br><span class="line">        rule1.set<span class="constructor">LimitApp(<span class="string">&quot;default&quot;</span>)</span>;</span><br><span class="line">        rules.add(rule1);</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">FlowRuleManager</span>.</span></span>load<span class="constructor">Rules(<span class="params">rules</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;...限流配置初始化成功..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、非注解形式配置到接口"><a href="#3、非注解形式配置到接口" class="headerlink" title="3、非注解形式配置到接口"></a>3、非注解形式配置到接口</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">&quot;/getOrder&quot;</span>)</span><br><span class="line">   public String getOrders() &#123;</span><br><span class="line">       Entry entry = null;</span><br><span class="line">       try &#123;</span><br><span class="line">           entry = SphU.entry(SentinelConstant.GETORDER_KEY);</span><br><span class="line">           <span class="regexp">//</span> 执行我们服务需要保护的业务逻辑</span><br><span class="line">           return <span class="string">&quot;getOrder接口&quot;</span>;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           return <span class="string">&quot;该服务接口已经达到上线!&quot;</span>;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           <span class="regexp">//</span> SphU.entry(xxx) 需要与 entry.<span class="keyword">exit</span>() 成对出现,否则会导致调用链记录异常</span><br><span class="line">           <span class="keyword">if</span> (entry != null) &#123;</span><br><span class="line">               entry.<span class="keyword">exit</span>();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="4、注解形式配置到接口"><a href="#4、注解形式配置到接口" class="headerlink" title="4、注解形式配置到接口"></a>4、注解形式配置到接口</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * fallback 服务降级执行本地方法</span></span><br><span class="line"><span class="comment"> * blockHandler 限流/熔断出现异常执行的方法</span></span><br><span class="line"><span class="comment"> * value 指定我们的资源名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">&quot;/orderTinner&quot;</span>)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = SentinelConstant.GETORDER_KEY,blockHandler = <span class="meta-string">&quot;getorderQpsException&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> String orderTinner() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;orderTinner&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String getorderQpsException(BlockException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;该接口已经被限流了！！！！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、控制台sentinel"><a href="#四、控制台sentinel" class="headerlink" title="四、控制台sentinel"></a>四、控制台sentinel</h3><h4 id="1-下载jar包"><a href="#1-下载jar包" class="headerlink" title="1.下载jar包"></a>1.下载jar包</h4><p>参考官网</p>
<h4 id="2-运行命令"><a href="#2-运行命令" class="headerlink" title="2.运行命令"></a>2.运行命令</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">java -<span class="module-access"><span class="module"><span class="identifier">Dserver</span>.</span></span>port=<span class="number">8718</span> -<span class="module-access"><span class="module"><span class="identifier">Dcsp</span>.</span></span>sentinel.dashboard.server=localhost:<span class="number">8718</span> -<span class="module-access"><span class="module"><span class="identifier">Dproject</span>.</span></span>name=sentinel-dashboard -<span class="module-access"><span class="module"><span class="identifier">Dcsp</span>.</span></span>sentinel.api.port=<span class="number">8719</span> -jar /Users/jinping/Desktop/sentinel-dashboard-<span class="number">1.7</span>.<span class="number">2.</span>jar</span><br></pre></td></tr></table></figure>
<p>8718属于 界面端口号 8719 属于api通讯的端口号</p>
<h4 id="五、SpringBoot整合Sentinel仪表盘-配置"><a href="#五、SpringBoot整合Sentinel仪表盘-配置" class="headerlink" title="五、SpringBoot整合Sentinel仪表盘 配置"></a>五、SpringBoot整合Sentinel仪表盘 配置</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tinner-member</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="comment">#nacos注册地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8718</span></span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br></pre></td></tr></table></figure>
<h5 id="基于并发数量处理限流"><a href="#基于并发数量处理限流" class="headerlink" title="基于并发数量处理限流"></a>基于并发数量处理限流</h5><p><img src="/2020/08/20/sentinel/2.png" alt="基于并发数量处理限流"><br>每次最多只会有一个线程处理该业务逻辑，超出该阈值的情况下，直接拒绝访问</p>
<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@SentinelResource</span>(value = <span class="string">&quot;getOrderThrad&quot;</span>, blockHandler = <span class="string">&quot;getOrderQpsException&quot;</span>)</span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">&quot;/getOrderThrad&quot;</span>)</span><br><span class="line">public String getOrderThrad() &#123;</span><br><span class="line">    <span class="selector-tag">System</span><span class="selector-class">.out</span><span class="selector-class">.println</span>(Thread.currentThread().getName());</span><br><span class="line">    <span class="selector-tag">try</span> &#123;</span><br><span class="line">        <span class="selector-tag">Thread</span><span class="selector-class">.sleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="selector-tag">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="string">&quot;getOrderThrad&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、Sentinel如何保证规则的持久化"><a href="#六、Sentinel如何保证规则的持久化" class="headerlink" title="六、Sentinel如何保证规则的持久化"></a>六、Sentinel如何保证规则的持久化</h3><p>默认的情况下Sentinel的规则是存放在内存中，如果Sentinel客户端重启后，Sentinel数据规则可能会丢失。<br>解决方案：<br><strong>Sentinel持久化机制支持四种持久化的机制。</strong></p>
<ul>
<li>1.本地文件</li>
<li>2.携程阿波罗</li>
<li>3.Nacos</li>
<li>4.Zookeeper<br><img src="/2020/08/20/sentinel/3.jpg" alt="数据持久化"><br><img src="/2020/08/20/sentinel/4.png" alt="数据持久化2"></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>作业帮面试题</title>
    <url>/2020/08/03/%E4%BD%9C%E4%B8%9A%E5%B8%AE%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>作业帮的面试官是做python的，所以java基本也没怎么问，主要是问了最近做的项目，更多的是redis和算法、linux的相关命令等操作，详细列一下吧</p>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><blockquote>
<p>1、手写二叉树的先序遍历<br>2、给定义一个int数组（里面给的都是不重复的0-9的数字）和一个数字（这个数字是这个字符数组的随机组合）num，求出这个int数组所有随机排列组合的数字中比给定的num大的组合中，最小的一个<br>例子：字符数组：[1,2,3,4,5]，num：34125。那么最终结果为：34152</p>
</blockquote>
<a id="more"></a>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul>
<li>你都用过哪几种数据结构？在项目中都是怎么用的</li>
<li>实现一个微博热搜榜的功能，有什么想法（实时性、海量数据两个维度去考虑）</li>
<li>什么样的数据需要进行哈希存取</li>
</ul>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>设计表，手写sql语句<br>索引</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>B+树</p>
<h3 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h3><p>对于海量数据量，Elasticsearch的搜索如何做的</p>
<h3 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h3><p>一个日志文件中有接口的请求地址和接口的请求时间，从小到大打印出每个接口的访问次数，降序排列。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>一个http请求，是怎么打入到java服务中去，相关结果又是怎么返回给前端的。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式一致性问题</title>
    <url>/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="分布式事务一致性框架与分布式系统一致性算法"><a href="#分布式事务一致性框架与分布式系统一致性算法" class="headerlink" title="分布式事务一致性框架与分布式系统一致性算法"></a>分布式事务一致性框架与分布式系统一致性算法</h3><p><strong>分布式事务一致性框架：</strong> 核心就是解决我们在实际系统中产生跨事务导致分布式事务的问题，核心靠的是最终一致性。比如：rocketMq事务消息、rabbitmq补单、lcn、seata等。<br><strong>分布式系统一致性算法：</strong> 解决我们系统之间集群之后每隔节点保持数据的一致性。比如：raft、zab、paxos等<br>分布式系统一致性算法应用于系统软件实现集群保持每隔节点数据的同步性。保持我们的集群中每个节点的数据的一致性问题。</p>
<a id="more"></a>

<h3 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h3><p>在集群环境下，如何去进行领导角色的选举？由以下两个选举算法：</p>
<h4 id="1、rap协议"><a href="#1、rap协议" class="headerlink" title="1、rap协议"></a>1、rap协议</h4><p>  对每个结点配置一个myid或者serverid，数值越大表示能力越强，或者随机时间<br>  整个集群中为了保持数据的一致性的问题，必须满足大多数情况下&gt; n/2+1,可运行的节点环境才可以使用<br>  ZAP的协议实现原理是通过比较myid，myid谁最大谁就最可能是领导角色，只要满足过半的机制就可以成为领导角色，后来启动的节点不会参与选举的。</p>
<p><strong>ZAP如何保持数据的一致性问题：</strong><br>  所有写的请求统一交给我们的领导角色实现，领导角色写完数据之后，领导角色再将数据同步给每个节点。数据之间同步采用<strong>2pc两阶段提交协议</strong>。</p>
<p><strong>选举过程：</strong><br>  先去比较zxid，zxid谁最大谁就为领导角色<br>  如果zxid相等的情况下，myid谁最大谁就为领导角色。</p>
<p><strong>关于zxid和2pc两阶段提交协议</strong><br>  zxid是每个节点都有的一个标记，所有的写请求都是交给主节点去进行操作的，当主节点操作完之后，会将zxid+1，然后同步给其他节点，其他节点确认自己本身能够将自己的zxid实现自增之后将确认信号给到主节点，当主节点全部收到确认信号之后将会通知所有节点进行zxid自增的操作。<br>  <img src="/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/4.jpg" alt="zxid和两节点提交"></p>
<h4 id="2、Raft协议"><a href="#2、Raft协议" class="headerlink" title="2、Raft协议"></a>2、Raft协议</h4><p><strong>在Raft协议算法中分为三个角色|名词：</strong></p>
<ul>
<li>状态：分为三种：跟随者、竞选者（候选人）、领导角色</li>
<li>大多数：&gt;n/2+1</li>
<li>任期：每次选举一个新的领导角色，任期都会实现增加</li>
<li>竞选者谁的票数最多，谁就是领导角色</li>
</ul>
<p><strong>选举的过程是怎么样的？</strong></p>
<ul>
<li>默认的情况下每个节点都是位跟随者</li>
<li>每个节点会随机地生成一个选举地超时时间，例如大概是100-300ms，在这个超时时间范围内必须要等待</li>
<li>超时时间过后，当前的节点状态可能由跟随者变为竞选者状态，会给其他的节点发出选举投票的通知，只要该竞选者有超过半数以上的票数即可选为领导角色<br>核心的设计原理其实就是靠的谁的超时时间最短谁就有非常大的概率成为领导角色。</li>
</ul>
<p><strong>核心设计的原理：</strong>谁超时时间最短谁就有大概率地成为领导角色。</p>
<p><strong>随机超时时间有可能一样的情况下：</strong><br>  1、如果所有地节点的超时随机数都是一样的情况下，当前投票全部作废，重新进入随机生成超时时间的状态<br>  2、如果由多个节点生成的随机数都是一样的情况下，比较谁的票数最多，谁就是领导。如果票数完全一样的情况，直接作废，重新进入随机生成超时时间的状态。</p>
<p>建议:集群节点设为<strong>奇数</strong></p>
<p><strong>故障的重新选举：</strong><br>  如果我们的跟随者节点不能够及时地收到领导角色消息，那么这个时候跟随者就会将当前自己的状态由跟随者变为竞选者的角色，会给其他的节点发出选举投票的通知，只要该竞选者有超过半数以上的票数即可选为领导角色。</p>
<p><em>疑问：是否可能会产生两个同时的竞选者，同时实现拉票呢？</em><br>    当我们的节点为偶数的情况下，可能会存在该问题，如果两个竞选者获取的票数相等的情况下，开始重置竞选的超时时间，一直到谁的票数最多谁就为领导。</p>
<p><strong>数据是如何保持一致性的？</strong><br>  类似zap两阶段提交协议。</p>
<p><strong>如何实现日志的复制？</strong></p>
<ul>
<li>所有的写的请求都是统一地交给我们的领导角色完成的，写入该对应的日志，标记该日志为被提交状态。</li>
<li>为了提交该日志，领导角色就会将该日志以心跳的形式发送给其他的跟随者，只要满足过半的跟随者可以写入该数据，则会通知其他节点同步该数据，这个称作为日志复制。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式配置中心</title>
    <url>/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="一-分布式配置中心的作用"><a href="#一-分布式配置中心的作用" class="headerlink" title="一.分布式配置中心的作用"></a>一.分布式配置中心的作用</h1><p>分布式配置中心可以实现不需要重启我们的服务器，动态的修改我们的配置文件内容，<br>常见的配置中心有携程的阿波罗、SpringCloud Config、Nacos轻量级的配置中心等。</p>
<p><strong>轻量级：</strong> 部署、架构设计原理都比较简单，学习成本也比较低。<br><strong>重量级：</strong> 部署、架构设计、体积都非常大，学习成本比较高。</p>
<a id="more"></a>

<h1 id="二-原理"><a href="#二-原理" class="headerlink" title="二.原理"></a>二.原理</h1><p>1、本地应用读取我们云端分布式配置中心文件（第一次建立长连接）<br>2、本地应用读取到配置文件之后，本地jvm和硬盘中都会缓存一份<br>3、本地应用与分布式配置中心服务端一直保持长连接<br>4、当我们的配置文件发生变化（MD5|版本号）实现区分，将变化结果通知给我们的本地应用及时地刷新我们的配置文件。<br><img src="/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86.jpg" alt="原理"><br>完全百分百实现动态化修改我们的配置文件</p>
<h1 id="三-代码实现"><a href="#三-代码实现" class="headerlink" title="三.代码实现"></a>三.代码实现</h1><h2 id="1-新增配置文件"><a href="#1-新增配置文件" class="headerlink" title="1.新增配置文件"></a>1.新增配置文件</h2><p><img src="/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/1.jpg" alt="新增配置文件"></p>
<h2 id="2-项目中添加依赖"><a href="#2-项目中添加依赖" class="headerlink" title="2.项目中添加依赖"></a>2.项目中添加依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-新建bootstrap-yml"><a href="#3-新建bootstrap-yml" class="headerlink" title="3.新建bootstrap.yml"></a>3.新建bootstrap.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment">###配置中心连接地址</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="comment">###分组</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="comment">###类型</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure>

<h2 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;tinner.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tinnerName;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tinnerName + <span class="string">&quot;我是会员服务&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5.注意事项"></a>5.注意事项</h3><ul>
<li>本地如果也配置相同的key，那么在启动的时候可能会抛出异常</li>
<li>可以实现动态实现<code>@RefreshScope</code></li>
<li>nacos在windows版本下运行默认是单机版本 需要指定<code>startup.cmd -m cluster</code></li>
<li>nacos在linux版本下运行默认是集群版本 如果想连接单机版本 <code>startup.cmd –m standalone</code></li>
</ul>
<h3 id="6-bootstrap与application区别"><a href="#6-bootstrap与application区别" class="headerlink" title="6.bootstrap与application区别"></a>6.bootstrap与application区别</h3><ul>
<li>bootstrap.yml 用于应用程序上下文的引导阶段。</li>
<li>application.yml 由父Spring ApplicationContext加载。</li>
</ul>
<h1 id="四-多版本控制"><a href="#四-多版本控制" class="headerlink" title="四.多版本控制"></a>四.多版本控制</h1><h2 id="1-新增prod配置文件"><a href="#1-新增prod配置文件" class="headerlink" title="1.新增prod配置文件"></a>1.新增prod配置文件</h2><p><img src="/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/2.jpg" alt="新增配置文件"></p>
<h2 id="2-修改项目的配置文件"><a href="#2-修改项目的配置文件" class="headerlink" title="2.修改项目的配置文件"></a>2.修改项目的配置文件</h2><p><img src="/2020/08/17/%E5%88%86%E5%B8%83%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/3.jpg" alt="新增配置文件"></p>
<h1 id="五-Nacos集群模式"><a href="#五-Nacos集群模式" class="headerlink" title="五. Nacos集群模式"></a>五. Nacos集群模式</h1><p>官方文档：<a href="https://nacos.io/en-us/docs/cluster-mode-quick-start.html">https://nacos.io/en-us/docs/cluster-mode-quick-start.html</a><br>视频教程：<a href="https://www.bilibili.com/video/BV1D7411A7Ru?p=43">https://www.bilibili.com/video/BV1D7411A7Ru?p=43</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork/Join分而治之</title>
    <url>/2018/01/09/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、十大经典算法"><a href="#一、十大经典算法" class="headerlink" title="一、十大经典算法"></a>一、十大经典算法</h3><p><strong>快速排序</strong>、堆排序、<strong>归并排序</strong>、<strong>二分查找</strong>、线性查找、深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类<br>（黑体的算法体现了分而治之的思想）<br>动态规划与分而治之特别像，但是不算是分而治之。</p>
<ul>
<li>分而治之的小问题之间是相互独立的，没有关联的。</li>
<li>动态规划的小问题之间是有关联的。<h5 id="外部排序：https-blog-csdn-net-zssapple-article-details-82770607"><a href="#外部排序：https-blog-csdn-net-zssapple-article-details-82770607" class="headerlink" title="外部排序：https://blog.csdn.net/zssapple/article/details/82770607"></a>外部排序：<a href="https://blog.csdn.net/zssapple/article/details/82770607">https://blog.csdn.net/zssapple/article/details/82770607</a></h5>体现了分而治之的思想，本质上来说就是归并排序</li>
</ul>
<h4 id="二、Fork-Join"><a href="#二、Fork-Join" class="headerlink" title="二、Fork/Join"></a>二、Fork/Join</h4><p><strong>Fork/Join框架</strong>：就是在必要的情况下，将一个大任务拆分（fork）成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行join汇总。<br>Fork/Join 将任务调度的部分给程序员屏蔽掉了。我们只需要关心如何把任务进行拆解以及每个具体任务怎么做就可以了。除此之外，Fork/Join还提供了一个<strong>工作密取</strong>的概念。不同的小任务执行的速度也是不一样的，<code>假设现在有两个线程去分别执行50个小任务，A线程提前完事了，然后看到B线程还有20个任务没有完事，A线程就会去窃取B线程尾部的任务去处理，处理完之后再将任务塞回到B线程的任务队列中去。</code>工作密取就是为了提高CPU的利用率而设计的。</p>
<a id="more"></a>

<p><img src="https://upload-images.jianshu.io/upload_images/15200008-27d049765131366e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作密取"></p>
<h5 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h5><p>JDK将Fork/Join框架进行了一个抽象，抽象成了一个<code>ForkJoinTask</code>抽象类。为了方便实现，还提供了两个实现类，一个是<code>RecursiveTask</code>，另一个是<code>RecursiveAction</code>。它们都是抽象类，RecursiveTask有个泛型，泛型意味着有返回结果，而action是没有返回结果的任务。<br>产生任务之后如何去执行呢？jdk交给<code>ForkJoinPool</code>这个线程池去执行。<br>ForkJoinPool中有三个方法：</p>
<ul>
<li>invoke：是一个同步方法,当我们调用这个方法之后，必须等这个任务全部完成了，invoke会返回一个任务的执行结果，在那之后我才能执行后面的代码。</li>
<li>submit、execute：异步方法，不必要等待全部执行，可以执行后面的代码。execute没有返回值，而submit会有一个返回值，返回一个ForkJoinTask，然后我们可以通过一个get()方法拿到执行结果。</li>
</ul>
<h5 id="使用范式"><a href="#使用范式" class="headerlink" title="使用范式"></a>使用范式</h5><p><img src="https://upload-images.jianshu.io/upload_images/15200008-1ebc9006d4c70f21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用范式"><br>我们只需要关心在compute方法中任务的拆分以及任务的业务实现就可以了。</p>
<h3 id="二、使用Fork-Join完成归并排序"><a href="#二、使用Fork-Join完成归并排序" class="headerlink" title="二、使用Fork/Join完成归并排序"></a>二、使用Fork/Join完成归并排序</h3><p>参考：<a href="https://github.com/jinping-dev/concurrent/tree/master/src/main/java/cn/enjoyedu/ch04/forkjoin">forkjoin相关代码示例</a></p>
<h3 id="三、常用的并发工具类"><a href="#三、常用的并发工具类" class="headerlink" title="三、常用的并发工具类"></a>三、常用的并发工具类</h3><h5 id="1-CountDownLatch"><a href="#1-CountDownLatch" class="headerlink" title="1.CountDownLatch"></a>1.CountDownLatch</h5><p>闭锁，CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。CountDownLatch是通过一个计数器来实现的，计数器的初始值为初始任务的数量。每当完成了一个任务后，计数器的值就会减1（CountDownLatch.countDown()方法）。当计数器值到达0时，它表示所有的已经完成了任务，然后在闭锁上等待CountDownLatch.await()方法的线程就可以恢复执行任务。实现最大的并行性：<strong>有时我们想同时启动多个线程，实现最大程度的并行性</strong>。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了，例如处理excel中多个表单。</p>
<h5 id="2-CyclicBarrier"><a href="#2-CyclicBarrier" class="headerlink" title="2.CyclicBarrier"></a>2.CyclicBarrier</h5><p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。<br>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），<strong>用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</strong><br><strong>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</strong></p>
<h5 id="3-CyclicBarrier和CountDownLatch的区别"><a href="#3-CyclicBarrier和CountDownLatch的区别" class="headerlink" title="3.CyclicBarrier和CountDownLatch的区别"></a>3.CyclicBarrier和CountDownLatch的区别</h5><p>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置，CountDownLatch.await一般阻塞主线程，所有的工作线程执行countDown，而CyclicBarrierton通过工作线程调用await从而阻塞工作线程，直到所有工作线程达到屏障。</p>
<h5 id="4-控制并发线程数的Semaphore"><a href="#4-控制并发线程数的Semaphore" class="headerlink" title="4.控制并发线程数的Semaphore"></a>4.控制并发线程数的Semaphore</h5><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。应用场景Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，几十个线程并发地存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。。Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。<br>Semaphore还提供一些其他方法，具体如下。</p>
<ul>
<li>intavailablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>intgetQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>booleanhasQueuedThreads()：是否有线程正在等待获取许可证。</li>
<li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li>
</ul>
<h5 id="5-Exchanger"><a href="#5-Exchanger" class="headerlink" title="5.Exchanger"></a>5.Exchanger</h5><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>架构演变</title>
    <url>/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">


<h3 id="传统架构"><a href="#传统架构" class="headerlink" title="传统架构"></a>传统架构</h3><p>传统的架构，也就是为单点应用，也就是大家在早期所学习的JavaEE知识SSH或者SSM架构模式，会采用分层架构模式：数据库访问层、业务逻辑层、控制层，从前端到后台所有的代码都是一个开发者去完成。<br>该架构模式没有对我们业务逻辑代码实现拆分，所有的代码都写入到同一个工程中里面，适合于小公司开发团队或者个人开发。<br>这种架构模式最大的缺点，如果该系统一个模块出现不可用、会导致整个系统无法使用。</p>
<a id="more"></a>

<p><img src="/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/%E5%8D%95%E4%BD%93.png" alt="单体架构"></p>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><p>分布式架构模式是基于传统的架构模式演变过来，将传统的单点项目根据业务模块实现拆分、会拆分为会员系统、订单系统、支付系统、秒杀系统等。 从而降低我们项目的耦合度，这种架构模式开始慢慢的适合于互联网公司开发团队。 </p>
<h3 id="SOA面向服务架构"><a href="#SOA面向服务架构" class="headerlink" title="SOA面向服务架构"></a>SOA面向服务架构</h3><p>SOA面向服务架构就是基于我们的分布式架构演变过来的，俗称服务化，也就是面向于接口开发（服务开发）。<br>SOA架构模式也称作为：面向服务架构模式、俗称面向与接口开发，将共同存在的业务逻辑抽取成一个共同的服务，提供给其他的服务接口实现调用、服务与服务之间通讯采用rpc远程调用技术。</p>
<p>SOA架构模式特点：</p>
<ul>
<li>SOA架构通讯中，采用XML方式实现通讯、在高并发下通讯过程中协议存在非常大冗余性，所以在最后微服务架构模式中使用JSON格式替代了XML。</li>
<li>SOA架构模式实现方案为WebService或者是ESB企业服务总线 底层通讯协议SOAP协议（Http+XML）实现传输。<br><img src="/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/soa.png" alt="SOA架构"></li>
</ul>
<h3 id="ESB企业服务总线"><a href="#ESB企业服务总线" class="headerlink" title="ESB企业服务总线"></a>ESB企业服务总线</h3><p>解决多系统之间跨语言无法实现通讯的问题，数据协议的转换，提供可靠消息传输。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h5 id="微服务架构产生的原因"><a href="#微服务架构产生的原因" class="headerlink" title="微服务架构产生的原因"></a>微服务架构产生的原因</h5><p>微服务架构基于SOA架构演变过来的<br>在传统的WebService架构中有如下问题:</p>
<ul>
<li>依赖中心化服务发现机制</li>
<li>使用Soap通讯协议，通常使用XML格式来序列化通讯数据，xml格式非常喜欢重，比较占宽带传输。</li>
<li>服务化管理和治理设施不完善</li>
<li>不适合前后端分离架构模式</li>
</ul>
<h5 id="微服务架构基本概念"><a href="#微服务架构基本概念" class="headerlink" title="微服务架构基本概念"></a>微服务架构基本概念</h5><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中：每个服务必须独立部署、互不影响，微服务架构模式体现轻巧、轻量级、适合于互联网公司开发模式。</p>
<p>微服务架构倡导应用程序设计程多个独立、可配置、可运行和可微服务的子服务。<br>服务与服务通讯协议采用Http协议，使用restful风格API形式来进行通讯，数据交换格式轻量级json格式通讯，整个传输过程中，采用二进制，所以http协议可以跨语言平台，并且可以和其他不同的语言进行相互的通讯，所以很多开放平台都采用http协议接口。<br><img src="/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/%E5%BE%AE%E6%9C%8D%E5%8A%A11.png" alt="SOA架构"><br><img src="/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/%E5%BE%AE%E6%9C%8D%E5%8A%A12.png" alt="SOA架构"></p>
<h5 id="微服务架构与SOA架构的不同"><a href="#微服务架构与SOA架构的不同" class="headerlink" title="微服务架构与SOA架构的不同"></a>微服务架构与SOA架构的不同</h5><p>1.微服务架构基于 SOA架构 演变过来，继承 SOA架构的优点，在微服务架构中去除 SOA 架构中SOAP协议和 ESB 企业服务总线，采用 http+json（restful）进行传输。<br>2.微服务架构比 SOA 架构粒度会更加精细，让专业的人去做专业的事情（专注），目的提高效率，每个服务于服务之间互不影响，微服务架构中，每个服务必须独立部署，微服务架构更加轻巧，轻量级。<br>3.SOA 架构中可能数据库存储会发生共享，微服务强调独每个服务都是单独数据库，保证每个服务于服务之间互不影响。<br>4.项目体现特征微服务架构比 SOA 架构更加适合与互联网公司敏捷开发、快速迭代版本，因为粒度非常精细。</p>
<h5 id="微服务架构会产生那些问题"><a href="#微服务架构会产生那些问题" class="headerlink" title="微服务架构会产生那些问题"></a>微服务架构会产生那些问题</h5><p>分布式事务解决方案(rabbitmq/rocketmq/lcn(已经淘汰)/ Seata)<br>分布式任务调度平台(XXL-Job、阿里Scheduler)<br>分布式日志采集系统ELK+Kafka<br>分布式服务注册中心 eureka、Zookeeper、consule、nacos等。<br>分布式服务追踪与调用链Zipkin等。<br>分布式服务配置中心（springcloud config/携程阿波罗/nacos/disconfig）</p>
<p>非常重要的概念：独立部署、可配置、动态化</p>
<h5 id="为什么我们要使用SpringCloud"><a href="#为什么我们要使用SpringCloud" class="headerlink" title="为什么我们要使用SpringCloud"></a>为什么我们要使用SpringCloud</h5><p>SpringCloud并不是rpc远程调用框架，而是一套全家桶的微服务解决框架，理念就是解决我们在微服务架构中遇到的任何问题。</p>
<h5 id="SpringCloud第一代与第二代的区别"><a href="#SpringCloud第一代与第二代的区别" class="headerlink" title="SpringCloud第一代与第二代的区别"></a>SpringCloud第一代与第二代的区别</h5><p><img src="/2020/08/04/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/%E5%8C%BA%E5%88%AB.png" alt="SOA架构"><br><strong>SpringCloud第一代实际上都是用的Netflix开源的组件整合微服务解决方案。</strong></p>
<ul>
<li>SpringCloud Config 分布式配置中心</li>
<li>SpringCloud Netflix 核心组件</li>
<li>Eureka:服务治理 </li>
<li>Hystrix:服务保护框架</li>
<li>Ribbon:客户端负载均衡器</li>
<li>Feign：基于ribbon和hystrix的声明式服务调用组件</li>
<li>Zuul: 网关组件,提供智能路由、访问过滤等功能。</li>
</ul>
<p><strong>SpringCloud第二代（自己研发）和优秀的组件组合：</strong></p>
<ul>
<li>Spring Cloud Gateway 网关</li>
<li>Spring Cloud Loadbalancer 客户端负载均衡器</li>
<li>Spring Cloud r4j(Resilience4J) 服务保护</li>
<li>Spring Cloud Alibaba Nacos 服务注册</li>
<li>Spring Cloud Alibaba Nacos 分布式配置中心</li>
<li>Spring Cloud Alibaba Sentinel服务保护 </li>
<li>SpringCloud Alibaba Seata分布式事务解决框架</li>
<li>Alibaba Cloud OSS 阿里云存储</li>
<li>Alibaba Cloud SchedulerX 分布式任务调度平台</li>
<li>Alibaba Cloud SMS 分布式短信系统</li>
</ul>
<h5 id="为什么Alibaba要推出SpringCloud组件"><a href="#为什么Alibaba要推出SpringCloud组件" class="headerlink" title="为什么Alibaba要推出SpringCloud组件"></a>为什么Alibaba要推出SpringCloud组件</h5><p>目的就是为了对阿里云的产品实现扩展。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>线上问题的定位与解决方案</title>
    <url>/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一、问题搜集"><a href="#一、问题搜集" class="headerlink" title="一、问题搜集"></a>一、问题搜集</h3><p><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/1.jpg" alt="问题搜集"><br>当学生遇到问题，可以有两种途径进行反馈：</p>
<ul>
<li>1.软件的反馈功能<br>运营老师看到反馈并不会立即反馈到技术支持那里，而是先去了解相关的情况，看是个例还是大规模学生都出现问题，如果是个例会先让学生进行排查，能解决就解决，如果解决不了就会反馈到报警群联系相关技术老师进行排查。</li>
<li>2.反馈给老师<br>反馈到授课老师那里的话，老师会在对接群里联系相关的技术支持老师进行排查，技术支持再去联系运营了解相关的情况。</li>
</ul>
<p>通过这些渠道，梳理成<code>问题list</code>，之后反馈到产品、测试及研发老师那里，进行问题的整理和分类。</p>
<p><strong>举例</strong><br>1.技术支持老师首先会提供临时方案，然后把近期所有类似问题的信息整理好发给产研团队<br>2.运营老师整理课后评价数据，发现反馈用户卡顿占比5%，将该问题反映给产研团队</p>
<a id="more"></a>

<h3 id="二、问题分类"><a href="#二、问题分类" class="headerlink" title="二、问题分类"></a>二、问题分类</h3><p><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/2.jpg" alt="问题分类"><br>根据这些线上问题，大体可以分为三类：</p>
<h6 id="1-线上bug"><a href="#1-线上bug" class="headerlink" title="1.线上bug"></a>1.线上bug</h6><p>比如：</p>
<ul>
<li>回放倍速功能失效</li>
<li>题目答对了，但是显示答题错误</li>
</ul>
<h6 id="2-优化建议"><a href="#2-优化建议" class="headerlink" title="2.优化建议"></a>2.优化建议</h6><p>比如：</p>
<ul>
<li>在线课堂浅颜色对孩子眼睛不好，可否调成深颜色</li>
<li>上课答题过程中可否不看其他同学的视频</li>
</ul>
<h6 id="3-专项问题"><a href="#3-专项问题" class="headerlink" title="3.专项问题"></a>3.专项问题</h6><p>比如：</p>
<ul>
<li>直播卡顿</li>
<li>无法收到互动<br><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/3.jpg" alt="专项问题的分类"></li>
</ul>
<p><strong>专项问题的特点：</strong></p>
<ul>
<li>1.系统中某一个特定功能、核心客户端或某一项基础能力出现问题；</li>
<li>2.专项中有若干影响用户体验的待解决问题/待完成的工作；</li>
<li>3.有可衡量稳定性的指标；</li>
</ul>
<h3 id="三、问题解决方案"><a href="#三、问题解决方案" class="headerlink" title="三、问题解决方案"></a>三、问题解决方案</h3><p><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/4.jpg" alt="问题分类"></p>
<h4 id="1-对于无法复现的bug"><a href="#1-对于无法复现的bug" class="headerlink" title="1.对于无法复现的bug"></a>1.对于无法复现的bug</h4><ul>
<li>1.和用户沟通：看是否特殊操作、特殊环境引起的问题</li>
<li>2.内部众测：有一些问题需要用户量达到一定程度才会出现</li>
<li>3.增加打点：通过增加打点日志，辅助定位问题</li>
<li>4.代码分析：从代码层面查找漏洞，寻找可能的原因并进行修复</li>
</ul>
<h4 id="2-问题专项"><a href="#2-问题专项" class="headerlink" title="2.问题专项"></a>2.问题专项</h4><h5 id="2-1-确认专项问题"><a href="#2-1-确认专项问题" class="headerlink" title="2.1 确认专项问题"></a>2.1 确认专项问题</h5><p><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/5.jpg" alt="问题分类"><br>主要确定<code>当前数据指标</code>和<code>需要解决的主要问题</code><br><strong>建立技术指标的好处</strong></p>
<ul>
<li>1.系统稳定性有数据支撑；</li>
<li>2.被挑战时拿数据说话；</li>
</ul>
<p>数据指标业界统一！！！</p>
<h5 id="2-2-确定重要干系人"><a href="#2-2-确定重要干系人" class="headerlink" title="2.2 确定重要干系人"></a>2.2 确定重要干系人</h5><p>确定<code>产品负责人</code>和<code>技术负责人</code></p>
<h5 id="2-3-确定项目目标"><a href="#2-3-确定项目目标" class="headerlink" title="2.3 确定项目目标"></a>2.3 确定项目目标</h5><p>包括<code>数据指标提升</code>和<code>需要解决的问题list</code></p>
<h5 id="2-4-梳理核心工作"><a href="#2-4-梳理核心工作" class="headerlink" title="2.4 梳理核心工作"></a>2.4 梳理核心工作</h5><p>确定<code>工作内容</code>和<code>所需资源和时间</code></p>
<h5 id="2-5-每周跟进"><a href="#2-5-每周跟进" class="headerlink" title="2.5 每周跟进"></a>2.5 每周跟进</h5><ul>
<li>同步本周数据（优化前后的数据对比）</li>
<li>主要工作进度跟踪</li>
<li>需要协调的资源和需要解决的阻塞点</li>
</ul>
<h5 id="2-6-跟随版本上线，达到目标后结束专项"><a href="#2-6-跟随版本上线，达到目标后结束专项" class="headerlink" title="2.6 跟随版本上线，达到目标后结束专项"></a>2.6 跟随版本上线，达到目标后结束专项</h5><ul>
<li>优化内容上线后验证数据/重点问题解决效果</li>
<li>达到目标后结束专项<br><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/6.png" alt="问题分类"></li>
</ul>
<h3 id="四、线上问题解决流程"><a href="#四、线上问题解决流程" class="headerlink" title="四、线上问题解决流程"></a>四、线上问题解决流程</h3><p><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/7.png" alt="问题分类"></p>
<h3 id="五、提升解决问题效率"><a href="#五、提升解决问题效率" class="headerlink" title="五、提升解决问题效率"></a>五、提升解决问题效率</h3><p>打造提升工作效率的平台<br>包括：<br><img src="/2020/09/24/%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/8.jpg" alt="问题分类"></p>
]]></content>
      <categories>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>服务注册与发现nacos</title>
    <url>/2020/08/05/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0nacos/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="服务治理基本的概念"><a href="#服务治理基本的概念" class="headerlink" title="服务治理基本的概念"></a>服务治理基本的概念</h3><p><strong>服务治理概念：</strong><br>在RPC远程调用过程中，服务与服务之间依赖关系非常大，服务Url地址管理非常复杂，所以这时候需要对我们服务的url实现治理，通过服务治理可以实现服务注册与发现、负载均衡、容错等。<br><strong>服务注册中心的概念</strong><br>每次调用该服务如果地址直接写死的话，一旦接口发生变化的情况下，这时候需要重新发布版本才可以该接口调用地址，所以需要一个注册中心统一管理我们的服务注册与发现。</p>
<a id="more"></a>

<p><strong>注册中心：</strong><br>我们的服务注册到我们注册中心，key为<code>服务名称</code>、value为<code>该服务调用地址</code>，该类型为集合类型。常用的注册中心有：Eureka、consul、zookeeper、nacos等。</p>
<p><strong>服务注册:</strong><br>我们生产者项目启动的时候，会将当前服务自己的信息地址注册到注册中心。</p>
<p><strong>服务发现:</strong><br>消费者从我们的注册中心上获取生产者调用的地址（集合），在使用负载均衡的策略获取集群中某个地址实现本地rpc远程调用。</p>
<h3 id="微服务调用接口常用名词"><a href="#微服务调用接口常用名词" class="headerlink" title="微服务调用接口常用名词"></a>微服务调用接口常用名词</h3><p><strong>生产者：</strong> 提供接口被其他服务调用<br><strong>消费者：</strong> 调用生产者接口实现消费<br><strong>服务注册：</strong> 将当前服务地址注册<br><strong>服务发现：</strong><br><img src="/2020/08/05/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0nacos/1.png" alt="微服务调用接口常用名词"></p>
<h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos可以实现分布式服务注册与发现/分布式配置中心框架。<br>官网的介绍: <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p>
<p>Nacos安装及基本操作：<a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机内存</title>
    <url>/2020/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><ul>
<li>L0:寄存器（最快、最小、成本最高）</li>
<li>L1:高速缓存</li>
<li>L2:高速缓存</li>
<li>L3:高速缓存</li>
<li>L4:主存</li>
<li>L5:磁盘</li>
<li>L6:远程文件存储<a id="more"></a>

</li>
</ul>
<h1 id="多核CPUL1、L2、L3缓存和内存结构和读取逻辑"><a href="#多核CPUL1、L2、L3缓存和内存结构和读取逻辑" class="headerlink" title="多核CPUL1、L2、L3缓存和内存结构和读取逻辑"></a>多核CPUL1、L2、L3缓存和内存结构和读取逻辑</h1><p><img src="/2020/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98/1.jpg" alt="计算机内存"></p>
<ul>
<li>ALU在读取数据的时候会先从L1中取，L1没有读L2,L2没有读L3,L3还没有则直接从主存中去读。</li>
<li>L1和L2位于一个CPU核的内部</li>
<li>每颗CPU里面有一个三级缓存，在一颗CPU的每个核中是共享的</li>
<li>每次拿数据的时候都是按块读取，一块的大小大概是64字节</li>
<li>缓存行的概念</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程相关面试题</title>
    <url>/2020/10/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h2 id="Java中进程和线程的关系"><a href="#Java中进程和线程的关系" class="headerlink" title="Java中进程和线程的关系"></a>Java中进程和线程的关系</h2><p>Java对操作系统提供的功能进行封装，包括进程和线程<br>运行一个程序会产生一个进程，进程包含至少一个线程<br>每个进程对应一个JVM实例，多个线程共享JVM里的堆<br>Java采用单线程编程模型，程序会自动创建主线程<br>主线程可以创建子线程，原则上要后于子线程完成执行</p>
<a id="more"></a>

<h2 id="start和run方法的区别"><a href="#start和run方法的区别" class="headerlink" title="start和run方法的区别"></a>start和run方法的区别</h2><p>调用start()方法会创建一个新的子线程并启动<br>run()方法只是Thread的一个普通方法的调用<br>start()方法会去调用start0()方法，是一个native方法，底层是调用JVM_StartThread方法创建一个线程去调用run方法</p>
<h2 id="Thread和Runnable是什么关系？"><a href="#Thread和Runnable是什么关系？" class="headerlink" title="Thread和Runnable是什么关系？"></a>Thread和Runnable是什么关系？</h2><p>Thread是一个类，这个类实现了Runnable接口，使得run支持多线程<br>因类的单一继承原则，推荐多使用Runnable接口</p>
<h2 id="如何给run-方法传参？"><a href="#如何给run-方法传参？" class="headerlink" title="如何给run()方法传参？"></a>如何给run()方法传参？</h2><p>构造函数传参<br>成员变量传参<br>回调函数传参</p>
<h2 id="如何实现处理线程的返回值？"><a href="#如何实现处理线程的返回值？" class="headerlink" title="如何实现处理线程的返回值？"></a>如何实现处理线程的返回值？</h2><h3 id="1-主线程等待法：让主线程循环等待，直到目标子线程返回为止"><a href="#1-主线程等待法：让主线程循环等待，直到目标子线程返回为止" class="headerlink" title="1.主线程等待法：让主线程循环等待，直到目标子线程返回为止"></a>1.主线程等待法：让主线程循环等待，直到目标子线程返回为止</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CycleWait</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">value</span> = <span class="string">&quot;we have data now&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws InterruptedException</span> &#123;</span><br><span class="line">        CycleWait cycleWait = <span class="keyword">new</span> CycleWait();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(cycleWait);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">while</span> (cycleWait.<span class="keyword">value</span> == <span class="literal">null</span>)&#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;value:&quot;</span>+ cycleWait.<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-使用Thread类的join方法阻塞当前线程以等待子线程处理完毕"><a href="#2-使用Thread类的join方法阻塞当前线程以等待子线程处理完毕" class="headerlink" title="2.使用Thread类的join方法阻塞当前线程以等待子线程处理完毕"></a>2.使用Thread类的join方法阻塞当前线程以等待子线程处理完毕</h3><h3 id="3-通过Callable接口实现，通过FutureTask或者线程池获取"><a href="#3-通过Callable接口实现，通过FutureTask或者线程池获取" class="headerlink" title="3.通过Callable接口实现，通过FutureTask或者线程池获取"></a>3.通过Callable接口实现，通过FutureTask或者线程池获取</h3><h2 id="线程的六个状态"><a href="#线程的六个状态" class="headerlink" title="线程的六个状态"></a>线程的六个状态</h2><ul>
<li>新建(new)：创建后尚未启动的线程的状态    </li>
<li>运行(Runnable):包含Running和Ready</li>
<li>无限等待(WAITING)：不会被分配CPU执行时间，需要显式被唤醒<br>  没有设置Timeout参数的Object.wait()方法<br>  没有设置Timeout参数的Thread.join()方法<br>  LockSupport.park()方法</li>
<li>限期等待(TIMED_WAITING)：在一定时间后会由系统自动唤醒<br>  Thread.sleep()方法<br>  设置了Timeout参数的Object.wait()方法<br>  设置了Timeout参数的Thread.join()方法<br>  LockSupport.parkNanos()方法<br>  LockSupport.parkUntil()方法</li>
<li>阻塞(BLOCKED):等待获取排他锁</li>
<li>结束(TERMINATED):已终止线程的状态，线程已经执行结束。一个线程处于结束状态就不能进行start()了</li>
</ul>
<h3 id="阻塞状态与等待方法的区别："><a href="#阻塞状态与等待方法的区别：" class="headerlink" title="阻塞状态与等待方法的区别："></a>阻塞状态与等待方法的区别：</h3><p>阻塞状态在等待获取排他锁，这个事件将在一个线程放弃这个锁的时候发生<br>等待状态是等待一段时间或者有唤醒动作的时候发生<br>在程序等待进入同步区域的时候，线程将进入阻塞状态，比如当某个线程进入synchronized关键字修饰的方法（即获取锁去执行）的时候，其他想执行该方法的线程就只能等着，他们的状态就是BLOCKED</p>
<h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><p>sleep是Thread类的方法，wait是Object类中定义的方法<br>sleep是可以在任何地方去使用的<br>wait方法只能在synchronized方法或synchronized代码块中使用<br>Thread.sleep只会让出CPU，不会导致锁行为的改变<br>Object.wait不仅让出CPU，还会释放已经占有的同步资源锁</p>
<h2 id="notify和notifyAll的区别"><a href="#notify和notifyAll的区别" class="headerlink" title="notify和notifyAll的区别"></a>notify和notifyAll的区别</h2><p>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会<br>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</p>
<h3 id="1-两个概念"><a href="#1-两个概念" class="headerlink" title="1.两个概念"></a>1.两个概念</h3><p><strong>锁池EntryList</strong><br>假设线程A已经拥有了某个对象的锁，而其他线程B、C想要调用这个对象的某个synchronized方法，由于B、C线程在进入对象的synchronized方法之前必须先获取该对象锁的拥有权，而恰巧该对象的锁目前正在被线程A锁占用，此时B、C线程就会被阻塞，进入一个地方去等待锁的释放，这个地方便是该对象的锁池<br><strong>等待池WaitSet</strong><br>假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁，同时线程A就进入到了该对象的等待池中，进入到等待池中的线程不会竞争该对象的锁</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p>当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用权的暗示，但是线程调度器可能会忽略这个暗示</p>
<h2 id="如何中断线程"><a href="#如何中断线程" class="headerlink" title="如何中断线程"></a>如何中断线程</h2><h3 id="1-已经被抛弃的方法"><a href="#1-已经被抛弃的方法" class="headerlink" title="1.已经被抛弃的方法"></a>1.已经被抛弃的方法</h3><p>通过调用stop()方法停止线程，可以由一个线程去停止另一个线程，这个方法太过暴力而且不安全<br>通过调用线程实例的suspend()和resume()方法</p>
<h3 id="2-目前使用的方法"><a href="#2-目前使用的方法" class="headerlink" title="2.目前使用的方法"></a>2.目前使用的方法</h3><ul>
<li>调用interrupt()，通知线程应该中断了</li>
</ul>
<p>1.如果一个线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常<br>2.如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="一-OSI七层协议"><a href="#一-OSI七层协议" class="headerlink" title="一.OSI七层协议"></a>一.OSI七层协议</h1><p><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82.jpg" alt="计算机网络"></p>
<ul>
<li>1.物理层<br>  机器A往机器B发送比特流，机器B要保证能收到比特流，这就是物理层要做的事情。物理层主要定义了网络设备的标准，如：网线的类型、光纤的接口类型。网卡就是工作在这一层里面的，这一层主要负责数模、模数的转换（比特流转化为电流，电流再转化为比特流）</li>
<li>2.数据链路层<br>  在传输比特流的过程中，会产生错传、数据传输不完整的可能，因此数据链路层定义了如何格式化数据以进行传输，这一层通常还提供错误检测和纠正，以确保数据传输的可靠性，本层将比特数据组成了“帧”，其中交换机工作在这一层中，对帧解码，并根据帧中包含的信息将数据发送给正确的接收方</li>
<li>3.网络层<br>  随着网络节点的不断增加，点对点通信的时候是需要经过多个节点的，如何找到目标节点、如何找到最佳路径便成为了首要需求，此时便有了网络层。其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个节点A到另一个节点B的最佳路径。路由器属于网络层，此时的数据我们称之为“数据包”。本层需要关注的协议主要是TCP/IP协议中的IP协议</li>
<li>4.传输层<br>  随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据（如海量文件的传输，可能需要很长的时间），而网络在通信的过程中会中断好多次，此时为了保证传输大量文件时的准确性，需要对发出去的数据进行切分，切分为一个个的小段落(segment),其中一个段落丢失了怎么办？要不要重传？每个段落要按照顺序到达吗？这些便是传输层需要考虑的问题了。传输层解决了数据之间的传输，解决了传输质量的问题，该层为OSI模型中最终要的一层。以太网无法接收超过1500字节的数据包。本层需要关注的协议主要是TCP/IP协议中的TCP协议和UDP协议。</li>
<li>5.会话层<br>  建立和管理应用程序之间的通信</li>
<li>6.表示层<br>  windows上无法运行linux中的脚本文件，机器之间存在数据通信的语法差异。表示层就是为了解决不同和操作系统之间的通信语法问题。在表示层，数据将按照网络能理解的方案进行格式化，这种格式化也因所使用网络的类型不同而不同。</li>
<li>7.应用层<br>  规定发送方和接收方必须使用固定格式的消息头，消息头必须使用某种固定的组成，而且消息头里必须记录消息体的长度等一系列信息，以方便接受方能够正确地解析发送方发送的数据，应用层旨在让我们更方便地应用从网络中接收到的数据。本层需要关注的协议主要是TCP/IP协议中的HTTP协议。<a id="more"></a>

</li>
</ul>
<h1 id="二-TCP-IP概念层模型"><a href="#二-TCP-IP概念层模型" class="headerlink" title="二.TCP/IP概念层模型"></a>二.TCP/IP概念层模型</h1><ul>
<li>1.应用层（应用层、表示层、会话层）</li>
<li>2.传输层</li>
<li>3.网络层</li>
<li>4.链路层（数据链路层，物理层）</li>
</ul>
<h2 id="2-1-IP协议"><a href="#2-1-IP协议" class="headerlink" title="2.1 IP协议"></a>2.1 IP协议</h2><ul>
<li>IP协议是无连接的通信协议，它不会占用两个正在通信的计算机之间的通信线路，这样IP就降低对网络线路的需求，每条线都可以满足许多计算机之间的通信需要，通过IP，消息或者其他会被分割为较小的独立的包，并通过在因特网在计算机之间传送。IP负责将每个包，路由至其目的地。但IP协议没有做任何事情来确认数据包是否按顺序发送，或者包被破坏。所以IP数据包是不可靠的，需要由它的上层协议作出控制。</li>
</ul>
<h2 id="2-2-TCP协议"><a href="#2-2-TCP协议" class="headerlink" title="2.2 TCP协议"></a>2.2 TCP协议</h2><ul>
<li>传输控制协议TCP 是传输层的协议</li>
<li>面向连接的，可靠的，基于字节流的传输层通信协议</li>
<li>将应用层的数据流分割成报文段并发送给目标节点的TCP层<br>  报文段的长度通常受该计算机连接网络的数据链路层最大传输单元及MPU的限制，之后TCP把结果包传给IP层</li>
<li>数据包都有序号，对方收到则发送ACK确认，未收到则重传<br>  数据包有序号的原因就是为了保证包不丢失，序列号(Sequence Number),也保证了传送到目标节点包的按序处理。然后接收端实体对已成功收到的包发回一个相应的确认，即ACK确认。如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包会被认为已丢失，并且将会对其进行重传。</li>
<li>使用校验和未校验数据在传输过程中是否有误<br>  TCP用奇偶校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和</li>
</ul>
<h2 id="2-3-TCP报文头"><a href="#2-3-TCP报文头" class="headerlink" title="2.3 TCP报文头"></a>2.3 TCP报文头</h2><p><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E5%A4%B4.jpg" alt="tcp报文头"><br><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E5%A4%B41.jpg" alt="tcp报文头"><br><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E5%A4%B42.jpg" alt="tcp报文头"><br>TCP报文是TCP层传输的数据单元，也叫报文段。</p>
<ul>
<li><p><strong>1.端口号</strong>：用来标识同一台计算机的不同的应用进程。<br>  1）源端口：源端口和IP地址的作用是标识报文的返回地址。<br>  2）目的端口：端口指明接收方计算机上的应用程序接口。<br>  TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。</p>
</li>
<li><p><strong>2.序号和确认号</strong>：是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。<br>  一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。</p>
</li>
<li><p><strong>3.数据偏移／首部长度：</strong><br>  4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8 = 60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。</p>
</li>
<li><p><strong>4.控制位</strong><br>  由8个标志位来组成，每个标志位表示一个控制的功能，其中常见的包括：</p>
  <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">URG: 紧急指针标志。<span class="number">1</span>-紧急指针有效，<span class="number">0</span>-忽略紧急指针</span><br><span class="line">ACK: 确认序号标志。<span class="number">1</span>-确认序号有效，<span class="number">0</span>-报文中不含确认信息，忽略确认字段</span><br><span class="line">PSH: push标志。<span class="number">1</span>-表有push的标志，指示接收方在接收到报文段以后，应尽快将报文段交给应用程序，而不是在缓冲区排队  </span><br><span class="line">RST: 重置连接标志。用于重置，主机崩溃或者其他原因而出现错误的连接，或者用于拒绝非法的报文端和拒绝连接请求</span><br><span class="line">SYN: 同步序号，用于建立连接过程，在连接请求中SYN=<span class="number">1</span>,ACK=<span class="number">0</span>表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=<span class="number">1</span>,ACK=<span class="number">1</span></span><br><span class="line">FIN: finsh标志。用于释放连接，唯一标识发送方没有数据发送，即关闭本方数据流，</span><br></pre></td></tr></table></figure></li>
<li><p><strong>5.窗口</strong><br>  滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小是一个16bit字段，因而窗口大小最大为65535。</p>
</li>
<li><p><strong>7.校验和</strong><br>  奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。</p>
</li>
<li><p><strong>8.紧急指针</strong><br>  只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
</li>
<li><p><strong>9.选项和填充</strong><br>  最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。</p>
</li>
<li><p><strong>10.数据部分</strong><br>   TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p>
</li>
</ul>
<h1 id="三-TCP三次握手"><a href="#三-TCP三次握手" class="headerlink" title="三.TCP三次握手"></a>三.TCP三次握手</h1><p>当应用程序希望通过TCP与另一个应用通信时，它会发送一个通信请求，这个请求必须被送到一个确切的地址，在双方握手之后，TCP将在两个应用之间建立一个全双通的通信，这个全双通（A可以给B发送信息的同时，B也能够给A发信息）的通信将占用两个计算机之间的通信线路，直到被一方，或者双方关闭为止。</p>
<p><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="tcp三次握手"></p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><ul>
<li>一开始客户端和服务器端都处于<code>Close</code>状态。</li>
<li>刚开始的时候TCP服务器进程先创建传输控制块(<code>PCD</code>)，时刻准备接受其他客户进程发送过来的连接请求。</li>
<li>此时服务端进入了Listen，即监听的状态。此时客户端进程也先创建一个传输控制块(<code>PCD</code>)然后向服务器发出连接请求报文，<code>SYN</code>就是<code>TCP Flags</code>的同步序号，SYN =1,选择一个初始序号seq =x ,x可以是任意的正整数值。</li>
<li>此时TCP客户端进程就进入了一个<code>SYN-SENT</code>同步已发送的状态，发送给服务端的数据包，即报文端会被称为SYN报文段，不能携带数据，但是要消耗一个序号。</li>
</ul>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><ul>
<li>当服务器接收到一个报文请求之后，同意连接，则发出确认报文，确认报文中包含TCP Flags中的<code>SYN,ACK</code>两位的字段。</li>
<li>SYN=1,ACK=1,seq=y,ack=x+1。</li>
<li>ack = x+1的原因是第一次握手SYN报文中指定了seq=x,服务端要回应相关的信息，并且第一次握手中报文消耗了一个序号，因此ack=x+1,同时为自己的缓存初始化一个序列号，即seq=y。此时服务器就进入到了<code>SYN-RCVD</code>,即同步收到的状态。</li>
<li>这个报文也是不能携带数据的，同时也需要消耗一个序号。</li>
</ul>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><ul>
<li><p>当TCP客户进程收到确认报文之后，还要给服务器一个确认。<code>ACK=1,seq=x+1,ack=y+1</code></p>
</li>
<li><p>ack=y+1,原因是服务器给客户端发送一个seq=y，客户端作为回应。所以就加了1。同时第二次握手的报文会消耗一个序号。</p>
</li>
<li><p>同时第一次握手的时候，客户端告知(ack)服务器序号被+1了，即seq =x ,第二次握手时ack=x +1 。所以第三次握手时候seq = x+ 1。</p>
</li>
<li><p>此时TCP连接建立，客户端就进入了<code>ESTAB-LISHED</code>,即已建立连接的状态，此时TCP规定这个时候的报文段可以携带数据。第一次，第二次握手的报文段都是不可以携带的。也可以不携带数据，这样就不会消耗序号了。</p>
</li>
<li><p>当服务器也收到了客户端的确认后也会进入<code>ESTAB-LISHED</code>状态。</p>
</li>
</ul>
<p>完成三次握手之后，双方就可以开始通信了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>在TCP/IP协议中，TCP协议提供可靠的链接服务，采用三次握手建立一个连接</li>
<li>第一次握手：建立连接时，客户端发送SYN包(SYN=j)到服务器，进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到SYN包，必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1),此时包发送完毕，客户端和服务区进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<h1 id="四-TCP四次挥手"><a href="#四-TCP四次挥手" class="headerlink" title="四.TCP四次挥手"></a>四.TCP四次挥手</h1><ul>
<li>断开一个TCP连接时，需要客户端和服务器端总共发出4个包，以确认连接的断开。</li>
<li>在Socket编程中，这过程由客户端或服务端任一方，执行Close来触发。</li>
</ul>
<p>“挥手”是为了终止连接，TCP四次挥手的流程图如下</p>
<p><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="tcp四次挥手"><br>上图由客户端主动触发close。数据传送完毕之后，双方都可以释放连接，最开始的时候客户端和服务端都处于ESTABLISHED状态。然后客户端主动关闭，服务器被动关闭。</p>
<h2 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h2><p>首先客户端进程发出连接释放报文（FIN），并且停止发送数据。在该数据报的报头中，TCP Flags 中的 FIN = 1，假设客户端定义的序列号为seq=u，该值等于前面ESTABLISHED状态数据最后一次发送的时候，已经传送过来的数据的最后一个字节的序号加上1。此时客户端就进入了FINWAIT1,这个终止等待1的状态。TCP规定即使FIN不携带数据，也要消耗掉一个序号。即回值的时候u要加上1。</p>
<h2 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h2><p>当服务器收到连接释放报文之后，也要发出确认报文，即ACK=1。作为回应akc=u+1,并且也带上了自己的序列号seq=v。此时服务端就进入了CLOSEWAIT,关闭等待的状态。TCP服务器通知高层的进程，客服端要释放与服务器之间的连接，这时候会处于半关闭的状态，即客户端没有数据要发送了，但是服务器要发送数据，客户端还是能够接受的。CLOSEWAIT状态还要持续一段时间。</p>
<h2 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h2><p>客户端收到服务器的确认请求之后，客户端就进入了FIN_WAIT_2,即终止等待2状态。等待服务器发送释放连接报文，也就是第三次挥手的请求。因此在这个时间内还需要接收服务器发送最后的数据，服务器将最后的数据发送完毕后就会向客户端发送连接释放报文，FIN=1,ack=u+1。有可能在半关闭的状态，服务器很可能又发送了一些数据，假定此时的序号变为了w。此时服务器就进入到了LAST_ACK的状态。等待客户端的最终确认。</p>
<h2 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h2><p>客户端在收到服务器的连接释放报文之后，必须发出确认，即ACK=1，然后再将服务器发送过来的w变成w+1,回发给服务器。</p>
<p>此时的seq为u+1。此时客户端就进入了TIME_WAIT,即时间等待的状态，这时客户端的TCP连接还没有释放，必须经过2MSL时间后，连接才会真正的释放，才会进入到CLOSED状态。MSL最长报文段生命。在Linux MSL 为30s,而服务器只要收到客户端发出的确认，立即就进入CLOSED状态。</p>
<p>由图可知，<strong>服务器结束TCP的连接时间要比客户端稍早一些</strong>。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据，Client进入<code>FIN_WAIT_1</code>状态；</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入<code>CLOSE_WAIT</code>状态,Client进入<code>FIN_WAIT_2</code>状态</li>
<li>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入<code>LAST_ACK</code>状态；</li>
<li>第四次挥手：Client收到FIN后，Client进入<code>TIME_WAIT</code>状态，接着发送一个ACK给Server,确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</li>
</ul>
<h2 id="4-1-为什么会有TIME-WAIT状态？"><a href="#4-1-为什么会有TIME-WAIT状态？" class="headerlink" title="4.1 为什么会有TIME_WAIT状态？"></a>4.1 为什么会有TIME_WAIT状态？</h2><ul>
<li>确保由足够的时间让对方收到ACK<br>  TIME_WAIT状态用来保证有足够的时间让对端接收完ACK，如果被动关闭的那方没有收到ACK就会触发被动端重发FIN包，一来一去正好是2MSL。</li>
<li>避免新旧连接混淆<br>  有足够的时间让这个连接，不会跟后面的连接混在一起，因为有些路由器会缓存IP数据包。如果连接被重用了，那么这些延迟被收到的包就有可能跟新连接混在一起</li>
</ul>
<h2 id="4-2-为什么需要四次挥手才能断开连接？"><a href="#4-2-为什么需要四次挥手才能断开连接？" class="headerlink" title="4.2 为什么需要四次挥手才能断开连接？"></a>4.2 为什么需要四次挥手才能断开连接？</h2><ul>
<li>全双通的意思是允许数据在两个方向上同时传输，即在同一时间，服务器可以发送数据给客户端，客户端也可以发送数据给服务器。</li>
<li>因为全双工，发送方和接收方都需要FIN报文和ACK报文</li>
<li>发送方和接收方各只需两两次挥手即可，只不过有一方是被动的，所以看上去就成了四次挥手</li>
</ul>
<h2 id="4-3-服务器出现CLOSE-WAIT状态的原因"><a href="#4-3-服务器出现CLOSE-WAIT状态的原因" class="headerlink" title="4.3 服务器出现CLOSE_WAIT状态的原因"></a>4.3 服务器出现CLOSE_WAIT状态的原因</h2><ul>
<li>问题其中一个表现是客户端一直在请求，但是返回给客户端的信息是异常的。服务端压根也没收到请求。</li>
<li>服务器保持大量的CLOSE_WAIT只有一种情况，那就是在对方发送一个FIN报文之后，程序这边没有进一步发送ACK，或者FIN报文以确认。</li>
</ul>
<h2 id="4-4-对方关闭Socket连接，我方忙于读或写，没有及时关闭连接"><a href="#4-4-对方关闭Socket连接，我方忙于读或写，没有及时关闭连接" class="headerlink" title="4.4 对方关闭Socket连接，我方忙于读或写，没有及时关闭连接"></a>4.4 对方关闭Socket连接，我方忙于读或写，没有及时关闭连接</h2><p>对方关闭连接后，程序里没有检测到，或者程序本身就已经忘了这个时候需要关闭连接，于是这个资源就被程序占用着。<br>遇到这种情况多数是程序里面有BUG，通常是有些连接没有释放<br><strong>检查代码，特别是释放资源代码</strong><br><strong>检查配置，特别是处理请求的线程配置</strong></p>
<h1 id="五-TCP和UDP的区别"><a href="#五-TCP和UDP的区别" class="headerlink" title="五.TCP和UDP的区别"></a>五.TCP和UDP的区别</h1><p>相比TCP报文，UDP的域少了很多。简单了很多。简单的报文结构意味着UDP不像TCP那样，支持错误重传，滑动窗口。</p>
<p><img src="/2020/11/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E5%92%8Cudp.jpeg" alt="TCP和UDP的区别"></p>
<h2 id="5-1UDP的特点"><a href="#5-1UDP的特点" class="headerlink" title="5.1UDP的特点"></a>5.1UDP的特点</h2><ul>
<li>面向非连接<br>  传输数据之前，源端和终端不建立连接，当它想传送时，就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。<br>  在发送端UDP传送数据的速度仅仅是受应用程序生成数据地速度，计算机的能力和传输带宽的限制。<br>  在接收端UDP把每个消息段放在队列中，应用程序每次从队列中读取一个消息段。</li>
<li>不维护连接状态，支持同时向多个客户端传输相同的消息<br>  由于传输数据不建立连接，所以不需要维护连接状态。</li>
<li>数据包报头只有8个字节，额外开销较小<br>  相对TCP的20个字节包小很多</li>
<li>吞吐量只受限于数据生成速率，传输速率以及机器性能<br>  吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的效率，传输带宽，源端和终端主机性能的限制。</li>
<li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li>
<li>面向报文，不对应用程序提交的报文信息进行拆分或者合并<br>  发送方的UDP对应用程序，交下来的报文，在添加守护后就向下交付给IP层，既不拆分，也不合并。而是保留报文的边界。因此应用程序应该选择合适的报文大小，UDP将多数的控制交给上层去解决。</li>
</ul>
<h2 id="5-2-总结"><a href="#5-2-总结" class="headerlink" title="5.2 总结"></a>5.2 总结</h2><p>TCP和UDP是OSI模型中，运输层的协议。TCP提供可靠的传输，而UDP常被用于让广播和细节控制交给应用层的通信传输。</p>
<ul>
<li>面向链接与面向无连接<br>  TCP有三次握手的过程，UDP合适消息的多播发布，从单个点向多个点发布信息</li>
<li>可靠性<br>  TCP利用握手，确认，重传机制提供了可靠性保证。UDP可能会被丢失，不知道有没有被接收</li>
<li>有序性<br>  TCP利用序列号保证了消息报的顺序交付，达到可能无序，但是TCP最终还是会排序的。<br>  UDP不具备有序性</li>
<li>速度<br>  TCP速度比较慢，因为要创建连接，保证消息的可靠性和有序性，需要额外做很多事。<br>  UDP比较适合对速度比较敏感的应用。比如在线视频媒体，电视广播，多人在线游戏。</li>
<li>量级<br>  TCP属于重量级的<br>  UDP属于轻量级的<br>  体现在源数据头部大小  TCP 20个字节  UDP 8个字节</li>
</ul>
<h1 id="六-TCP的滑动窗口"><a href="#六-TCP的滑动窗口" class="headerlink" title="六.TCP的滑动窗口"></a>六.TCP的滑动窗口</h1><pre><code>https://blog.csdn.net/qq_41398448/article/details/100775989</code></pre>
<h1 id="七-HTTP相关"><a href="#七-HTTP相关" class="headerlink" title="七.HTTP相关"></a>七.HTTP相关</h1><pre><code>https://blog.csdn.net/qq_41398448/article/details/100780050</code></pre>
<h1 id="八-HTTP和HTTPS的区别"><a href="#八-HTTP和HTTPS的区别" class="headerlink" title="八.HTTP和HTTPS的区别"></a>八.HTTP和HTTPS的区别</h1><pre><code>https://blog.csdn.net/qq_41398448/article/details/100830299</code></pre>
<h1 id="九-ping和talnet命令"><a href="#九-ping和talnet命令" class="headerlink" title="九.ping和talnet命令"></a>九.ping和talnet命令</h1><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>基于ICMP协议，验证IP的可达性，<code>ping ip地址</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">192.168</span><span class="number">.205</span><span class="number">.10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="talne"><a href="#talne" class="headerlink" title="talne"></a>talne</h3><p>检车服务的可用性,<code>ping ip地址 端口号</code></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ping <span class="number">192.168</span><span class="number">.205</span><span class="number">.10</span> <span class="number">8080</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="十-网络抓包工具"><a href="#十-网络抓包工具" class="headerlink" title="十.网络抓包工具"></a>十.网络抓包工具</h1><p>wireshark</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2020/08/06/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="本地负载均衡"><a href="#本地负载均衡" class="headerlink" title="本地负载均衡"></a>本地负载均衡</h3><p>本地负载均衡器基本的概念：我们的消费者服务从我们的注册中心获取到集群地址列表，缓存到本地，让后本地采用负载均衡策略（轮训、随机、权重、hash等），实现本地的rpc远程的。</p>
<h3 id="本地负载均衡器与Nginx-的区别"><a href="#本地负载均衡器与Nginx-的区别" class="headerlink" title="本地负载均衡器与Nginx 的区别"></a>本地负载均衡器与Nginx 的区别</h3><ul>
<li>Nginx是客户端所有的请求统一都交给我们的Nginx处理，然后再由Nginx实现负载均衡转发，属于服务器端负载均衡器。</li>
<li>本地负载均衡器是从注册中心获取到集群地址列表，本地实现负载均衡算法，既本地负载均衡器。</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>Nginx属于服务器负载均衡，应用于Tomcat/Jetty服务器等，</li>
<li>本地负载均衡器，应用于在微服务架构中rpc框架中，rest、openfeign、dubbo。</li>
</ul>
<a id="more"></a>
<h3 id="代码改造："><a href="#代码改造：" class="headerlink" title="代码改造："></a>代码改造：</h3><p>我本地并没有引入ribbon的包，但是springcloud二代默认集成了ribbon<br>在启动类中添加代码：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加上LoadBalanced注解就可以实现我们的本地负载均衡</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * SpringCloud rest或者openfeign客户端默认都是ribbon实现调用</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@LoadBalanced</span></span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在order模块中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> OrderController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 3:44 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancer loadBalancer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于ribbon实现本地负载均衡</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/orderToRibbonMember&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">orderToRibbonMember</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String result = restTemplate.getForObject(<span class="string">&quot;http://tinner-member/getUser&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;订单调用会员返回结果：&quot;</span>+ result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>orderToRibbonMember方法省略了之前两步，我们可以通过服务名称直接拿到服务器地址和host，然后让restTemplate通过自身的算法给我们挑选出一个服务器进行服务的调用。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Classname</span> OrderController</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2020/8/5 3:44 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by jinping</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认是default，轮询的算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">&quot;/orderByLoadbalancerClient&quot;</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object orderByLoadbalancerClient()&#123;</span><br><span class="line">        ServiceInstance result = loadBalancerClient.choose(<span class="string">&quot;tinner-member&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以看到会给我们返回服务器相关信息<br><img src="/2020/08/06/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/1.jpg" alt="orderByLoadbalancerClient"></p>
<h3 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h3><p>源码：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">package org.springframework.cloud.client.loadbalancer;</span><br><span class="line"></span><br><span class="line">import org.springframework.cloud.client.ServiceInstance;</span><br><span class="line"></span><br><span class="line">public<span class="built_in"> interface </span>ServiceInstanceChooser &#123;</span><br><span class="line">    ServiceInstance choose(String serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>LoadBalancerClient是spring自己实现的一套负载均衡策略器，choose方法通过serviceId拿到所有的服务器列表，然后内部通过默认的轮询策略挑选出一个表服务器返回出去。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">protected<span class="built_in"> Server </span>getServer(ILoadBalancer loadBalancer) &#123;</span><br><span class="line">    return loadBalancer == <span class="literal">null</span> ? <span class="literal">null</span> : loadBalancer.chooseServer(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收</title>
    <url>/2020/10/27/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="一-如何知道对象是一个垃圾？"><a href="#一-如何知道对象是一个垃圾？" class="headerlink" title="一.如何知道对象是一个垃圾？"></a>一.如何知道对象是一个垃圾？</h3><p>没有任何引用指向的对象就是垃圾。</p>
<ul>
<li>可达性分析(非GCRoot引用的对象)<ol>
<li>通过判断对象的引用链是否可达来决定对象是否可以被回收</li>
<li>通过一系列名为GCRoot的对象为起始点，从这些节点开始向下搜索，搜索所走过的路径就被称为引用链</li>
<li>当一个对象从GCRoot没有任何引用链相连，即从GCRoot到这个对象是不可达的，在这个时候就证明了这个对象是不可用的，可以进行回收</li>
</ol>
</li>
<li>引用计数法（判断对象的引用数量来决定对象是否可以被回收）<ol>
<li>每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1</li>
<li>任何引用计数为0的对象实例可以被当做垃圾收集<br>优点：执行效率高，程序执行受影响较小<br>缺点：无法检测出循环引用的情况，导致内存泄漏</li>
</ol>
</li>
</ul>
<a id="more"></a>

<h3 id="二-可以作为GCRoot的对象有哪些？"><a href="#二-可以作为GCRoot的对象有哪些？" class="headerlink" title="二.可以作为GCRoot的对象有哪些？"></a>二.可以作为GCRoot的对象有哪些？</h3><ul>
<li>虚拟机栈中引用的对象（栈帧中的本地变量表）</li>
<li>方法区中的常量引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中JNI(native方法）的引用对象</li>
<li>活跃线程的引用对象</li>
</ul>
<h3 id="三-GC算法"><a href="#三-GC算法" class="headerlink" title="三.GC算法"></a>三.GC算法</h3><ul>
<li>1.标记清除（有碎片）</li>
<li>2.拷贝算法（浪费空间，一般用于MinorGC,对于新生代的）</li>
<li>3.标记整理（一边做标记一边做整理，但是效率低）</li>
</ul>
<p><code>标记清除</code>和<code>标记整理</code>算法一般都是针对老年代进行回收的算法</p>
<h3 id="四-垃圾回收器"><a href="#四-垃圾回收器" class="headerlink" title="四.垃圾回收器"></a>四.垃圾回收器</h3><h4 id="需要了解的相关概念："><a href="#需要了解的相关概念：" class="headerlink" title="需要了解的相关概念："></a>需要了解的相关概念：</h4><ul>
<li>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)</li>
<li>Stop-the-world（STW）<br>  JVM由于要执行GC而停止了应用程序的执行<br>  任何一种GC算法中都会发生<br>  多数GC优化通过减少Stop-the-world发生的时间来提升程序性能</li>
<li>Safepoint（安全点）<br>  分析可达性的过程中引用关系不会发生变化的点<br>  产生Safepoint的地方：方法调用、循环跳转、异常跳转等<br>  安全点的数量需要适中。太少会让GC等待太长的时间，太多会增加程序运行的负荷</li>
<li>JVM的运行模式<br>  Server：启动较慢，但是启动成功之后server程序的运行效率要比Client快。采用的是重量级的虚拟机，对程序采用了更多的优化。<br>  Client：启动较快，采用的是轻量级的虚拟机<br>  通过<code>java -version</code>命令进行查看</li>
</ul>
<h4 id="1-分代模型"><a href="#1-分代模型" class="headerlink" title="1.分代模型"></a>1.分代模型</h4><p>对于新生代：</p>
<ul>
<li>Serial(最早的垃圾回收器，现在很少用，单线程)<br>  可以通过<code>-XX:+UseSerialGC</code>,使得年轻代使用该垃圾回收期进行回收<br>  在jdk1.3之前，是Java年轻代垃圾回收器的唯一选择<br>  单线程通过复制算法进行收集，在进行垃圾收集时，必须暂停所有的工作线程<br>  简单高效，是Client模式下默认的年轻代收集器</li>
<li>ParNew(多线程处理,工作在年轻代,专门和CMS做配合的)<br>  可以通过<code>-XX:+UseParNewGC</code>,使得年轻代使用该垃圾回收期进行回收<br>  多线程收集，其余的行为、特点和Serial收集器一样<br>  是Server模式下首选的年轻代回收器<br>  也是使用复制算法<br>  单核执行效率不如Serial，在多核下执行才有优势</li>
<li>Parallel Scavenge(多线程处理,工作在年轻代)<br>  可以通过<code>-XX:+UseParallelGC</code>,使得年轻代使用该垃圾回收期进行回收<br>  使用复制算法<br>  比起关注用户线程停顿时间，更关注系统的吞吐量<br>  在多核执行下才有优势，Server模式下默认的年轻代收集器<br>  自适应调节策略：<code>-XX:+UseAdaptiveSizePolicy</code>,会把内置管理的调优任务交给虚拟机去完成</li>
</ul>
<p>对于老年代：</p>
<ul>
<li>Serial Old(单线程)<br>  可以通过<code>-XX:+UseSerialOldGC</code>,使得老年代使用该垃圾回收期进行回收<br>  单线程通过标记-整理算法进行收集，在进行垃圾收集时，必须暂停所有的工作线程<br>  简单高效，是Client模式下默认的老年代收集器</li>
<li>Parallel Old(多线程处理)<br>  可以通过<code>-XX:+UseParallelOldGC</code>,使得老年代使用该垃圾回收期进行回收<br>  多线程使用标记-整理算法进行收集，JDK6之后开始提供的，吞吐量优先</li>
<li>CMS<br>  标记-清除算法<br>  垃圾回收线程几乎能与用户线程做到同时工作，只是尽可能缩短了停顿时间<br>  JDK5提出的第一款针对于老年代GC与工作线程并发执行的收集器</li>
</ul>
<h4 id="2-分区模型"><a href="#2-分区模型" class="headerlink" title="2.分区模型"></a>2.分区模型</h4><ul>
<li>G1（1.8可用）</li>
<li>ZGC</li>
<li>Shenandoah</li>
<li>Epsilon(无用)</li>
</ul>
<h4 id="3-关于JDK1-8"><a href="#3-关于JDK1-8" class="headerlink" title="3.关于JDK1.8"></a>3.关于JDK1.8</h4><ul>
<li>1.8默认的垃圾回收器：PS+PO</li>
<li>1.8推荐用G1</li>
</ul>
<h4 id="4-CMS垃圾回收器"><a href="#4-CMS垃圾回收器" class="headerlink" title="4.CMS垃圾回收器"></a>4.CMS垃圾回收器</h4><ul>
<li>中文：concurrent mark sweep</li>
<li>沿着路线在前进：内存越来越大，卡顿时间越来越短</li>
<li>垃圾回收线程和工作线程可以一起并行工作。</li>
<li>大致六个阶段，主要有四个阶段：1.初始标记；2.并发标记；3.重新标记；4.并发清理<br>  1.初始标记：STW的时间很短，降低STW时间；G1垃圾回收器在STW的时间更短<br>  2.并发标记：会跟工作线程发生混乱，会发生错标的问题<br>  3.并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象<br>  4.重新标记：修正那些错标的对象，remark阶段，必须从头扫描一遍，暂停虚拟机，扫描堆中的剩余对象<br>  5.并发清理：也是并发执行，发生错标问题，但是没关系，下次循环可以解决<br>  6.并发重置：重置CMS收集器的数据结构，等待下一次垃圾回收</li>
</ul>
<p><strong>对于三色标记算法产生的漏标问题：</strong>CMS的解决方案为：<code>incremental update</code></p>
<h5 id="5-G1垃圾回收器"><a href="#5-G1垃圾回收器" class="headerlink" title="5.G1垃圾回收器"></a>5.G1垃圾回收器</h5><ul>
<li>既用于新生代，也可以用于老年代的垃圾回收器</li>
<li>使用<code>复制+标记-整理</code>算法进行回收</li>
<li>设计的目的是为了替换掉JDK5中发布的CMS垃圾回收期</li>
<li>并发+并行，使用多个CPU来缩短STW的停顿时间，与用户线程并发执行</li>
<li>分代收集，独立管理整个堆</li>
<li>空间整合，基于标记整理算法，解决了内存碎片的问题</li>
<li>可预测的停顿，能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为n毫秒的时间片段内消耗在垃圾收集上的时间不得超过n毫秒，这个n是可以设置的。</li>
<li>用到了读屏障和写屏障</li>
<li>对于三色标记算法产生的漏标问题，对应的算法为SATB</li>
<li>将整个Java堆内存划分成多个大小相等的Region区</li>
<li>年轻代和老年代不再物理隔离</li>
</ul>
<h5 id="5-触发fullGC的情况"><a href="#5-触发fullGC的情况" class="headerlink" title="5.触发fullGC的情况"></a>5.触发fullGC的情况</h5><ul>
<li>老年代空间不足</li>
<li>永久代空间不足（jdk8之后没有了永久代，该条件不成立，取而代之的是元空间，目的是为了降低fullGC的频率，减少GC的负担，提升效率），只针对1.7</li>
<li>CMS GC时出现promotionfailed,concurrent mode failure</li>
<li>MinorGC晋升到老年代平均大小大于老年代的剩余空间</li>
<li>调用System.gc(),不会立即回收，而是通知jvm进行回收，回收时机需要等底层进行</li>
<li>使用RMI来进行RPC或管理的JDK的应用，每小时执行一次FullGC</li>
</ul>
<h3 id="五-内存模型"><a href="#五-内存模型" class="headerlink" title="五.内存模型"></a>五.内存模型</h3><h4 id="1-分代"><a href="#1-分代" class="headerlink" title="1.分代"></a>1.分代</h4><h5 id="1-1-新生代"><a href="#1-1-新生代" class="headerlink" title="1.1 新生代"></a>1.1 新生代</h5><ul>
<li>新生代就是刚刚new出来的对象</li>
<li>新生代可以理解为大多数一次垃圾回收就能回收掉的对象</li>
<li>在新生代里面用<code>拷贝算法</code>效率极高</li>
<li>年轻代分为三个区域：<code>Eden</code>、2个<code>survivor(幸存者)</code>。比例为：8:1:1</li>
<li>不能回收的对象在两个survivor区中来回存活，直到达到<code>-XX:MaxTenuringThreshold</code>设置的最大年龄则进入老年代，默认为16</li>
<li>CMS的默认的一个对象在新生代的最大年龄为16</li>
<li>新生代空间耗尽触发<code>MinorGC/YGC</code><h5 id="1-2-老年代"><a href="#1-2-老年代" class="headerlink" title="1.2 老年代"></a>1.2 老年代</h5></li>
<li>老年代就是经过了好多次垃圾回收之后老是回收不了的对象</li>
<li>垃圾回收不容易回收掉的对象</li>
<li>在老年代一般用<code>标记清除</code>或者<code>标记整理</code></li>
<li>在老年代无法继续分配空间时触发<code>MajorGC/FullGC</code>，新生代老年代同时进行回收</li>
<li>大对象直接放在老年代（有参数可以确定）</li>
</ul>
<h3 id="六-对象回收步骤"><a href="#六-对象回收步骤" class="headerlink" title="六.对象回收步骤"></a>六.对象回收步骤</h3><ul>
<li>当new一个对象的时候，判断是否可以不在堆上进行分配（可以在栈上进行分配，只要栈pop之后，对象就可以直接被回收，不用被GC所回收），但是这个栈上的对象有两个前提：逃逸分析(一个方法中的对象不能被另一个方法所引用)和标量替换(基础数据类型)</li>
<li>如果对象是个大对象，直接放到老年代</li>
<li>如果不是大对象，不管是不是TLAB（线程本地分配缓冲区），都会进入Eden区，然后进行GC清除，能清除的直接清除。清除不了的进入survivor1区域，年龄够了进入老年代，年龄不够进入survivor2，循环往复。</li>
</ul>
<h3 id="七-GC常用参数"><a href="#七-GC常用参数" class="headerlink" title="七.GC常用参数"></a>七.GC常用参数</h3><ul>
<li>-Xmn:年轻代</li>
<li>-Xms:最小堆内存</li>
<li>-Xmx:最大堆内存</li>
<li>-Xss:栈空间<h4 id="关于G1的参数"><a href="#关于G1的参数" class="headerlink" title="关于G1的参数"></a>关于G1的参数</h4></li>
<li>-XX:+UseG1GC</li>
<li>-XX:MaxGCPauseMillis(建议值，G1会尝试调整young区的块数来达到这个值)</li>
<li>-XX:GCPauseIntervalMillis(GC的间隔时间)</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2019/12/13/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>链表是有序的列表，它在内存中的存储不一定是连续的，有如下几个特点：</p>
<ul>
<li>链表是以节点的方式来存储的，是链式存储</li>
<li>每个节点包含data域、next域（指向下一个节点）</li>
<li>链表的各个节点不一定是连续存储</li>
<li>链表分带头节点的和不带头节点的链表。<a id="more"></a>

</li>
</ul>
<h3 id="关于链表的几个操作"><a href="#关于链表的几个操作" class="headerlink" title="关于链表的几个操作"></a>关于链表的几个操作</h3><p>以下定义都是基于带头节点的链表去实现的(头节点的number值为0)</p>
<h5 id="链表的定义："><a href="#链表的定义：" class="headerlink" title="链表的定义："></a>链表的定义：</h5><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public class <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    public</span> int <span class="keyword">number</span>;</span><br><span class="line">    public <span class="keyword">Node</span> <span class="title">next</span>;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(int</span> <span class="keyword">number</span>) &#123;</span><br><span class="line">        this.<span class="keyword">number</span> = <span class="keyword">number</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="链表的基础操作（增删改查）"><a href="#链表的基础操作（增删改查）" class="headerlink" title="链表的基础操作（增删改查）"></a>链表的基础操作（增删改查）</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public class TestLinkedList &#123;</span><br><span class="line"></span><br><span class="line">    //头节点</span><br><span class="line">    private static <span class="keyword">Node</span> <span class="title">head</span> = new <span class="keyword">Node</span><span class="title">(0</span>);</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node1</span> = new <span class="keyword">Node</span><span class="title">(1</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node2</span> = new <span class="keyword">Node</span><span class="title">(2</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node3</span> = new <span class="keyword">Node</span><span class="title">(3</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node4</span> = new <span class="keyword">Node</span><span class="title">(4</span>);</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">node5</span> = new <span class="keyword">Node</span><span class="title">(5</span>);</span><br><span class="line"></span><br><span class="line">        addByOrder(node1);</span><br><span class="line">        addByOrder(node2);</span><br><span class="line">        addByOrder(node4);</span><br><span class="line">        addByOrder(node3);</span><br><span class="line">        addByOrder(node5);</span><br><span class="line"></span><br><span class="line">        display(head);</span><br><span class="line"></span><br><span class="line">//        modifyNumber(<span class="number">5</span>,<span class="number">100</span>);</span><br><span class="line">//        display(head);</span><br><span class="line">//        System.out.println(<span class="string">&quot;删除节点之前的长度为：&quot;</span>+length(head));</span><br><span class="line">//</span><br><span class="line">//        delete(<span class="number">3</span>);</span><br><span class="line">//        display(head);</span><br><span class="line">//</span><br><span class="line">//        System.out.println(<span class="string">&quot;删除节点之后的长度为：&quot;</span>+length(head));</span><br><span class="line"></span><br><span class="line">//        <span class="keyword">Node</span> <span class="title">revertNode</span> = revert(head);</span><br><span class="line">//        display(revertNode);</span><br><span class="line"></span><br><span class="line">        revertPrint(head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向链表中添加元素</span><br><span class="line">     * @param <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">     */</span></span><br><span class="line"><span class="title">    public</span> static void add(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">temp</span> = head;</span><br><span class="line">        while (temp.next != null)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    /**</span></span><br><span class="line"><span class="title">     * 按照元素大小值排列添加元素</span></span><br><span class="line"><span class="title">     * @param</span> <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">     */</span></span><br><span class="line"><span class="title">    public</span> static void addByOrder(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">        boolean flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">temp</span> = head;</span><br><span class="line">        while (temp.next != null)&#123;</span><br><span class="line">            if (temp.next.<span class="keyword">number</span> &gt; node.<span class="keyword">number</span>)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)&#123;</span><br><span class="line">            <span class="keyword">Node</span> <span class="title">nextNode</span> = temp.next;</span><br><span class="line">            temp.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">            node</span>.next = nextNode;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">        &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">    /**</span></span><br><span class="line"><span class="title">     * 打印链表中的元素</span></span><br><span class="line"><span class="title">     * @param</span> <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">     */</span></span><br><span class="line"><span class="title">    public</span> static void display(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">        if (<span class="keyword">node</span> <span class="title">== null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">temp</span> = node.next;</span><br><span class="line">        while (temp != null )&#123;</span><br><span class="line">            System.out.print(temp.<span class="keyword">number</span> + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改链表中指定索引的<span class="keyword">node</span><span class="title">的值</span></span><br><span class="line"><span class="title">     * @param</span> index 要修改的索引下标</span><br><span class="line">     * @param newNum 需要修改的新值</span><br><span class="line">     */</span><br><span class="line">    public static void modifyNumber(int index ,int newNum)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">temp</span> = head;</span><br><span class="line">        int indexSum = <span class="number">1</span>;</span><br><span class="line">        while (temp.next != null)&#123;</span><br><span class="line">            if (index == indexSum)&#123;</span><br><span class="line">               temp.next.<span class="keyword">number</span> = newNum;</span><br><span class="line">               break;</span><br><span class="line">            &#125;</span><br><span class="line">            indexSum ++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除一个<span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">     * @param</span> index 需要删除的索引下标</span><br><span class="line">     */</span><br><span class="line">    public static void delete(int index)&#123;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">temp</span> = head;</span><br><span class="line">        int indexSum = <span class="number">1</span>;</span><br><span class="line">        while (temp.next != null)&#123;</span><br><span class="line">            if (index == indexSum)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            indexSum ++;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算链表的长度</span><br><span class="line">     * @param <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">     * @return</span></span><br><span class="line">     */</span><br><span class="line">    public static int length(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">        int result = <span class="number">0</span>;</span><br><span class="line">        while (node.next != null)&#123;</span><br><span class="line">            result++;</span><br><span class="line">            <span class="keyword">node</span> <span class="title">= node</span>.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将链表反转"><a href="#将链表反转" class="headerlink" title="将链表反转"></a>将链表反转</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表反转</span></span><br><span class="line"><span class="comment"> * @return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node revert(Node node)&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.<span class="keyword">next</span> == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node revertNode = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    Node cur = node.<span class="keyword">next</span>;</span><br><span class="line">    Node <span class="keyword">next</span> = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//1.保存下一个节点指针</span></span><br><span class="line">        <span class="keyword">next</span> = cur.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//2.将当前节点的下一个节点指向新节点的下一个节点</span></span><br><span class="line">        cur.<span class="keyword">next</span> = revertNode.<span class="keyword">next</span>;</span><br><span class="line">        <span class="comment">//3.新节点的下一个节点指向当前节点</span></span><br><span class="line">        revertNode.<span class="keyword">next</span> = cur;</span><br><span class="line">        <span class="comment">//4.当前节点为下一个节点，继续执行循环</span></span><br><span class="line">        cur = <span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> revertNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将链表反向打印（用stack的方式）"><a href="#将链表反向打印（用stack的方式）" class="headerlink" title="将链表反向打印（用stack的方式）"></a>将链表反向打印（用stack的方式）</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表反向打印（stack方式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> revertPrint(Node node)&#123;</span><br><span class="line">    Node temp = node.<span class="keyword">next</span>;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (temp!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.<span class="keyword">push</span>(temp);</span><br><span class="line">        temp = temp.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.<span class="keyword">size</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        Node <span class="keyword">pop</span> = stack.<span class="keyword">pop</span>();</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="keyword">pop</span>.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="递归打印链表"><a href="#递归打印链表" class="headerlink" title="递归打印链表"></a>递归打印链表</h5><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">public static void printDigui(Node <span class="type">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">node</span><span class="built_in">.number</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="type">node</span><span class="built_in">.number</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">node</span>.<span class="keyword">next</span> != null)&#123;</span><br><span class="line">            printDigui(<span class="type">node</span>.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="将链表反向打印（用递归的方式）"><a href="#将链表反向打印（用递归的方式）" class="headerlink" title="将链表反向打印（用递归的方式）"></a>将链表反向打印（用递归的方式）</h5><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">//默认认为头节点<span class="built_in">的number</span>的值为<span class="number">0</span></span><br><span class="line">public static void printDigui(Node <span class="type">node</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">node</span>.<span class="keyword">next</span> != null)&#123;</span><br><span class="line">            printDigui(<span class="type">node</span>.<span class="keyword">next</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">node</span><span class="built_in">.number</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="type">node</span><span class="built_in">.number</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将链表两两反转"><a href="#将链表两两反转" class="headerlink" title="将链表两两反转"></a>将链表两两反转</h5><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 链表两两反转</span><br><span class="line"> * @param <span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title"> * @return</span></span><br><span class="line"> */</span><br><span class="line">public static <span class="keyword">Node</span> <span class="title">revertNode</span>(<span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">head</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    while</span>(head.next != null &amp;&amp; head.next.next != null)&#123;</span><br><span class="line">        // 开始反转</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">next1</span> = head.next;</span><br><span class="line">        <span class="keyword">Node</span> <span class="title">next2</span> = next1.next;</span><br><span class="line">        head.next = next2;</span><br><span class="line">        next1.next = next2.next;</span><br><span class="line">        next2.next = next1;</span><br><span class="line">        // dummy 指针前移</span><br><span class="line">        head = next1;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>面试准备</title>
    <url>/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<meta name="referrer" content="no-referrer">

<h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h1><h2 id="1-hashmap"><a href="#1-hashmap" class="headerlink" title="1.hashmap"></a>1.hashmap</h2><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并且允许null键和null值。不保证顺序。</p>
<h3 id="1-1-7与8的区别"><a href="#1-1-7与8的区别" class="headerlink" title="1.1 7与8的区别"></a>1.1 7与8的区别</h3><p>hashmap初始容量都是16，扩容因子是0.75倍.当元素的数量达到了<code>16*0.75=12</code>的时候，会进行扩容。<br>底层：数组+链表。数组中的元素存放的是entry的引用</p>
<ul>
<li>jdk8中会将链表转化为红黑树（红黑树的查询插入效率介于链表和二叉树之间）</li>
<li>新节点插入链表的顺序不同（jdk7是插入头节点，jdk8因为要遍历链表把链表变为红黑树所以采用插入尾结点）</li>
<li>hash算法简化。因为使用了红黑树，即使散列不均匀查询效率也不会很低。</li>
<li>resize的逻辑修改（jdk7会出现死循环，jdk8不会），resize方法完成了初始化和扩容。</li>
</ul>
<a id="more"></a>
<blockquote>
<p>1.在put的时候一开始初始化的时候要用比阈值大的2的次方数。</p>
</blockquote>
<blockquote>
<p>2.在hash算法中，首先对其key的hashcode进行抑或操作，目的就是控制散列值在数组size中，但是在抑或之后还要对key的hashcode进行右移，目的就是让其高位参与运算，使得散列更为均匀。</p>
</blockquote>
<blockquote>
<p>3.jdk1.7中在对hashmap进行扩容的时候，由于使用的是头插法，就可能会导致出现死循环的问题，发生死锁。因为1.7是循环遍历，1.8是先判断元素是要放在高位还是低位，然后将low的元素和high的元素分别组合起来放到新的扩容数组中</p>
</blockquote>
<blockquote>
<p>4.jdk1.8当hash相同的链表中的node超过阈值（8）的时候并且数组的长度小于64的时候，会进行扩容；如果数组的长度大于64，会将当前下标指向的这个链表转化为红黑树。</p>
</blockquote>
<blockquote>
<p>5.链表转化为红黑树：先比较key的hashcode；如果相同则去看key有没有实现comparable接口，如果实现了则进行比较；如果没有实现或者相同，则会比较key的class的名字；如果key的className相同则会调同<code>System.identityHashcode</code>方法去进行比较jvm内部的hashcode。然后根据插入的元素进行红黑树root节点的调整。一个node节点既是红黑树的节点，同时也是双向链表的节点，因为它继承了hashmap的entry类。扩容的时候遍历双向链表，同样先判断元素是要放在高位还是低位.</p>
</blockquote>
<h3 id="1-2遍历方式"><a href="#1-2遍历方式" class="headerlink" title="1.2遍历方式"></a>1.2遍历方式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Iterator</span>&lt;Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">Integer</span>&gt;&gt; entryIterator = map.entrySet().<span class="built_in">iterator</span>();</span><br><span class="line">        <span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;<span class="keyword">String</span>, <span class="keyword">Integer</span>&gt; next = entryIterator.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + next.getKey() + <span class="string">&quot; value=&quot;</span> + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Iterator</span>&lt;<span class="keyword">String</span>&gt; <span class="built_in">iterator</span> = map.keySet().<span class="built_in">iterator</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">iterator</span>.hasNext())&#123;</span><br><span class="line">            <span class="keyword">String</span> key = <span class="built_in">iterator</span>.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;key=&quot;</span> + key + <span class="string">&quot; value=&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-Concurrenthashmap"><a href="#2-Concurrenthashmap" class="headerlink" title="2.Concurrenthashmap"></a>2.Concurrenthashmap</h2><h3 id="jdk1-7"><a href="#jdk1-7" class="headerlink" title="jdk1.7"></a>jdk1.7</h3><p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/concurrent1" alt="concurrent构成"></p>
<p>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<p>它的核心成员变量：</p>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line">    * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。</span><br><span class="line">    */</span><br><span class="line">   final Segment&lt;<span class="keyword">K</span>,V&gt;[] segments;</span><br><span class="line">   transient <span class="keyword">Set</span>&lt;<span class="keyword">K</span>&gt; keySet;</span><br><span class="line">   transient <span class="keyword">Set</span>&lt;<span class="keyword">Map</span>.Entry&lt;<span class="keyword">K</span>,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure>

<p>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p>
<p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</p>
<p><strong>[put]</strong></p>
<ul>
<li><p>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</p>
</li>
<li><p>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</p>
</li>
<li><p>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</p>
</li>
<li><p>最后会解除在 1 中所获取当前 Segment 的锁</p>
</li>
</ul>
<p><strong>[get]</strong></p>
<ul>
<li><p>只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。</p>
</li>
<li><p>由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。</p>
</li>
<li><p>ConcurrentHashMap 的 get 方法是非常高效的，因为整个过程都不需要加锁。</p>
</li>
</ul>
<h3 id="jdk1-8"><a href="#jdk1-8" class="headerlink" title="jdk1.8"></a>jdk1.8</h3><p>抛弃了原有的 Segment 分段锁，而采用了 <code>CAS + synchronized</code> 来保证并发安全性。</p>
<p>也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。</p>
<p>其中的 val next 都用了 volatile 修饰，保证了可见性。</p>
<p><strong>[put]</strong></p>
<ul>
<li><p>根据 key 计算出 hashcode 。</p>
</li>
<li><p>判断是否需要进行初始化。</p>
</li>
<li><p>f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
</li>
<li><p>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</p>
</li>
<li><p>如果都不满足，则利用 synchronized 锁写入数据。</p>
</li>
<li><p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p>
</li>
</ul>
<p><strong>[get]</strong></p>
<ul>
<li><p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p>
</li>
<li><p>如果是红黑树那就按照树的方式获取值。</p>
</li>
<li><p>不满足那就按照链表的方式遍历获取值。</p>
</li>
</ul>
<blockquote>
<p>1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（O(logn)），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。</p>
</blockquote>
<h2 id="3-内存相关"><a href="#3-内存相关" class="headerlink" title="3.内存相关"></a>3.内存相关</h2><h3 id="3-1-对象在内存中的布局：（4部分）"><a href="#3-1-对象在内存中的布局：（4部分）" class="headerlink" title="3.1 对象在内存中的布局：（4部分）"></a>3.1 对象在内存中的布局：（4部分）</h3><ul>
<li><code>markword</code> :标记字，8字节（64位的话，给8字节），记录的是锁信息、hashcode、gc垃圾回收信息</li>
<li><code>class pointer</code>:类型指针。（创建一个Object类型，就是Object.class）</li>
<li><code>instance data</code>:实例数据，一个类中的成员变量（8种基本数据类型和引用数据类型）</li>
<li><code>padding</code>:对齐，为了能够让上述三部分相加起来的字节数能够让8整除，多添加几个字节，目的是为了提高cpu的利用率。</li>
</ul>
<p>一个Object对象，占16个字节，8个标记字，4个class pointer,还有4个对齐</p>
<h3 id="3-2-锁升级"><a href="#3-2-锁升级" class="headerlink" title="3.2 锁升级"></a>3.2 锁升级</h3><p>java上的实现都是小端在前，大端在后；网络上的实现都是大端在前</p>
<ul>
<li>new出来对象之后，优先上的锁叫偏向锁，偏向第一个进去做事的线程。偏向锁的意思就是当前线程的指针被记录在了markword里面，偏向锁严格来讲不是一把锁，它就是一个标志，表示这个锁归我了。</li>
<li>偏向锁不需要锁竞争，只需要第一个来的线程就直接给他上了这个锁，没有竞争，就少了同步，效率就会提升。</li>
</ul>
<p><strong>为什么要设计偏向锁？</strong></p>
<p>设计偏向锁的原因在于提高效率，因为这个锁相当于给了一个标记，标记它不需要去参与竞争。</p>
<p><strong>如果第二个线程来了怎么办？</strong></p>
<p>1&gt;这个时候锁升级，升级为自旋锁（轻量级锁）。<br>2&gt;自旋锁又会升级为重量级锁</p>
<p><strong>那么什么时候自旋锁会升级为重量级锁？</strong></p>
<p>竞争加剧：有一个线程超过10次自旋，或者自旋线程超过CPU核数的一半，就会升级。1.6之后，加入自适应自旋AdapativeSlefSpinning，JVM自己控制</p>
<h4 id="3-2-1-自旋锁和重量级锁的区别"><a href="#3-2-1-自旋锁和重量级锁的区别" class="headerlink" title="3.2.1 自旋锁和重量级锁的区别"></a>3.2.1 自旋锁和重量级锁的区别</h4><p>自旋是发生在用户空间的，它不经过os对线程的调度。一般来讲，只要调用了<code>wait()</code>、<code>notify()</code>等方法，就进入到了重量级锁的状态了。重量级状态是什么状态呢？这把锁，附着着一个队列，这个队列的专业叫法叫<code>waitSet</code>,<code>waitSet</code>这里面的线程都是排好队的，等着操作系统调度才能拿到锁，这个<code>waitSet</code>就是等待队列。区别就在于，自旋锁是大家相互抢，谁抢着锁算谁的，而重量级锁是大家都进入到一个等待队列中去，等着操作系统老大去进行调度拿锁。自旋锁在等待的时候消耗cpu资源，而重量级锁在等待的时候不需要消耗cpu资源。</p>
<h4 id="3-2-2-偏向锁的时延："><a href="#3-2-2-偏向锁的时延：" class="headerlink" title="3.2.2 偏向锁的时延："></a>3.2.2 偏向锁的时延：</h4><p>偏向锁是在jvm启动之后的4秒后开始启动，偏向锁启动之后，给对象上的偏向锁都是匿名偏向。<code>为什么是4秒？</code>原因是jvm启动的过程一定会有锁竞争，因此就没有必要启动这把偏向锁，等jvm启动之后，再启动偏向锁</p>
<h4 id="3-2-3-偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？"><a href="#3-2-3-偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？" class="headerlink" title="3.2.3 偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？"></a>3.2.3 偏向锁的效率是不是一定比自旋锁的效率高？打开偏向锁是不是效率一定会提升？</h4><p>不一定，因为偏向锁是希望没有锁竞争的，但是如果你明明知道会有锁竞争，还去加偏向锁，没有任何意义。</p>
<blockquote>
<p>注意：偏向锁是锁的类型，可重入锁是锁的机制，两个不是一个概念。</p>
</blockquote>
<h3 id="3-3-volatile关键字"><a href="#3-3-volatile关键字" class="headerlink" title="3.3 volatile关键字"></a>3.3 volatile关键字</h3><p>作用：</p>
<ul>
<li>1、线程间可见<br>  A线程将变量的值更改了，另一个线程需要知道</li>
<li>2、禁止指令重排序<br>  指令重排序：在程序运行中，可能后面的代码比前面的代码先执行（前提是后面的代码不依赖于前面的代码情况下，为了提高cpu利用率，会这样运行）<br>  禁止重排序原理：在两条指令中间加了一层屏障：JSR内存屏障（分四种：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障）<br>  load是读，store是写</li>
</ul>
<h4 id="3-3-1-汇编语言的lock指令"><a href="#3-3-1-汇编语言的lock指令" class="headerlink" title="3.3.1 汇编语言的lock指令:"></a>3.3.1 汇编语言的lock指令:</h4><ul>
<li>用于在多处理器中执行指令时对共享内存的独占使用</li>
<li>它的作用是能够将当前处理器对应缓存的内容刷新到内存，并使其他处理器对应的缓存失效。</li>
<li>另外还提供了有序的指令无法越过这个内存屏障的作用。</li>
<li>lock addl实现了volatile的两个作用</li>
</ul>
<h3 id="3-4-Java和go"><a href="#3-4-Java和go" class="headerlink" title="3.4 Java和go"></a>3.4 Java和go</h3><ul>
<li>Java的线程和内核线程是一对一的。</li>
<li>Go的线程和内核是M:N的，而且M远大于N</li>
<li>Java中的线程池：<code>forkjoinPool</code>,每一个线程都有自己的任务队列，但是任务和任务之间它们是不能做同步的，就是说我这个任务执行完了才能执行下一个任务。但是go的routin任务和任务之间是可以同步的，在用户空间模拟了cpu的执行，有类似保存现场恢复现场的功能。</li>
</ul>
<h1 id="二-设计模式"><a href="#二-设计模式" class="headerlink" title="二.设计模式"></a>二.设计模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><h3 id="1-1-饿汉"><a href="#1-1-饿汉" class="headerlink" title="1.1 饿汉"></a>1.1 饿汉</h3><ul>
<li>对外提供一个返回该实例的方法，static用来在jvm启动过程中去创建对象，构造方法私有化，以此来保证在程序运行过程中用到的对象都是只有一个实例。</li>
<li>类加载到内存后，就会实例化一个单例，JVM保证线程安全。</li>
<li>简单实用，推荐使用。</li>
<li>唯一缺点：类装载的时候就完成实例化，不管你是否需要用到它。</li>
</ul>
<h3 id="1-2懒汉："><a href="#1-2懒汉：" class="headerlink" title="1.2懒汉："></a>1.2懒汉：</h3><ul>
<li>什么时候需要用，才会将这个实例给new出来，但是是线程不安全的，因为同一时刻如果多个线程都需要这个实例，产生出来的就不止一个对象，很简单的优化方式就是加synchronized锁，以此来保证只有一个实例。 但是这种锁的粒度太大了，如果在getInstance方法中有业务代码，那么会锁定相关的业务代码。所以就牵涉到一个优化问题</li>
<li>引入DCL：double check lock</li>
</ul>
<p>相关代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public class Mgr01 &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile Mgr01 INSTANCE;</span><br><span class="line">    private Mgr01()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Mgr01 getInstance()&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            synchronized (Mgr01.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span> )&#123;</span><br><span class="line">                   <span class="built_in"> INSTANCE </span>= new Mgr01();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DCl不能乱序，所以DCL一定要加volatile。因为在初始化一个对象的时候，在汇编层面有5条指令，大体的流程就是：开辟内存空间-&gt;成员变量初始化-&gt;引用绑定，之所以要用volatile就是为了不让其指令发生重排序，如果不加的话，可能第二步和第三步发生指令重排序，导致成员没有初始化就将引用绑定给变量了，那么其他线程用这个类的实例的时候就会出现问题。</p>
<h1 id="三、存储层"><a href="#三、存储层" class="headerlink" title="三、存储层"></a>三、存储层</h1><h2 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1.Mysql"></a>1.Mysql</h2><h4 id="1-1-隔离级别"><a href="#1-1-隔离级别" class="headerlink" title="1.1 隔离级别"></a>1.1 隔离级别</h4><ul>
<li>读未提交<br>  脏读</li>
<li>读已提交<br>  不可重复读</li>
<li>可重复度*（mysql默认的隔离级别）<br>  幻读</li>
<li>可序列化</li>
</ul>
<h4 id="1-2-事务隔离级别实现原理"><a href="#1-2-事务隔离级别实现原理" class="headerlink" title="1.2 事务隔离级别实现原理"></a>1.2 事务隔离级别实现原理</h4><h5 id="1-2-1-事务隔离的实现-mvcc，多版本并发控制"><a href="#1-2-1-事务隔离的实现-mvcc，多版本并发控制" class="headerlink" title="1.2.1 事务隔离的实现-mvcc，多版本并发控制"></a>1.2.1 事务隔离的实现-mvcc，多版本并发控制</h5><p>在mysql中，不管一个表的数据结构定义成什么样，都会有两个隐藏列：</p>
<ul>
<li>trx_id:每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer:每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ul>
<p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="mvcc"></p>
<p><strong>mvcc的流程</strong></p>
<ul>
<li>1.事务在查询数据之前，会生成数据库系统当前的一个快照（read view），记录并维护系统当前<code>活跃事务的ID</code>,快照里面存着的是当前时间<code>活跃的事务id</code></li>
<li>2.把快照比作条件用来判断当前事务能够看到哪个版本的数据</li>
<li>3.快照是在<code>查询数据</code>时生成的。</li>
</ul>
<p><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="mvcc"></p>
<p>总结：拿着数据比对版本，而不是拿着版本找数据。</p>
<ul>
<li>不同的隔离级别底层就是因为他们的快照不一样。</li>
<li>读未提交就是根本没有快照，每次修改了不用提交就是一个新的版本。每次读都是一次全新的搜索</li>
<li>可重复读是在第一次查询数据的时候生成一次快照，只要我还没提交，我就不会改变我的快照，所以叫可重复读。</li>
<li>序列化就是我不存在快照，就是串行执行，没有并发的概念。</li>
</ul>
<h4 id="1-2-幻读是什么？"><a href="#1-2-幻读是什么？" class="headerlink" title="1.2 幻读是什么？"></a>1.2 幻读是什么？</h4><ul>
<li>幻读主要体现在读-写冲突上，而不可重复读主要体现在读-读冲突上</li>
<li>比如A事务开启之后，读了4条数据，而B事务同时插入了命中A查询条件中的一条数据。A查询之后进行了update，update语句是不会去管快照的，他会直接从B-tree上去读数据，但是这个时候B-tree上有5条数据，它的快照上还是4条，更新之后再次查询，查出了5条，这种现象就是幻读。</li>
<li>为什么是5条？因为在update的时候在trx_id这个隐藏列中有了A事务的事务id，所以在更新之后查询能查得到。</li>
</ul>
<h4 id="1-3-锁"><a href="#1-3-锁" class="headerlink" title="1.3 锁"></a>1.3 锁</h4><ul>
<li>行锁，表锁—-&gt;锁的粒度</li>
<li>乐观锁，悲观锁—-&gt;锁的时机</li>
<li>共享锁，排他锁—-&gt;锁的兼容性</li>
</ul>
<p>mysql的官方文档中有<code>8</code>种锁模式</p>
<ul>
<li>索引锁<br>  记录存在与否和事务加锁成功与否无关，如SELECT * FROM user WHERE id = 5 FOR UPDATE，此时id=5的记录不存在，隔壁事务仍然无法插入记录（假设当前自增的主键id已经是4了）。因为锁定的是索引，故记录实体存在与否没关系。</li>
<li>间隙锁</li>
<li>临键锁<br>  间隙锁一定是开区间，临键锁是是一个左开右闭的区间<br>  间隙锁是不互斥的，即两个事务可以同时持有包含共同间隙的间隙锁。<br>  在RR级别下，如果你使用select … in share mode或者select … for update语句，那么InnoDB会使用临键锁，因而可以防止幻读</li>
<li>共享锁/排他锁</li>
<li>意向共享锁/意向排他锁<br>  共享锁/排他锁都只是行锁，意向共享锁/意向排他锁属于表锁<br>  取得意向共享锁/意向排他锁是取得共享锁/排他锁的前置条件<br>  一个事务在请求共享锁/排他锁时，获取到的结果却可能是行锁，也可能是间隙锁，也可能是临键锁</li>
<li>插入意向锁<br>  插入意向锁是一种特殊的间隙锁<br>  两个事务却不能在同一时间内一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）</li>
<li>自增锁</li>
<li>预测锁<br>  自增锁是一种特殊的表级锁，主要用于事务中插入自增字段，也就是我们最常用的自增主键id。<br>  自增锁有3种模式，决定了并发自增时并发的自增语句如何持有锁</li>
</ul>
<h1 id="四-Java底层"><a href="#四-Java底层" class="headerlink" title="四.Java底层"></a>四.Java底层</h1><h2 id="1-锁"><a href="#1-锁" class="headerlink" title="1.锁"></a>1.锁</h2><ul>
<li>引入锁，目的是为了保证数据一致性。</li>
<li>锁住的一定是一个对象，而且同一时刻只能有一个线程拥有锁去做业务逻辑处理</li>
</ul>
<h2 id="2-不持有锁的线程怎么办？"><a href="#2-不持有锁的线程怎么办？" class="headerlink" title="2.不持有锁的线程怎么办？"></a>2.不持有锁的线程怎么办？</h2><ul>
<li>自旋：轻量级锁。</li>
<li>进入等待队列，等待操作系统调度，这个时候是重量级锁。</li>
</ul>
<h2 id="3-synchronized关键字"><a href="#3-synchronized关键字" class="headerlink" title="3.synchronized关键字"></a>3.synchronized关键字</h2><ul>
<li>1.在早期1.0~1.2的时候，操作系统会接管对应的线程，是个重量级锁，效率非常低。</li>
<li>2.jdk1.5之后，诞生了<code>JUC</code>包</li>
<li>3.锁升级：偏向锁（没有竞争）—&gt;轻量级锁（重量级锁）—&gt;重量级锁</li>
</ul>
<h3 id="3-1-AtomicInteger"><a href="#3-1-AtomicInteger" class="headerlink" title="3.1 AtomicInteger"></a>3.1 AtomicInteger</h3><ul>
<li><code>incrementAndGet()</code>用到的就是自旋锁。在这个方法的底层调用的是<code>compareAndSwapInt</code>，比较并交换，简写为<code>CAS</code>.</li>
</ul>
<p><strong>什么叫CAS？</strong></p>
<p>CAS不需要操作系统的调度，只需要在用户空间即可解决。<br><img src="/2020/10/23/%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="cas"></p>
<h3 id="3-2-CAS两大面试题"><a href="#3-2-CAS两大面试题" class="headerlink" title="3.2 CAS两大面试题"></a>3.2 CAS两大面试题</h3><h4 id="3-2-1-ABA问题加版本号即可解决"><a href="#3-2-1-ABA问题加版本号即可解决" class="headerlink" title="3.2.1 ABA问题加版本号即可解决"></a>3.2.1 ABA问题加版本号即可解决</h4><h4 id="3-2-2-CAS修改值的时候的原子性问题"><a href="#3-2-2-CAS修改值的时候的原子性问题" class="headerlink" title="3.2.2 CAS修改值的时候的原子性问题"></a>3.2.2 CAS修改值的时候的原子性问题</h4><ul>
<li>Q:当线程A在判断原值E是否是原值之后，还没有修改之前，如何保证没有其他线程B对其变量进行修改？</li>
<li>A:CAS在最底层是用<code>lock cmpxchg</code>指令来支撑的。在多核cpu下，lock指令是锁总线的作用。最终的CAS实现就是这条指令。</li>
</ul>
<h2 id="4-生成一个对象的过程？"><a href="#4-生成一个对象的过程？" class="headerlink" title="4.生成一个对象的过程？"></a>4.生成一个对象的过程？</h2><p>至少需要三步：</p>
<ul>
<li>1.申请内存空间，用来装new出来的对象。</li>
<li>2.调用构造方法，从默认值变成初始值，此时是半初始化状态</li>
<li>3.建立引用连接</li>
</ul>
<h2 id="5-happens-before原则（JVM规定重排序必须遵守的原则）"><a href="#5-happens-before原则（JVM规定重排序必须遵守的原则）" class="headerlink" title="5.happens-before原则（JVM规定重排序必须遵守的原则）"></a>5.happens-before原则（JVM规定重排序必须遵守的原则）</h2><ul>
<li><code>as if serial</code>:不管如何重排序，单线程执行结果不会改变</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
</search>
